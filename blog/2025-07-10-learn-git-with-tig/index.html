<!doctype html>
<html lang="ko" data-bs-theme="auto">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><link rel="preload" href="https://mycodingshub.github.io/fonts/vendor/jost/jost-v4-latin-regular.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="https://mycodingshub.github.io/fonts/vendor/jost/jost-v4-latin-500.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="https://mycodingshub.github.io/fonts/vendor/jost/jost-v4-latin-700.woff2" as="font" type="font/woff2" crossorigin>
<script 
  src="/js/color-mode.86a91f050a481d0a3f0c72ac26543cb6228c770875981c58dcbc008fd3f875c8.js"
  integrity="sha256-hqkfBQpIHQo/DHKsJlQ8tiKMdwh1mBxY3LwAj9P4dcg=">
</script>


<link rel="stylesheet" href="/main.86b7305f5a96b7dd3a46fa6277d87b125af3bf13f48c4cfcc269be84fa9e8fb75375d45a5fe9056ce9190644b7a6e5f13f917f12d853ed38bb76d8856898f755.css" integrity="sha512-hrcwX1qWt906Rvpid9h7ElrzvxP0jEz8wmm+hPqej7dTddRaX+kFbOkZBkS3puXxP5F/EthT7Ti7dtiFaJj3VQ==" crossorigin="anonymous">

<noscript><style>img.lazyload { display: none; }</style></noscript><title>Visual Git 마스터하기 - Tig를 활용한 인터랙티브 Git 강좌</title>
<meta name="description" content="Tig를 사용하여 Git을 시각적, 상호작용적으로 마스터하세요. Tig는 혼란스러운 명령어를 명확하고 직관적인 히스토리 그래프로 바꿔주는 강력한 텍스트 모드 인터페이스입니다." />
<link rel="canonical" href="https://mycodingshub.github.io/blog/2025-07-10-learn-git-with-tig/" />
<meta name="robots" content="index, follow" />

<meta property="og:type" content="article" />
<meta property="og:title" content="Visual Git 마스터하기 - Tig를 활용한 인터랙티브 Git 강좌" />
<meta property="og:description" content="Tig를 사용하여 Git을 시각적, 상호작용적으로 마스터하세요. Tig는 혼란스러운 명령어를 명확하고 직관적인 히스토리 그래프로 바꿔주는 강력한 텍스트 모드 인터페이스입니다." />
<meta property="og:url" content="https://mycodingshub.github.io/blog/2025-07-10-learn-git-with-tig/" />
<meta property="og:site_name" content="Home" />
<meta property="og:image" content="https://mycodingshub.github.io/cover.png" />
<meta property="og:locale" content="en" />
<meta property="article:published_time" content="2025-07-09T13:44:32Z" />
<meta property="article:modified_time" content="2025-07-09T13:44:32Z" />
<meta property="article:tag" content="git" />
<meta property="article:tag" content="tig" />
<meta property="article:tag" content="visual git" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:title" content="Visual Git 마스터하기 - Tig를 활용한 인터랙티브 Git 강좌" />
<meta name="twitter:description" content="Tig를 사용하여 Git을 시각적, 상호작용적으로 마스터하세요. Tig는 혼란스러운 명령어를 명확하고 직관적인 히스토리 그래프로 바꿔주는 강력한 텍스트 모드 인터페이스입니다." />
<meta name="twitter:image" content="https://mycodingshub.github.io/cover.png" />

<meta name="author" content="cpro95@gmail.com" />

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "\"Visual Git 마스터하기 - Tig를 활용한 인터랙티브 Git 강좌\"",
  "description": "\"Tig를 사용하여 Git을 시각적, 상호작용적으로 마스터하세요. Tig는 혼란스러운 명령어를 명확하고 직관적인 히스토리 그래프로 바꿔주는 강력한 텍스트 모드 인터페이스입니다.\"",
  "datePublished": "\"2025-07-09T13:44:32Z\"",
  "dateModified": "\"2025-07-09T13:44:32Z\"",
  "author": {
    "@type": "Person",
    "name": "\"cpro95@gmail.com\""
  },
  "image": "\"https://mycodingshub.github.io/cover.png\"",
  "url": "\"https://mycodingshub.github.io/blog/2025-07-10-learn-git-with-tig/\"",
  "publisher": {
    "@type": "Organization",
    "name": "\"Home\""
  }
}
</script>




<script async src="https://www.googletagmanager.com/gtag/js?id=G-C7SBETWEJ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-C7SBETWEJ0');
</script>


<script
  async
  src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7748316956330968"
  crossOrigin="anonymous"
></script>


</head>

  
  <body class="single section blog" data-bs-spy="scroll" data-bs-target="#toc" data-bs-root-margin="0px 0px -60%" data-bs-smooth-scroll="true" tabindex="0">
    <div class="sticky-top">
<header class="navbar navbar-expand-sm">
  <div class="container-lg">
  <div class="d-flex flex-grow-1 justify-content-between">
    <div class="d-flex flex-row navbar-nav justify-content-between align-items-start gap-2">
    
    <a class="nav-link fw-bold fs-4" href="/">Home</a>

    
    
            <a class="nav-link fs-4  active" href="https://mycodingshub.github.io/blog/" aria-current="true">Blog</a>
          
        
            <a class="nav-link fs-4 " href="https://mycodingshub.github.io/life/">Life</a>
          
        
    </div>
    <div class="d-flex flex-row justify-content-between align-items-center">
      
      
      <button type="button" id="searchToggleMobile" class="btn btn-link nav-link mx-2 d-lg-none" aria-label="Search website">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
          <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
          <circle cx="10" cy="10" r="7"></circle>
          <line x1="21" y1="21" x2="15" y2="15"></line>
        </svg>
      </button>
      
      
      <button type="button" id="searchToggleDesktop" class="btn btn-link nav-link p-2 d-none d-lg-block" aria-label="Search website">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
          <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
          <circle cx="10" cy="10" r="7"></circle>
          <line x1="21" y1="21" x2="15" y2="15"></line>
        </svg>
      </button>
      
      <button id="buttonColorMode" class="btn btn-link mx-auto nav-link p-0 ms-lg-2 me-lg-1" type="button" aria-label="Toggle theme">
        <svg data-bs-theme-value="dark" xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-moon" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
          <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
          <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
        </svg>
        <svg data-bs-theme-value="light" xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-sun" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
          <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
          <path d="M12 12m-4 0a4 4 0 1 0 8 0a4 4 0 1 0 -8 0m-5 0h1m8 -9v1m8 8h1m-9 8v1m-6.4 -15.4l.7 .7m12.1 -.7l-.7 .7m0 11.4l.7 .7m-12.1 -.7l-.7 .7"></path>
        </svg>
      </button>
      </div>
        
        
        
        
        </div>
    </div>

    
    </div>
</header>
</div>

<div class="modal" id="searchModal" tabindex="-1" aria-labelledby="searchModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-fullscreen-md-down">
    <div class="modal-content">
      <div class="modal-header">
        <h1 class="modal-title fs-5 visually-hidden" id="searchModalLabel">Search</h1>
        <button type="button" class="btn-close visually-hidden" data-bs-dismiss="modal" aria-label="Close"></button>
        <div class="search-input flex-grow-1 d-none">
          <form id="search-form" class="search-form" action="#" method="post" accept-charset="UTF-8" role="search">
            <label for="query" class="visually-hidden">Search</label>
            <div class="d-flex">
              <input type="search" id="query" name="query" class="search-text form-control form-control-lg" placeholder="Search" aria-label="Search" maxlength="128" autocomplete="off">
              <button type="button" class="btn btn-link text-decoration-none px-0 ms-3 d-md-none" data-bs-dismiss="modal" aria-label="Close">Cancel</button>
            </div>
          </form>
        </div>
      </div>
      <div class="modal-body">
        <p class="search-loading status message d-none mt-3 text-center">Loading search index…</p>
        <p class="search-no-recent message d-none mt-3 text-center">No recent searches</p>
        <p class="search-no-results message d-none mt-3 text-center">No results for "<strong><span class="query-no-results">Query here</span></strong>"</p>
        <div id="searchResults" class="search-results"></div>
        <template>
          <article class="search-result list-view">
            <div class="card my-3">
              <div class="card-body">
                <header>
                  <h2 class="h5 title title-submitted mb-0"><a class="stretched-link text-decoration-none text-reset" href="#">Title here</a></h2>
                  <div class="submitted d-none"><time class="created-date">Date here</time></div>
                </header>
                <div class="content">Summary here</div>
              </div>
            </div>
          </article>
        </template>
      </div>
      <div class="modal-footer">
        <ul class="list-inline me-auto d-none d-md-block">
          <li class="list-inline-item"><kbd class="me-2"><svg width="15" height="15" aria-label="Enter key" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M12 3.53088v3c0 1-1 2-2 2H4M7 11.53088l-3-3 3-3"></path></g></svg></kbd><span class="DocSearch-Label">to select</span></li>
          <li class="list-inline-item"><kbd class="me-2"><svg width="15" height="15" aria-label="Arrow down" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M7.5 3.5v8M10.5 8.5l-3 3-3-3"></path></g></svg></kbd><kbd class="me-2"><svg width="15" height="15" aria-label="Arrow up" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M7.5 11.5v-8M10.5 6.5l-3-3-3 3"></path></g></svg></kbd><span class="DocSearch-Label">to navigate</span></li>
          <li class="list-inline-item"><kbd class="me-2"><svg width="15" height="15" aria-label="Escape key" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M13.6167 8.936c-.1065.3583-.6883.962-1.4875.962-.7993 0-1.653-.9165-1.653-2.1258v-.5678c0-1.2548.7896-2.1016 1.653-2.1016.8634 0 1.3601.4778 1.4875 1.0724M9 6c-.1352-.4735-.7506-.9219-1.46-.8972-.7092.0246-1.344.57-1.344 1.2166s.4198.8812 1.3445.9805C8.465 7.3992 8.968 7.9337 9 8.5c.032.5663-.454 1.398-1.4595 1.398C6.6593 9.898 6 9 5.963 8.4851m-1.4748.5368c-.2635.5941-.8099.876-1.5443.876s-1.7073-.6248-1.7073-2.204v-.4603c0-1.0416.721-2.131 1.7073-2.131.9864 0 1.6425 1.031 1.5443 2.2492h-2.956"></path></g></svg></kbd><span class="DocSearch-Label">to close</span></li>
        </ul>
        <p class="d-md-none">Search by <a class="text-decoration-none" href="https://github.com/nextapps-de/flexsearch">FlexSearch</a></p>
      </div>
    </div>
  </div>
</div>


    <div class="wrap container-lg" role="document">
      <div class="content">
      
        
<article>
  <div class="row justify-content-center">
    <div class="col-md-12 col-lg-12">
      
      <ins class="adsbygoogle"
        style="display:block"
        data-ad-client="ca-pub-7748316956330968"
        data-ad-slot="2971373181"
        data-ad-format="auto"
        data-full-width-responsive="true"></ins>
      <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
      </script>
      <div class="blog-header">
        <h1>Visual Git 마스터하기 - Tig를 활용한 인터랙티브 Git 강좌</h1>
        <p>
  <small>July 9, 2025<span class="stretched-link position-relative reading-time text-nowrap" title="Estimated reading time"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
        <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
        <path d="M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0"></path>
        <path d="M12 7v5l3 3"></path>
      </svg>31&nbsp;minutes</span></small>
</p>

      </div>
    </div>
      <div class="col-md-12 col-lg-12">
      
      <h2 id="모듈-1-첫걸음---git과-tig-그리고-첫-만남"><strong>모듈 1: 첫걸음 - Git과 Tig, 그리고 첫 만남</strong></h2>
<p><strong>강좌 목표:</strong> Git과 Tig의 필요성을 이해하고, 직접 설치하여 첫 커밋 히스토리를 <code>tig</code>로 확인하는 경험을 합니다.</p>
<p>&lsquo;명령어의 결과&rsquo;를 &lsquo;시각적인 히스토리&rsquo;로 인식하는 첫 단추를 끼웁니다.</p>
<hr>
<h3 id="1-intro-왜-git을-써야-할까-버전-관리의-필요성"><strong>1. Intro: 왜 Git을 써야 할까? (버전 관리의 필요성)</strong></h3>
<p>혹시 이런 경험 없으신가요?</p>
<p><code>최종_보고서.docx</code>, <code>진짜_최종_보고서.docx</code>, <code>이게진짜최종_보고서_수정1.docx</code>&hellip;</p>
<p>프로젝트 파일이 복잡해질수록 우리는 파일명에 의존해 버전을 관리하곤 합니다.</p>
<p>하지만 이건 매우 위험하고 비효율적인 방법입니다.</p>
<p>만약 동료와 함께 이 파일을 수정한다면요? 누가 어떤 부분을 수정했는지, 실수로 중요한 내용을 삭제했다면 어떻게 되돌릴 수 있을까요?</p>
<p><strong>Git은 바로 이 문제를 해결하는 &lsquo;버전 관리 시스템(Version Control System)&lsquo;입니다.</strong> Git을 사용하면 다음과 같은 강력한 능력을 얻게 됩니다.</p>
<ol>
<li>
<p><strong>시간 여행 (코드의 스냅샷 저장):</strong>
프로젝트의 특정 상태를 &lsquo;커밋(Commit)&lsquo;이라는 단위로 저장합니다. 마치 게임의 &lsquo;세이브 포인트&rsquo;처럼, 언제든 원하는 시점의 코드로 돌아갈 수 있습니다. 버그가 발생했을 때, 어떤 변경사항 때문에 문제가 생겼는지 쉽게 추적하고 되돌릴 수 있죠.</p>
</li>
<li>
<p><strong>안전한 협업 (독립적인 작업 공간):</strong>
&lsquo;브랜치(Branch)&lsquo;라는 기능을 통해 기존 코드를 건드리지 않고, 자신만의 독립적인 공간에서 새로운 기능을 개발하거나 버그를 수정할 수 있습니다. 작업이 완료되면 원래의 코드와 안전하게 합칠 수 있어 여러 명이 동시에 작업해도 코드가 꼬이지 않습니다.</p>
</li>
<li>
<p><strong>든든한 백업 (히스토리 전체 보관):</strong>
단순 파일 백업과 다릅니다. Git은 프로젝트의 &lsquo;모든 변경 이력&rsquo;을 저장합니다. 내 컴퓨터의 파일이 모두 사라져도, GitHub 같은 원격 저장소에 올려두었다면 모든 히스토리와 함께 프로젝트 전체를 완벽하게 복원할 수 있습니다.</p>
</li>
</ol>
<blockquote>
<p><strong>결론:</strong> Git은 더 이상 선택이 아닌, 현대 개발자에게 꼭 필요한 <strong>기본 소양</strong>입니다.</p></blockquote>
<hr>
<h3 id="2-intro-tig는-무엇이고-왜-써야-할까-git의-시각화"><strong>2. Intro: Tig는 무엇이고 왜 써야 할까? (Git의 시각화)</strong></h3>
<p>Git은 정말 강력하지만, 모든 상호작용이 터미널의 텍스트 명령어로 이루어집니다.</p>
<p>예를 들어, 프로젝트의 변경 이력을 보려면 <code>git log</code> 명령어를 사용합니다.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># git log --oneline --graph --all 의 출력 예시</span>
</span></span><span class="line"><span class="cl">* 1ab2c3d <span class="o">(</span>HEAD -&gt; feature/login<span class="o">)</span> Add login button
</span></span><span class="line"><span class="cl">* 4d5e6f7 Implement login logic
</span></span><span class="line"><span class="cl"><span class="p">|</span> * 8g9h0i1 <span class="o">(</span>main<span class="o">)</span> Fix typo in README
</span></span><span class="line"><span class="cl"><span class="p">|</span>/
</span></span><span class="line"><span class="cl">* 7j8k9l0 Initial commit</span></span></code></pre></div>
  </figure>
</div>
<p>이것도 유용하지만, 브랜치가 수십 개로 복잡해지면 텍스트만으로는 전체 구조를 파악하기 매우 어렵습니다.</p>
<p><strong>그래서 우리는 대안을 찾습니다.</strong></p>
<ul>
<li><strong>GUI 툴 (SourceTree, GitKraken 등):</strong> 예쁜 그래픽으로 히스토리를 보여줘서 직관적이지만, 프로그램이 무겁고, 마우스를 써야 하며, 터미널 환경을 벗어나야 하는 단점이 있습니다.</li>
<li><strong>Tig (Text-mode Interface for Git):</strong> 바로 이 지점에서 <code>tig</code>가 빛을 발합니다. <code>tig</code>는 <strong>터미널 환경을 벗어나지 않으면서도</strong> Git 히스토리를 그래픽 유저 인터페이스(GUI)처럼 시각적으로 보여주는 놀라운 도구입니다.</li>
</ul>
<p><strong>Tig를 써야 하는 이유:</strong></p>
<ul>
<li><strong>가볍고 빠릅니다:</strong> 터미널에서 즉시 실행됩니다.</li>
<li><strong>시각적입니다:</strong> 복잡한 브랜치 구조와 커밋 히스토리를 ASCII 아트로 그려주어 한눈에 파악할 수 있습니다.</li>
<li><strong>인터랙티브합니다:</strong> 단순히 보기만 하는 게 아니라, <code>tig</code> 화면 안에서 커밋 내용을 자세히 보고, 브랜치를 바꾸고, 심지어 커밋까지 할 수 있습니다.</li>
</ul>
<blockquote>
<p><strong>결론:</strong> <code>tig</code>는 CLI(Command Line Interface)의 <strong>속도와 효율성</strong> + GUI의 <strong>시각적 직관성</strong>을 모두 잡은, Git 경험을 10배 향상시키는 최고의 파트너입니다.</p></blockquote>
<hr>
<h3 id="3-설치-및-기본-설정"><strong>3. 설치 및 기본 설정</strong></h3>
<p><code>tig</code>는 Git의 &lsquo;뷰어&rsquo;이므로, 당연히 Git이 먼저 설치되어 있어야 합니다.</p>
<h4 id="1-git-설치"><strong>1) Git 설치</strong></h4>
<p>대부분의 최신 운영체제에는 Git이 이미 설치되어 있습니다.</p>
<p>터미널을 열고 확인해보세요.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">git --version</span></span></code></pre></div>
  </figure>
</div>
<p>만약 설치되어 있지 않다면 <a href="https://git-scm.com/downloads">공식 사이트</a>를 참고하여 설치해주세요.</p>
<h4 id="2-tig-설치"><strong>2) Tig 설치</strong></h4>
<p>각 운영체제에 맞는 패키지 매니저를 사용하면 간단히 설치할 수 있습니다.</p>
<ul>
<li>
<p><strong>macOS (Homebrew 사용):</strong></p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">brew install tig</span></span></code></pre></div>
  </figure>
</div>
</li>
<li>
<p><strong>Ubuntu/Debian Linux (apt 사용):</strong></p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sudo apt-get update
</span></span><span class="line"><span class="cl">sudo apt-get install tig</span></span></code></pre></div>
  </figure>
</div>
</li>
<li>
<p><strong>Windows (scoop 또는 winget 사용):</strong>
<em>Git for Windows (Git Bash)</em> 환경에서 사용하는 것을 권장합니다.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># scoop 사용 시</span>
</span></span><span class="line"><span class="cl">scoop install tig
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># winget 사용 시</span>
</span></span><span class="line"><span class="cl">winget install tig</span></span></code></pre></div>
  </figure>
</div>
</li>
</ul>
<h4 id="3-최초-git-설정"><strong>3) 최초 Git 설정</strong></h4>
<p>Git을 처음 설치했다면, 커밋에 기록될 사용자 정보(이름, 이메일)를 설정해야 합니다.</p>
<p>이 정보는 당신의 &lsquo;디지털 서명&rsquo;과 같습니다.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">git config --global user.name <span class="s2">&#34;Your Name&#34;</span>
</span></span><span class="line"><span class="cl">git config --global user.email <span class="s2">&#34;youremail@example.com&#34;</span></span></span></code></pre></div>
  </figure>
</div>
<hr>
<h3 id="4-나의-첫-번째-저장소와-첫-tig-실행-실습"><strong>4. 나의 첫 번째 저장소와 첫 Tig 실행 (실습)</strong></h3>
<p>이제 Git과 <code>tig</code>를 직접 경험해볼 시간입니다.</p>
<p><strong>1. 실습용 폴더를 만들고 이동합니다.</strong></p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">mkdir my-git-project
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> my-git-project</span></span></code></pre></div>
  </figure>
</div>
<p><strong>2. 이 폴더를 Git 저장소로 초기화합니다.</strong>
이 명령을 실행하면 폴더 내에 숨김 파일인 <code>.git</code> 디렉토리가 생성되며, 이제 Git이 이 폴더의 모든 변경사항을 추적하기 시작합니다.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">git init</span></span></code></pre></div>
  </figure>
</div>
<p><strong>3. 첫 번째 파일을 만들고, Git에게 추적하라고 알려줍니다 (<code>add</code>).</strong>
<code>add</code>는 변경된 파일들을 &lsquo;스테이징 영역(Staging Area)&lsquo;이라는 커밋 대기실로 보내는 과정입니다.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;Hello, Git World!&#34;</span> &gt; README.md
</span></span><span class="line"><span class="cl">git add README.md</span></span></code></pre></div>
  </figure>
</div>
<p><strong>4. 첫 번째 커밋(스냅샷)을 남깁니다.</strong>
<code>commit</code>은 스테이징 영역에 있는 파일들을 하나의 의미 있는 변경사항 묶음(스냅샷)으로 저장하고, 메시지를 남기는 행위입니다.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">git commit -m <span class="s2">&#34;Initial commit: Add README.md&#34;</span></span></span></code></pre></div>
  </figure>
</div>
<p><strong>5. 대망의 순간: <code>tig</code>를 실행합니다!</strong>
이제 터미널에 <code>tig</code> 라고만 입력하고 Enter를 누르세요.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">tig</span></span></code></pre></div>
  </figure>
</div>
<p><strong>축하합니다!</strong> 다음과 비슷한 화면을 보게 될 것입니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <pre tabindex="0"><code>[main] [HEAD] o 2023-10-27 Your Name    Initial commit: Add README.md

--
main:
  (0) Main view
  (s) Status      (l) Log           (d) Diff          (t) Tree
  (f) File log    (b) Blame         (r) Refs          (y) Stash
  (h) Help        (q) Quit</code></pre>
  </figure>
</div>
<p><strong><code>tig</code> 화면 분석:</strong></p>
<ul>
<li><strong><code>[main] [HEAD] o ...</code></strong>: 이것이 방금 우리가 만든 커밋입니다.
<ul>
<li><code>[main]</code>: 현재 <code>main</code> 브랜치에 있다는 뜻입니다.</li>
<li><code>[HEAD]</code>: 현재 작업 중인 위치(포인터)를 의미합니다.</li>
<li><code>o</code>: 커밋을 나타내는 점입니다.</li>
<li>뒤이어 날짜, 작성자(<code>git config</code>에서 설정한 이름), 그리고 커밋 메시지가 보입니다.</li>
</ul>
</li>
</ul>
<p><strong>기본 조작법:</strong></p>
<ul>
<li><strong><code>k</code></strong> 또는 <strong>위쪽 화살표</strong>: 위로 이동</li>
<li><strong><code>j</code></strong> 또는 <strong>아래쪽 화살표</strong>: 아래로 이동</li>
<li><strong><code>Enter</code></strong>: 선택한 커밋의 변경 내용(Diff) 보기</li>
<li><strong><code>q</code></strong>: <code>tig</code> 종료하기 (또는 이전 화면으로 돌아가기)</li>
</ul>
<p><strong>미션:</strong></p>
<ol>
<li>
<p>파일을 한 번 더 수정하고, 두 번째 커밋을 만들어보세요.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;Learning tig is fun!&#34;</span> &gt;&gt; README.md
</span></span><span class="line"><span class="cl">git add README.md
</span></span><span class="line"><span class="cl">git commit -m <span class="s2">&#34;Update README with tig info&#34;</span></span></span></code></pre></div>
  </figure>
</div>
</li>
<li>
<p>다시 <code>tig</code>를 실행해서 커밋이 두 줄로 쌓인 히스토리를 눈으로 직접 확인해보세요.</p>
</li>
<li>
<p>키보드 <code>j</code>, <code>k</code>로 커밋 사이를 오가보고, 각 커밋에서 <code>Enter</code>를 눌러 어떤 내용이 변경되었는지 확인해보세요.</p>
</li>
</ol>
<hr>
<h4 id="모듈-1-요약">모듈 1 요약</h4>
<p>당신은 이제 Git이 왜 필요한지 설명할 수 있고, <code>tig</code>를 이용해 내가 만든 작업의 히스토리를 &lsquo;시각적으로&rsquo; 확인할 수 있게 되었습니다.</p>
<p>텍스트로만 보던 <code>git log</code>와는 전혀 다른 경험이죠.</p>
<p>다음 모듈에서는 <code>tig</code>의 다양한 뷰(View)를 탐험하며 Git의 상태를 속속들이 파헤쳐 보겠습니다.</p>
<hr>
<h3 id="모듈-2-tig의-눈으로-git-바라보기-핵심-뷰"><strong>모듈 2: Tig의 눈으로 Git 바라보기 (핵심 뷰)</strong></h3>
<p><strong>강좌 목표:</strong> <code>tig</code>의 기본 화면(Main View)을 넘어, 작업 현황(Status View), 브랜치 목록(Branch View), 코드 작성자 추적(Blame View) 등 핵심 뷰(View)를 자유자재로 넘나들며 Git의 상태를 입체적으로 파악합니다.</p>
<p><code>tig</code> 안에서 Git의 주요 명령어를 실행하는 경험을 통해 생산성을 극대화합니다.</p>
<hr>
<h3 id="1-main-view-커밋-히스토리-여행하기-심화"><strong>1. Main View: 커밋 히스토리 여행하기 (심화)</strong></h3>
<p>모듈 1에서 우리는 <code>tig</code>를 실행하면 가장 먼저 보이는 <strong>Main View</strong>를 만났습니다.</p>
<p>이곳은 우리 프로젝트의 시간 흐름, 즉 커밋 히스토리 전체를 보여주는 지도와 같습니다.</p>
<p>이제 이 지도를 더 깊이 탐험해 봅시다.</p>
<p><strong>핵심 인터랙션: <code>Enter</code> 키로 커밋 내용 확인하기</strong></p>
<p><code>tig</code>의 Main View에서 가장 중요한 기능 중 하나는 특정 커밋에서 정확히 <strong>무엇이</strong> 변경되었는지 즉시 확인하는 것입니다.</p>
<ol>
<li><code>tig</code>를 실행하세요.</li>
<li>키보드의 <code>j</code>(아래), <code>k</code>(위)를 이용해 확인하고 싶은 커밋으로 이동합니다.</li>
<li>해당 커밋 위에서 <strong><code>Enter</code></strong> 키를 누르세요.</li>
</ol>
<p>화면이 바뀌면서 선택한 커밋의 상세 변경 내역(Diff)이 나타납니다.</p>
<ul>
<li><strong>초록색 <code>+</code> 기호</strong>: 해당 커밋에서 추가된 라인입니다.</li>
<li><strong>빨간색 <code>-</code> 기호</strong>: 해당 커밋에서 삭제된 라인입니다.</li>
</ul>
<p>이 화면에서 다시 <strong><code>q</code></strong> 키를 누르면 이전의 Main View로 돌아옵니다. 이 <strong><code>j/k</code> (이동) → <code>Enter</code> (상세 보기) → <code>q</code> (돌아가기)</strong> 흐름은 <code>tig</code> 사용의 가장 기본적인 리듬입니다.</p>
<blockquote>
<p><strong>실습:</strong>
모듈 1에서 만든 <code>my-git-project</code> 폴더로 이동하여 <code>README.md</code> 파일을 열고 내용을 자유롭게 추가 및 삭제한 후 새로운 커밋을 만드세요. 그 다음 <code>tig</code>를 실행하여 각 커밋을 오가며 <code>Enter</code> 키로 어떤 내용이 어떻게 변했는지 직접 확인하고 <code>q</code> 키로 돌아오는 연습을 반복해보세요.</p></blockquote>
<hr>
<h3 id="2-status-view-내-작업-현황판"><strong>2. Status View: 내 작업 현황판</strong></h3>
<p>지금까지 수정한 내용, 새로 추가한 파일들을 커밋하기 전에 확인하려면 <code>git status</code> 명령어를 사용해야 했습니다.</p>
<p><code>tig</code>의 <strong>Status View</strong>는 이 과정을 <code>tig</code> 안에서 훨씬 직관적으로 처리하게 해줍니다.</p>
<p><strong>Status View로 전환하기: <code>s</code> 키</strong></p>
<p><code>tig</code>의 아무 뷰에서나 <strong><code>s</code></strong> (status) 키를 눌러보세요.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <pre tabindex="0"><code># tig 화면에서 &#39;s&#39; 키를 누른 후의 예시

[main] ?? new-file.txt
[main]  M README.md

--
status:
  (u) Update      (c) Commit        (r) Revert
  (s) Status      (l) Log           (q) Quit</code></pre>
  </figure>
</div>
<p><strong>화면 해석:</strong></p>
<ul>
<li><code>Unstaged changes</code>: 아직 <code>git add</code> 하지 않은 변경사항 목록입니다. (<code>??</code>: 추적하지 않는 새 파일, <code>M</code>: 수정된 파일)</li>
<li><code>Staged changes</code>: <code>git add</code>를 통해 커밋 대기실(스테이징 영역)에 올라간 파일 목록입니다. (지금은 비어있음)</li>
</ul>
<p><strong>핵심 인터랙션: <code>u</code>, <code>C</code> 로 커밋까지 한 번에!</strong></p>
<p>Status View는 단순히 보여주기만 하는 것이 아니라, 직접 파일을 스테이징하고 커밋까지 할 수 있는 강력한 작업 공간입니다.</p>
<ol>
<li>
<p><strong><code>u</code> (update/unstage): 파일 스테이징/언스테이징</strong></p>
<ul>
<li><code>Unstaged changes</code> 목록에 있는 파일 위에서 <code>u</code> 키를 누르면, 해당 파일이 <code>Staged changes</code> 목록으로 이동합니다. (<code>git add &lt;file&gt;</code>과 동일한 효과)</li>
<li>반대로, <code>Staged changes</code> 목록의 파일 위에서 <code>u</code> 키를 누르면 <code>Unstaged changes</code>로 돌아옵니다. (<code>git reset HEAD &lt;file&gt;</code>과 동일한 효과)</li>
</ul>
</li>
<li>
<p><strong><code>C</code> (Commit): 커밋하기</strong></p>
<ul>
<li>스테이징할 파일들을 모두 <code>u</code> 키로 올렸다면, <strong>대문자 <code>C</code></strong> 키를 누르세요.</li>
<li>터미널의 기본 편집기(Vim, Nano 등)가 열리면서 커밋 메시지를 작성하는 화면이 나타납니다.</li>
<li>메시지를 작성하고 저장 후 종료하면, 커밋이 완료됩니다!</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>실습 (가장 중요한 실습!):</strong></p>
<ol>
<li><code>README.md</code> 파일을 수정합니다.</li>
<li><code>feature.txt</code> 라는 새 파일을 만듭니다.</li>
<li><code>tig</code>를 실행하고 <code>s</code> 키를 눌러 Status View로 들어갑니다.</li>
<li><code>README.md</code>와 <code>feature.txt</code>가 <code>Unstaged changes</code>에 있는 것을 확인합니다.</li>
<li><code>j</code>, <code>k</code>로 이동하며 각 파일 위에서 <code>u</code> 키를 눌러 <code>Staged changes</code>로 옮겨보세요.</li>
<li><code>C</code> 키를 눌러 &ldquo;Add new feature and update README&rdquo; 라는 메시지로 커밋을 완료하세요.</li>
<li><code>q</code> 키로 Status View를 나와 Main View로 돌아가면, 방금 만든 커밋이 최상단에 추가된 것을 볼 수 있습니다. <strong>이제 당신은 <code>tig</code>를 벗어나지 않고 <code>add</code>와 <code>commit</code>을 모두 수행했습니다!</strong></li>
</ol></blockquote>
<hr>
<h3 id="3-branch-view--refs-view-가지들-한눈에-보기"><strong>3. Branch View &amp; Refs View: 가지들 한눈에 보기</strong></h3>
<p>프로젝트가 커지면 여러 브랜치를 동시에 관리하게 됩니다.</p>
<p><code>tig</code>는 흩어져 있는 모든 브랜치와 태그를 한 곳에서 보여줍니다.</p>
<ul>
<li><strong><code>b</code> (branch):</strong> 로컬 브랜치 목록을 보여줍니다.</li>
<li><strong><code>r</code> (refs):</strong> 로컬 브랜치, 원격 브랜치, 태그 등 모든 참조(Reference)를 보여줍니다. 보통 <code>r</code>을 더 자주 씁니다.</li>
</ul>
<p><strong>Refs View로 전환하기: <code>r</code> 키</strong></p>
<p><code>tig</code> 화면에서 <strong><code>r</code></strong> 키를 눌러보세요.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="c1"># &#39;r&#39; 키를 누른 후의 예시</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">[</span>refs<span class="o">]</span>
</span></span><span class="line"><span class="cl">  HEAD
</span></span><span class="line"><span class="cl">  refs/heads/main
</span></span><span class="line"><span class="cl">  refs/heads/feature/login
</span></span><span class="line"><span class="cl">  refs/remotes/origin/main
</span></span><span class="line"><span class="cl">  refs/tags/v1.0</span></span></code></pre></div>
  </figure>
</div>
<p><strong>핵심 인터랙션: <code>Enter</code>로 특정 브랜치 히스토리 필터링하기</strong></p>
<p>Refs View의 진정한 힘은 &lsquo;필터링&rsquo; 기능에 있습니다.</p>
<ol>
<li><code>r</code> 키로 Refs View를 엽니다.</li>
<li>보고 싶은 브랜치(예: <code>refs/heads/feature/login</code>)로 이동합니다.</li>
<li><strong><code>Enter</code></strong> 키를 누릅니다.</li>
</ol>
<p>화면이 Main View로 바뀌면서, 오직 <code>feature/login</code> 브랜치에 해당하는 커밋 히스토리만 필터링되어 보입니다.</p>
<p>전체 히스토리를 다시 보고 싶다면, <code>r</code> 키로 돌아가 <code>HEAD</code>에서 <code>Enter</code>를 누르면 됩니다.</p>
<hr>
<h3 id="4-blame-view-이-코드는-누가-언제-수정했을까"><strong>4. Blame View: 이 코드는 누가, 언제 수정했을까?</strong></h3>
<p>협업 시 &ldquo;이 코드는 어떤 의도로 작성되었을까?&rdquo; 궁금할 때가 많습니다.</p>
<p>Blame View는 파일의 각 라인이 마지막으로 수정된 커밋 정보(작성자, 날짜, 커밋 해시)를 보여주는 강력한 추적 도구입니다.</p>
<p><strong>Blame View로 진입하기: Main View → Diff View → <code>B</code> 키</strong></p>
<p>Blame View는 진입 방법이 조금 다릅니다.</p>
<ol>
<li><code>tig</code>의 Main View에서 특정 커밋을 선택하고 **<code>Enter</code>**를 눌러 Diff View로 들어갑니다.</li>
<li>파일 변경 내역이 보이는 이 화면에서, 추적하고 싶은 파일 섹션에 커서가 있을 때 <strong>대문자 <code>B</code></strong> 키를 누릅니다.</li>
</ol>
<p>이제 해당 파일의 전체 내용이 나타나며, 각 줄의 왼쪽에 누가, 언제, 어떤 커밋에서 이 라인을 수정했는지에 대한 정보가 표시됩니다.</p>
<p>버그의 원인이 된 코드를 찾았을 때, 이 기능을 사용하면 해당 변경사항의 맥락을 파악하고 담당자에게 질문하기가 매우 용이해집니다.</p>
<hr>
<h4 id="모듈-2-요약">모듈 2 요약</h4>
<p>당신은 이제 <code>tig</code>의 4대 핵심 뷰(Main, Status, Refs, Blame)를 모두 다룰 수 있게 되었습니다.</p>
<p>단순히 히스토리를 보는 것을 넘어, <code>tig</code> 안에서 직접 파일을 스테이징하고 커밋하며, 브랜치를 필터링하고, 코드의 역사를 추적하는 &lsquo;능동적인&rsquo; 사용자 되었습니다.</p>
<p>이제 <code>tig</code>를 통해 Git의 가장 중요하고 흥미로운 기능인 &lsquo;브랜치&rsquo;를 시각적으로 다루어 볼 준비가 되었습니다.</p>
<p>다음 모듈 3에서는 브랜치를 만들고 합치는 과정을 <code>tig</code>로 직접 눈으로 보며 마스터해 보겠습니다.</p>
<hr>
<h3 id="모듈-3-브랜치-전략-tig로-시각화하기"><strong>모듈 3: 브랜치 전략, Tig로 시각화하기</strong></h3>
<p><strong>강좌 목표:</strong> Git의 꽃이라 불리는 &lsquo;브랜치&rsquo;의 개념을 완벽히 이해합니다.</p>
<p>브랜치를 만들고, 이동하고, 합치는(Merge, Rebase) 모든 과정을 <code>tig</code>의 ASCII 그래프를 통해 시각적으로 추적하며, 복잡한 히스토리를 깔끔하게 관리하는 능력을 기릅니다.</p>
<hr>
<h3 id="1-브랜치-왜-써야-할까-독립적인-작업-공간"><strong>1. 브랜치, 왜 써야 할까? (독립적인 작업 공간)</strong></h3>
<p>팀 프로젝트를 한다고 상상해 보세요.</p>
<p><code>A</code>는 로그인 기능을 만들고, <code>B</code>는 메인 페이지 디자인을 개선하고 있습니다.</p>
<p>만약 두 사람이 <code>main</code>이라는 단 하나의 브랜치에서 동시에 작업한다면 어떻게 될까요?</p>
<ul>
<li>아직 미완성인 <code>A</code>의 로그인 코드가 <code>B</code>의 작업에 영향을 줄 수 있습니다.</li>
<li>두 사람이 같은 파일을 수정하면 코드가 엉망이 될 수 있습니다. (충돌, Conflict)</li>
<li>갑자기 긴급한 버그를 수정해야 할 때, 현재 작업 중인 내용을 모두 되돌려야 하는 재앙이 발생합니다.</li>
</ul>
<p>**브랜치(Branch)**는 이런 문제를 해결하기 위해, 기존 코드(보통 <code>main</code> 브랜치)의 특정 시점에서 새로운 가지를 만들어 독립적인 작업 공간을 제공하는 기능입니다.</p>
<ul>
<li><strong>안전성:</strong> 각자 자신의 브랜치에서 작업하므로 다른 사람의 작업에 영향을 주지 않습니다.</li>
<li><strong>동시성:</strong> 여러 기능을 동시에 개발할 수 있습니다.</li>
<li><strong>유연성:</strong> 기능 개발, 버그 수정, 테스트 등 목적에 따라 브랜치를 만들고, 작업이 끝나면 원래 브랜치와 합치거나 필요 없으면 버릴 수 있습니다.</li>
</ul>
<blockquote>
<p><strong>결론:</strong> 브랜치는 안전하고 효율적인 협업을 위한 Git의 <strong>핵심 기능</strong>입니다.</p></blockquote>
<hr>
<h3 id="2-브랜치-생성과-전환-그리고-시각화"><strong>2. 브랜치 생성과 전환, 그리고 시각화</strong></h3>
<p>이제 직접 브랜치를 만들고 <code>tig</code>로 어떻게 보이는지 확인해 봅시다.</p>
<p><strong>1. 새 브랜치 생성 및 이동 (Checkout)</strong>
현재 우리는 <code>main</code> 브랜치에 있습니다. &ldquo;로그인 기능 개발&quot;을 위한 <code>feature/login</code> 브랜치를 만들어 보겠습니다.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># &#39;feature/login&#39; 브랜치를 생성하고, 그 브랜치로 즉시 이동(-b 옵션)</span>
</span></span><span class="line"><span class="cl">git checkout -b feature/login</span></span></code></pre></div>
  </figure>
</div>
<p><em><code>git branch feature/login</code> 과 <code>git checkout feature/login</code> 두 명령을 합친 것입니다.</em></p>
<p><strong>2. 핵심: <code>tig --all</code> 로 전체 히스토리 보기</strong>
그냥 <code>tig</code>만 실행하면 현재 브랜치(<code>feature/login</code>)의 히스토리만 보입니다.</p>
<p>모든 브랜치를 함께 보려면 <code>--all</code> 옵션을 사용해야 합니다.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">tig --all</span></span></code></pre></div>
  </figure>
</div>
<p><code>tig</code> 화면을 보면, 이제 <code>main</code>과 <code>feature/login</code>이 같은 커밋을 가리키고 있습니다.</p>
<p><code>(HEAD -&gt; feature/login, main)</code> 처럼 표시될 것입니다.</p>
<p><code>HEAD</code>는 &ldquo;내가 지금 작업하는 곳&quot;을 가리키는 포인터이며, 이제 <code>feature/login</code>을 따라다닙니다.</p>
<p><strong>3. 새 브랜치에서 커밋하기</strong>
<code>feature/login</code> 브랜치에서 로그인과 관련된 작업을 하고 커밋을 만들어 봅시다.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;Login form added&#34;</span> &gt; login.html
</span></span><span class="line"><span class="cl">git add login.html
</span></span><span class="line"><span class="cl">git commit -m <span class="s2">&#34;Feat: Add login form structure&#34;</span></span></span></code></pre></div>
  </figure>
</div>
<p><strong>4. 히스토리가 갈라지는 순간 확인하기</strong>
다시 <code>tig --all</code>을 실행해 보세요. 마법 같은 순간이 펼쳐집니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <pre tabindex="0"><code># &#39;tig --all&#39; 실행 예시
* 1a2b3c4 (HEAD -&gt; feature/login) Feat: Add login form structure
|
* d4e5f6g (main) Update README with tig info
...</code></pre>
  </figure>
</div>
<ul>
<li><strong>ASCII 그래프:</strong> <code>feature/login</code> 브랜치가 <code>main</code> 브랜치에서 분기되어 새로운 커밋(<code>1a2b3c4</code>)을 쌓아 올린 모습이 세로선 <code>|</code> 과 별표 <code>*</code> 로 명확하게 보입니다.</li>
<li><strong>포인터:</strong> <code>HEAD</code>와 <code>feature/login</code>은 새 커밋으로 이동했지만, <code>main</code>은 예전 커밋에 그대로 머물러 있습니다.</li>
</ul>
<blockquote>
<p><strong>이것이 바로 <code>tig</code>의 힘입니다.</strong> 텍스트 명령어만으로는 상상해야 했던 &lsquo;브랜치의 분기&rsquo;를 직접 눈으로 확인하는 순간입니다.</p></blockquote>
<hr>
<h3 id="3-merge-병합-가지를-하나로-합치기"><strong>3. Merge (병합): 가지를 하나로 합치기</strong></h3>
<p><code>feature/login</code> 브랜치에서 기능 개발이 끝났다고 가정합시다.</p>
<p>이제 이 변경사항을 <code>main</code> 브랜치에 합쳐야 합니다. 이것을 **Merge(병합)**라고 합니다.</p>
<p><strong>1. 합칠 대상 브랜치로 이동</strong>
<code>main</code> 브랜치에 <code>feature/login</code>을 합칠 것이므로, <code>main</code> 브랜치로 돌아가야 합니다.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">git checkout main</span></span></code></pre></div>
  </figure>
</div>
<p><strong>2. Merge 명령어 실행</strong>
<code>main</code> 브랜치에서, 합치고 싶은 브랜치(<code>feature/login</code>)를 지정하여 병합합니다.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">git merge feature/login</span></span></code></pre></div>
  </figure>
</div>
<p><strong>3. Merge 결과, <code>tig</code>로 확인하기</strong>
다시 <code>tig --all</code> 을 실행해 보세요.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <pre tabindex="0"><code># &#39;tig --all&#39; 실행 예시
*   5h6i7j8 (HEAD -&gt; main) Merge branch &#39;feature/login&#39;
|\
| * 1a2b3c4 (feature/login) Feat: Add login form structure
|/
* d4e5f6g Update README with tig info
...</code></pre>
  </figure>
</div>
<ul>
<li><strong>Merge Commit:</strong> &ldquo;Merge branch &lsquo;feature/login&rsquo;&rdquo; 이라는 메시지를 가진 새로운 <strong>Merge Commit</strong>(<code>5h6i7j8</code>)이 생성되었습니다. 이 커밋은 두 개의 부모 커밋(기존 <code>main</code>의 마지막 커밋과 <code>feature/login</code>의 마지막 커밋)을 가집니다.</li>
<li><strong>그래프:</strong> 갈라졌던 두 브랜치가 Merge Commit을 통해 다시 하나로 합쳐지는 모습이 <code>|\</code> 와 <code>|/</code> 같은 그래프로 명확하게 보입니다. <code>main</code>과 <code>HEAD</code> 포인터는 이제 이 Merge Commit을 가리킵니다.</li>
</ul>
<hr>
<h3 id="4-rebase-재배치-히스토리-깔끔하게-만들기"><strong>4. Rebase (재배치): 히스토리 깔끔하게 만들기</strong></h3>
<p><strong>Rebase</strong>는 Merge와 같이 브랜치를 합치는 또 다른 방법이지만, 동작 방식이 완전히 다릅니다.</p>
<p>Rebase는 말 그대로 브랜치의 **베이스(Base, 기준점)를 재배치(Re-base)**하여 히스토리를 한 줄로 깨끗하게 만듭니다.</p>
<p><strong>상황 설정:</strong> Merge를 되돌리고 Rebase를 해보기 위해, 방금 한 Merge를 취소해 봅시다.</p>
<p>(<code>tig</code>에서 Merge Commit 바로 이전 커밋의 해시(e.g., <code>d4e5f6g</code>)를 확인하세요.)</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># 이전 상태로 되돌리기 (주의: 이미 원격에 push한 커밋에는 사용하면 안 됩니다!)</span>
</span></span><span class="line"><span class="cl">git reset --hard d4e5f6g</span></span></code></pre></div>
  </figure>
</div>
<p><strong>1. Rebase 명령어 실행</strong>
<code>feature/login</code> 브랜치의 변경사항들을, <code>main</code> 브랜치의 최신 커밋 <strong>위로</strong> 옮겨 붙이겠습니다.
<em>먼저 <code>feature/login</code> 브랜치로 이동해야 합니다.</em></p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">git checkout feature/login
</span></span><span class="line"><span class="cl">git rebase main</span></span></code></pre></div>
  </figure>
</div>
<p><strong>2. Rebase 결과, <code>tig</code>로 확인하기</strong>
<code>tig --all</code> 로 결과를 확인하면, Merge와는 완전히 다른 모습에 놀라게 될 것입니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <pre tabindex="0"><code># &#39;tig --all&#39; 실행 예시 (Rebase 후)
* 1a2b3c4&#39; (HEAD -&gt; feature/login) Feat: Add login form structure
* d4e5f6g (main) Update README with tig info
...</code></pre>
  </figure>
</div>
<ul>
<li><strong>선형 히스토리:</strong> Merge처럼 히스토리가 갈라지고 합쳐지는 지저분한 그래프가 사라지고, <strong>마치 처음부터 <code>main</code> 브랜치에서 순서대로 작업한 것처럼</strong> 히스토리가 한 줄로 깔끔하게 정리되었습니다.</li>
<li><strong>새로운 커밋 해시:</strong> <code>feature/login</code>의 커밋이었던 <code>1a2b3c4</code>가 <code>1a2b3c4'</code> 처럼 새로운 해시값을 가진 커밋으로 재작성되었습니다. (Rebase는 기존 커밋을 복사해서 새로 만드는 과정이기 때문입니다.)</li>
</ul>
<p><strong>3. Fast-forward Merge</strong>
이제 <code>main</code> 브랜치로 돌아가서 <code>merge</code>를 해보세요.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">git checkout main
</span></span><span class="line"><span class="cl">git merge feature/login</span></span></code></pre></div>
  </figure>
</div>
<p><code>tig --all</code> 을 보면, 별도의 Merge Commit 없이 <code>main</code> 포인터가 <code>feature/login</code>의 위치로 &lsquo;빨리 감기(Fast-forward)&lsquo;처럼 쓱 이동한 것을 볼 수 있습니다. 히스토리가 매우 깨끗하게 유지됩니다.</p>
<p><strong>Merge vs Rebase: 언제 무엇을 쓸까?</strong></p>
<ul>
<li><strong>Merge:</strong> &ldquo;두 브랜치를 합쳤다&quot;는 사실 자체를 히스토리에 명확히 남기고 싶을 때 사용합니다. 팀의 공식적인 히스토리에 적합합니다.</li>
<li><strong>Rebase:</strong> 브랜치가 너무 지저분하게 뻗어 나가는 것을 방지하고, 최종적으로 <code>main</code>에 합치기 전에 내 작업 히스토리를 깔끔하게 정리하고 싶을 때 사용합니다. (특히 개인 브랜치에서)</li>
</ul>
<blockquote>
<p><strong>경고:</strong> 이미 팀원과 공유한(원격 저장소에 <code>push</code>한) 브랜치에서는 절대 <code>rebase</code>를 사용하면 안 됩니다. 다른 팀원의 히스토리와 충돌하여 큰 혼란을 일으킬 수 있습니다.</p></blockquote>
<hr>
<h4 id="모듈-3-요약">모듈 3 요약</h4>
<p>당신은 이제 Git 브랜치의 핵심인 분기(Branching), 병합(Merge), 재배치(Rebase)의 개념을 <code>tig</code>를 통해 <strong>눈으로 직접 확인하며</strong> 완벽히 이해했습니다.</p>
<p>지저분한 Merge 히스토리와 깔끔한 Rebase 히스토리의 차이를 시각적으로 비교함으로써, 언제 어떤 전략을 써야 할지 판단하는 능력을 갖추게 되었습니다.</p>
<p>이제 이 로컬에서의 경험을 바탕으로, 다음 모듈에서는 다른 사람과 협업하기 위한 &lsquo;원격 저장소&rsquo;와의 상호작용을 배워보겠습니다.</p>
<hr>
<h3 id="모듈-4-협업의-시작---원격-저장소와-tig"><strong>모듈 4: 협업의 시작 - 원격 저장소와 Tig</strong></h3>
<p><strong>강좌 목표:</strong> 로컬 저장소의 작업을 GitHub과 같은 원격 저장소와 동기화하는 방법을 배웁니다. <code>push</code>, <code>pull</code>, <code>fetch</code> 명령어의 차이점을 <code>tig</code>의 <code>origin/main</code>과 같은 원격 브랜치 포인터의 움직임을 통해 명확하고 직관적으로 이해합니다. 이를 통해 팀원들과 코드를 안전하게 공유하고 최신 상태를 유지하는 능력을 기릅니다.</p>
<hr>
<h3 id="1-원격-저장소remote-연동"><strong>1. 원격 저장소(Remote) 연동</strong></h3>
<p>지금까지 우리의 모든 작업(<code>커밋</code>, <code>브랜치</code>)은 개인 컴퓨터, 즉 **로컬 저장소(Local Repository)**에만 저장되어 있습니다.</p>
<p>협업을 하려면 이 작업 내역을 모든 팀원이 접근할 수 있는 중앙 서버, 즉 **원격 저장소(Remote Repository)**에 올려야 합니다.</p>
<p>가장 대표적인 원격 저장소 서비스가 바로 <strong>GitHub</strong>입니다.</p>
<p><strong>1. GitHub에 새 원격 저장소 생성하기</strong></p>
<ol>
<li><a href="https://github.com/">GitHub</a>에 접속하여 로그인합니다.</li>
<li>우측 상단의 &lsquo;+&rsquo; 버튼 또는 &lsquo;New&rsquo; 버튼을 눌러 새 저장소를 만듭니다.</li>
<li>저장소 이름은 로컬 프로젝트와 동일하게 <code>my-git-project</code>로 설정합니다.</li>
<li><strong>중요:</strong> <code>Initialize this repository with a README</code> 옵션은 <strong>체크 해제</strong>합니다. 우리는 이미 로컬에 작업 내역이 있기 때문입니다.</li>
<li>&lsquo;Create repository&rsquo; 버튼을 클릭합니다.</li>
</ol>
<p><strong>2. 로컬 저장소에 원격 저장소 주소 등록하기</strong></p>
<p>저장소가 생성되면, GitHub는 친절하게도 &ldquo;&hellip;or push an existing repository from the command line&rdquo; 이라는 안내를 보여줍니다.</p>
<p>이 안내문의 명령어를 사용하면 됩니다.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># &#39;origin&#39;이라는 별명으로 원격 저장소 주소를 등록합니다.</span>
</span></span><span class="line"><span class="cl">git remote add origin https://github.com/YourUsername/my-git-project.git
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 등록된 원격 저장소 정보를 확인합니다.</span>
</span></span><span class="line"><span class="cl">git remote -v</span></span></code></pre></div>
  </figure>
</div>
<ul>
<li><code>origin</code>: 원격 저장소 주소에 붙이는 기본 별명입니다. 다른 이름으로 지정할 수도 있지만, <code>origin</code>이 관례입니다.</li>
<li>이제 Git은 <code>origin</code>이라는 단어가 GitHub에 있는 우리 저장소를 의미한다는 것을 압니다.</li>
</ul>
<hr>
<h3 id="2-push--pull-내-코드를-공유하고-동료-코드를-가져오기"><strong>2. Push &amp; Pull: 내 코드를 공유하고, 동료 코드를 가져오기</strong></h3>
<p><strong>Push: 내 로컬 작업을 원격 저장소에 올리기 (업로드)</strong></p>
<p><code>push</code>는 내 컴퓨터(로컬)의 커밋들을 원격 저장소(<code>origin</code>)로 전송하여 팀원들과 공유하는 명령어입니다.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># 현재 로컬의 &#39;main&#39; 브랜치를 원격 &#39;origin&#39;의 &#39;main&#39; 브랜치로 push 합니다.</span>
</span></span><span class="line"><span class="cl"><span class="c1"># -u 옵션은 앞으로 이 로컬 브랜치가 원격의 해당 브랜치를 추적하도록 설정하는 것입니다. (최초 한번만)</span>
</span></span><span class="line"><span class="cl">git push -u origin main</span></span></code></pre></div>
  </figure>
</div>
<ul>
<li>핵심: <code>tig</code>로 Push 결과 확인하기**</li>
</ul>
<p><code>push</code>가 성공적으로 완료된 후, <code>tig --all</code>을 실행해 보세요.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="c1"># &#39;tig --all&#39; 실행 예시 (Push 후)</span>
</span></span><span class="line"><span class="cl">* ... <span class="o">(</span>HEAD -&gt; main, origin/main<span class="o">)</span> Latest commit
</span></span><span class="line"><span class="cl">...</span></span></code></pre></div>
  </figure>
</div>
<ul>
<li><strong><code>origin/main</code> 포인터 등장:</strong> 이전에는 보이지 않던 <code>origin/main</code> 이라는 새로운 포인터가 생겼습니다! 이것은 원격 저장소 <code>origin</code>의 <code>main</code> 브랜치가 <strong>어디까지 알고 있는지</strong>를 나타냅니다.</li>
<li><strong>동일한 위치:</strong> <code>push</code>를 했기 때문에, 로컬 <code>main</code>과 원격 <code>origin/main</code>은 현재 동일한 최신 커밋을 가리키고 있습니다.</li>
</ul>
<p><strong>Pull: 원격 저장소의 최신 작업을 내 로컬로 가져오기 (다운로드 + 병합)</strong></p>
<p>이제 다른 팀원이 새로운 작업을 <code>push</code>했다고 상상해 봅시다.</p>
<p>우리는 그 최신 내용을 우리 로컬 컴퓨터로 가져와야 합니다. 이 때 <code>pull</code> 명령어를 사용합니다.</p>
<p><em>(실습을 위해 GitHub 사이트에서 직접 <code>README.md</code> 파일을 수정하여 새 커밋을 만들어 봅시다.)</em></p>
<ol>
<li>GitHub의 <code>my-git-project</code> 저장소 페이지로 이동합니다.</li>
<li><code>README.md</code> 파일을 클릭하고, 연필 모양(Edit) 아이콘을 눌러 내용을 수정한 뒤, &ldquo;Commit changes&rdquo; 버튼을 눌러 커밋합니다.</li>
</ol>
<p>이제 원격 저장소는 우리 로컬보다 한 발 앞서 나간 상태입니다. 이 변경사항을 가져와 봅시다.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">git pull origin main</span></span></code></pre></div>
  </figure>
</div>
<ul>
<li>핵심: <code>tig</code>로 Pull 결과 확인하기**</li>
</ul>
<p><code>pull</code> 명령 후 <code>tig --all</code>을 다시 실행하면,</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <pre tabindex="0"><code># &#39;tig --all&#39; 실행 예시 (Pull 후)
* ... (HEAD -&gt; main, origin/main) Commit from GitHub
* ... Previous local commit
...</code></pre>
  </figure>
</div>
<ul>
<li><strong>포인터 동기화:</strong> <code>pull</code>을 통해 원격 저장소의 새 커밋이 로컬로 다운로드되고, 로컬 <code>main</code> 브랜치에 병합(merge)되었습니다. 그 결과, <code>HEAD</code>, <code>main</code>, <code>origin/main</code> 포인터가 모두 다시 최신 커밋을 함께 가리키게 됩니다.</li>
</ul>
<hr>
<h3 id="3-fetch-vs-pull-명확히-이해하기"><strong>3. Fetch vs Pull 명확히 이해하기</strong></h3>
<p>많은 입문자들이 <code>fetch</code>와 <code>pull</code>의 차이를 헷갈려 합니다. <code>tig</code>는 이 둘의 차이를 명확하게 보여주는 최고의 교사입니다.</p>
<blockquote>
<p><strong>결론부터 말하면: <code>git pull</code> = <code>git fetch</code> + <code>git merge</code> 입니다.</strong></p></blockquote>
<p><strong><code>fetch</code>: 일단 가져와서 보기만 할게 (다운로드)</strong></p>
<p><code>fetch</code>는 원격 저장소의 최신 변경 내역을 로컬로 가져오되, <strong>내 작업 브랜치(<code>main</code>)와 자동으로 합치지는 않습니다.</strong> 단지 &ldquo;원격 저장소는 이런 변경사항이 있구나&rdquo; 하고 정보만 업데이트하는 것입니다.</p>
<p><strong><code>pull</code>: 가져와서 합치기까지 할게 (다운로드 + 병합)</strong></p>
<p><code>pull</code>은 <code>fetch</code>를 수행한 다음, 가져온 내용을 현재 내 작업 브랜치와 즉시 <code>merge</code>까지 해버립니다.</p>
<ul>
<li>실습: <code>tig</code>로 <code>fetch</code>와 <code>pull</code>의 차이 눈으로 보기**</li>
</ul>
<ol>
<li>
<p><strong>상황 만들기:</strong> 다시 GitHub 사이트에서 <code>README.md</code> 파일을 한번 더 수정하고 커밋합니다. 이제 원격 저장소가 다시 앞서 나갑니다.</p>
</li>
<li>
<p><strong><code>fetch</code> 실행:</strong> 이번에는 <code>pull</code> 대신 <code>fetch</code>를 실행합니다.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">git fetch origin</span></span></code></pre></div>
  </figure>
</div>
</li>
<li>
<p><strong><code>tig</code>로 <code>fetch</code> 결과 확인:</strong> <code>tig --all</code>을 실행해 보세요. 이것이 가장 중요한 순간입니다.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="c1"># &#39;tig --all&#39; 실행 예시 (Fetch 후)</span>
</span></span><span class="line"><span class="cl">* ... <span class="o">(</span>origin/main<span class="o">)</span> New commit from GitHub
</span></span><span class="line"><span class="cl"><span class="p">|</span>
</span></span><span class="line"><span class="cl">* ... <span class="o">(</span>HEAD -&gt; main<span class="o">)</span> My previous commit
</span></span><span class="line"><span class="cl">...</span></span></code></pre></div>
  </figure>
</div>
<ul>
<li><strong>포인터 분리!</strong>
<ul>
<li><code>origin/main</code> 포인터는 GitHub에서 새로 만든 커밋으로 <strong>혼자 이동</strong>했습니다. 원격의 최신 정보를 반영한 것이죠.</li>
<li>하지만 <code>HEAD -&gt; main</code> 포인터는 <strong>이전 커밋에 그대로 머물러 있습니다!</strong> <code>fetch</code>는 내 작업을 전혀 건드리지 않았다는 명확한 증거입니다.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>수동으로 Merge 하기:</strong> 이제 <code>main</code> 브랜치에 <code>origin/main</code>의 변경사항을 직접 합쳐봅시다.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">git merge origin/main</span></span></code></pre></div>
  </figure>
</div>
</li>
<li>
<p><strong><code>tig</code>로 최종 결과 확인:</strong> <code>tig --all</code>을 다시 실행하면, <code>main</code> 포인터가 <code>origin/main</code>의 위치로 이동하며 합쳐지고, 두 포인터가 다시 같은 커밋을 가리키는 것을 볼 수 있습니다. 이 결과는 <code>git pull</code>을 실행했을 때와 동일합니다.</p>
</li>
</ol>
<blockquote>
<p><strong>언제 <code>fetch</code>를 쓸까?</strong>
동료가 어떤 작업을 했는지 내 로컬 브랜치에 영향을 주지 않고 <strong>미리 확인하고 싶을 때</strong> 매우 유용합니다. <code>fetch</code>로 변경사항을 가져온 뒤, <code>tig</code>로 <code>origin/main</code>의 히스토리를 쭉 훑어보고, 준비가 되었을 때 <code>merge</code>를 실행하는 것이 훨씬 안전한 워크플로우입니다.</p></blockquote>
<hr>
<h4 id="모듈-4-요약">모듈 4 요약</h4>
<p>당신은 이제 로컬 작업을 원격 저장소에 공유(<code>push</code>)하고, 팀원의 작업을 내 로컬로 가져오는(<code>pull</code>) 방법을 마스터했습니다.</p>
<p>더 나아가, <code>tig</code>의 원격 브랜치 포인터(<code>origin/main</code>)의 움직임을 통해 <code>fetch</code>와 <code>pull</code>의 근본적인 차이점을 <strong>시각적으로 완벽하게 이해</strong>했습니다.</p>
<p>이제 당신은 Git을 이용한 기본적인 팀 협업을 수행할 준비가 되었습니다.</p>
<p>다음 모듈에서는 과거의 실수를 바로잡거나, 필요한 커밋만 쏙쏙 가져오는 등 Git의 강력한 시간 여행 기술들을 배워보겠습니다.</p>
<hr>
<h3 id="모듈-5-시간-여행과-문제-해결-고급-스킬"><strong>모듈 5: 시간 여행과 문제 해결 (고급 스킬)</strong></h3>
<p><strong>강좌 목표:</strong> 잘못된 커밋을 안전하게 되돌리고(<code>revert</code>), 과거의 특정 시점으로 돌아가며(<code>reset</code>), 다른 브랜치의 유용한 커밋만 가져오고(<code>cherry-pick</code>), 지저분한 커밋 히스토리를 재구성하는(<code>rebase -i</code>) 등 Git의 강력한 시간 여행 기술들을 마스터합니다. 이 모든 위험할 수 있는 작업들을 <code>tig</code>를 통해 시각적으로 확인하며 안전하고 자신감 있게 수행하는 능력을 기릅니다.</p>
<hr>
<h3 id="1"><strong>1. <code>revert</code>: 안전하게 과거 되돌리기</strong></h3>
<p>실수로 버그가 있는 코드를 커밋하고 <code>push</code>까지 해버렸다면 어떻게 할까요?</p>
<p>히스토리를 강제로 삭제하는 <code>reset</code>은 팀원들에게 혼란을 줄 수 있어 위험합니다.</p>
<p>이럴 때 **<code>revert</code>**를 사용합니다. <code>revert</code>는 특정 커밋의 변경사항을 <strong>취소하는 새로운 커밋</strong>을 만들어 문제를 해결합니다.</p>
<p><strong>1. 문제 상황 만들기</strong>
먼저, 버그를 포함한 커밋을 만들어 원격 저장소에 <code>push</code>까지 해봅시다.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;This is a critical bug!&#34;</span> &gt;&gt; bug.txt
</span></span><span class="line"><span class="cl">git add bug.txt
</span></span><span class="line"><span class="cl">git commit -m <span class="s2">&#34;Feat: Add new feature (with a bug)&#34;</span>
</span></span><span class="line"><span class="cl">git push origin main</span></span></code></pre></div>
  </figure>
</div>
<p><strong>2. <code>tig</code>로 되돌릴 커밋 확인 및 해시 복사</strong>
<code>tig</code>를 실행하여 방금 만든 &ldquo;Feat: Add new feature (with a bug)&rdquo; 커밋을 찾으세요.</p>
<p>커밋 라인의 맨 앞에 있는 <code>a1b2c3d</code> 같은 7자리의 **커밋 해시(hash)**가 필요합니다.</p>
<p><code>tig</code> 화면에서 해당 커밋 위에 커서를 놓고 <strong><code>y</code></strong> 키를 누르면 해시 값이 클립보드에 복사됩니다.</p>
<p><strong>3. <code>revert</code> 실행</strong>
복사한 해시를 사용하여 <code>revert</code> 명령을 실행합니다.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># a1b2c3d 부분에 방금 복사한 해시를 붙여넣으세요.</span>
</span></span><span class="line"><span class="cl">git revert a1b2c3d</span></span></code></pre></div>
  </figure>
</div>
<p>이 명령을 실행하면 커밋 메시지 편집기가 열립니다.</p>
<p>기본 메시지(&ldquo;Revert &lsquo;&hellip;&rsquo;&quot;)를 그대로 사용하거나 수정 후 저장하고 종료합니다.</p>
<p><strong>4. <code>tig</code>로 결과 확인</strong>
<code>tig</code>를 다시 실행해 보세요.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <pre tabindex="0"><code># &#39;tig&#39; 실행 예시 (Revert 후)
* 4e5f6g7 (HEAD -&gt; main) Revert &#34;Feat: Add new feature (with a bug)&#34;
* a1b2c3d (origin/main) Feat: Add new feature (with a bug)
...</code></pre>
  </figure>
</div>
<ul>
<li><strong>새로운 Revert 커밋:</strong> 기존의 버그 커밋(<code>a1b2c3d</code>)은 그대로 남아있고, 그 위에 &ldquo;Revert&hellip;&ldquo;라는 새로운 커밋(<code>4e5f6g7</code>)이 쌓였습니다.</li>
<li><strong>안전한 히스토리:</strong> 이 <code>Revert</code> 커밋의 내용을 <code>Enter</code>로 확인해 보면, 버그 커밋에서 했던 변경사항을 정확히 반대로 수행(파일을 삭제하거나, 추가했던 내용을 삭제)한 것을 볼 수 있습니다. 기존 히스토리를 삭제하지 않고 새로운 커밋을 추가하여 문제를 해결했기 때문에 팀원들과 공유하기에 매우 안전합니다.</li>
</ul>
<hr>
<h3 id="2"><strong>2. <code>reset</code>: 강력하지만 위험한 과거 바꾸기</strong></h3>
<p><code>reset</code>은 브랜치 포인터를 특정 과거 커밋으로 강제로 이동시켜, 그 이후의 커밋들을 히스토리에서 <strong>사라지게</strong> 만드는 강력한 도구입니다.</p>
<p><strong>아직 <code>push</code>하지 않은, 로컬에만 있는 실수를 바로잡을 때</strong> 매우 유용합니다.</p>
<p><strong><code>--soft</code>, <code>--mixed</code>(기본값), <code>--hard</code> 옵션의 차이</strong></p>
<ul>
<li>
<p><code>--soft</code>: 커밋만 취소. 변경된 파일 내용은 스테이징 영역(<code>git add</code> 한 상태)에 그대로 남아있음.</p>
</li>
<li>
<p><code>--mixed</code>: 커밋과 스테이징을 모두 취소. 변경된 파일 내용은 워킹 디렉토리(수정만 한 상태)에 남아있음.</p>
</li>
<li>
<p><code>--hard</code>: <strong>(주의!)</strong> 커밋, 스테이징, 워킹 디렉토리의 변경 내용을 <strong>모두 삭제</strong>. 해당 시점 이후의 모든 작업이 영구적으로 사라짐.</p>
</li>
<li>
<p>실습: <code>reset --hard</code>의 파괴력 <code>tig</code>로 확인하기**</p>
</li>
</ul>
<ol>
<li>
<p><strong>상황 만들기:</strong> 로컬에서만 두 개의 잘못된 커밋을 만들었다고 가정합시다.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;Mistake 1&#34;</span> &gt; mistake.txt
</span></span><span class="line"><span class="cl">git add . <span class="o">&amp;&amp;</span> git commit -m <span class="s2">&#34;Oops, mistake 1&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;Mistake 2&#34;</span> &gt;&gt; mistake.txt
</span></span><span class="line"><span class="cl">git add . <span class="o">&amp;&amp;</span> git commit -m <span class="s2">&#34;Oops, mistake 2&#34;</span></span></span></code></pre></div>
  </figure>
</div>
</li>
<li>
<p><strong><code>tig</code>로 현재 상태와 돌아갈 지점 확인</strong>
<code>tig</code>를 켜서 방금 만든 두 개의 &ldquo;Oops&rdquo; 커밋과, 그 이전의 정상적인 커밋을 확인하세요. 정상 커밋의 해시를 <code>y</code>로 복사합니다.</p>
</li>
<li>
<p><strong><code>reset --hard</code> 실행</strong></p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># 복사한 정상 커밋의 해시를 붙여넣으세요.</span>
</span></span><span class="line"><span class="cl">git reset --hard &lt;정상_커밋_해시&gt;</span></span></code></pre></div>
  </figure>
</div>
</li>
<li>
<p><strong><code>tig</code>로 결과 확인</strong>
<code>tig</code>를 다시 실행하면, &ldquo;Oops&rdquo; 커밋 두 개가 히스토리에서 <strong>완전히 사라진 것</strong>을 볼 수 있습니다. <code>ls</code> 명령어로 파일 목록을 봐도 <code>mistake.txt</code> 파일이 사라졌습니다. <code>reset --hard</code>는 이렇게 과거를 없었던 일로 만들어 버립니다.</p>
</li>
</ol>
<blockquote>
<p><strong>경고:</strong> <code>reset</code>은 히스토리를 재작성하므로, 이미 팀원과 공유한(<code>push</code>한) 커밋에는 <strong>절대 사용하지 마세요.</strong> 꼭 필요하다면 <code>revert</code>를 사용해야 합니다.</p></blockquote>
<hr>
<h3 id="3"><strong>3. <code>cherry-pick</code>: 필요한 커밋만 쏙쏙 가져오기</strong></h3>
<p><code>feature/A</code> 브랜치에서 작업한 5개의 커밋 중, 딱 1개의 커밋(예: 유용한 유틸리티 함수)만 지금 당장 <code>main</code> 브랜치에도 적용하고 싶을 때가 있습니다.</p>
<p>이럴 때 **<code>cherry-pick</code>**을 사용하면 해당 커밋 하나만 &lsquo;체리처럼 쏙 따서&rsquo; 내 브랜치에 복사해올 수 있습니다.</p>
<p><strong>1. 상황 만들기</strong></p>
<ul>
<li>
<p><code>feature/new-util</code> 이라는 브랜치를 만듭니다.</p>
</li>
<li>
<p>해당 브랜치에서 2개의 커밋을 만듭니다. (하나는 불필요한 커밋, 다른 하나는 유용한 커밋)</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">git checkout -b feature/new-util
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;useless&#34;</span> &gt; temp.txt <span class="o">&amp;&amp;</span> git add . <span class="o">&amp;&amp;</span> git commit -m <span class="s2">&#34;WIP: temporary work&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;export const useful = () =&gt; {}&#34;</span> &gt; util.js <span class="o">&amp;&amp;</span> git add . <span class="o">&amp;&amp;</span> git commit -m <span class="s2">&#34;Feat: Add a very useful utility&#34;</span></span></span></code></pre></div>
  </figure>
</div>
</li>
</ul>
<p><strong>2. <code>tig</code>로 가져올 커밋 확인 및 해시 복사</strong></p>
<ul>
<li><code>main</code> 브랜치로 돌아옵니다. (<code>git checkout main</code>)</li>
<li><code>tig --all</code>을 실행하여 <code>feature/new-util</code> 브랜치를 봅니다.</li>
<li>가져오고 싶은 &ldquo;Feat: Add a very useful utility&rdquo; 커밋을 찾아 해시를 <code>y</code>로 복사합니다.</li>
</ul>
<p><strong>3. <code>cherry-pick</code> 실행</strong></p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">git cherry-pick &lt;복사한_유틸리티_커밋_해시&gt;</span></span></code></pre></div>
  </figure>
</div>
<p><strong>4. <code>tig</code>로 결과 확인</strong>
<code>tig</code>를 실행해 보면, <code>main</code> 브랜치의 최상단에 &ldquo;Feat: Add a very useful utility&rdquo; 커밋이 <strong>그대로 복사되어</strong> 들어온 것을 볼 수 있습니다. <code>feature/new-util</code> 브랜치의 불필요한 커밋은 가져오지 않았습니다.</p>
<hr>
<h3 id="4"><strong>4. <code>rebase -i</code>: 인터랙티브 리베이스로 커밋 재구성하기</strong></h3>
<p><code>push</code> 하기 전에, 너무 자잘하게 만든 커밋들을 하나의 의미 있는 커밋으로 합치거나(squash), 커밋 메시지를 수정하고 싶을 때 **인터랙티브 리베이스(<code>rebase -i</code>)**를 사용합니다. 히스토리를 예술 작품처럼 다듬는 과정입니다.</p>
<p><strong>1. 상황 만들기:</strong> 로컬에서 자잘한 커밋 3개를 만들었다고 가정합니다.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;1&#34;</span> &gt; work.txt <span class="o">&amp;&amp;</span> git add . <span class="o">&amp;&amp;</span> git commit -m <span class="s2">&#34;fix: typo&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;2&#34;</span> &gt;&gt; work.txt <span class="o">&amp;&amp;</span> git add . <span class="o">&amp;&amp;</span> git commit -m <span class="s2">&#34;add part of feature&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;3&#34;</span> &gt;&gt; work.txt <span class="o">&amp;&amp;</span> git add . <span class="o">&amp;&amp;</span> git commit -m <span class="s2">&#34;complete the feature and fix style&#34;</span></span></span></code></pre></div>
  </figure>
</div>
<p><strong>2. <code>tig</code>로 재구성할 커밋 범위 확인</strong>
<code>tig</code>를 켜면 방금 만든 3개의 너저분한 커밋이 보입니다. 이 3개의 커밋을 정리할 것입니다. 현재 위치(<code>HEAD</code>)로부터 3개 이전까지를 의미하는 <code>HEAD~3</code>을 범위로 사용합니다.</p>
<p><strong>3. <code>rebase -i</code> 실행</strong></p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">git rebase -i HEAD~3</span></span></code></pre></div>
  </figure>
</div>
<p><strong>4. 인터랙티브 화면에서 히스토리 편집</strong>
이 명령을 실행하면, 다음과 같은 편집기 화면이 나타납니다.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">pick a1b2c3d fix: typo
</span></span><span class="line"><span class="cl">pick b2c3d4e add part of feature
</span></span><span class="line"><span class="cl">pick c3d4e5f <span class="nb">complete</span> the feature and fix style
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Commands:</span>
</span></span><span class="line"><span class="cl"><span class="c1"># p, pick = use commit</span>
</span></span><span class="line"><span class="cl"><span class="c1"># s, squash = use commit, but meld into previous commit</span>
</span></span><span class="line"><span class="cl">...</span></span></code></pre></div>
  </figure>
</div>
<ul>
<li>
<p>맨 위 커밋(<code>a1b2c3d</code>)은 <code>pick</code>(그대로 둠)으로 놔두고,</p>
</li>
<li>
<p>아래 두 개의 커밋 앞 단어 <code>pick</code>을 <code>s</code> (또는 <code>squash</code>)로 바꿉니다.</p>
</li>
<li>
<p><code>pick</code> → <code>s</code> 로 변경:</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">pick a1b2c3d fix: typo
</span></span><span class="line"><span class="cl">s b2c3d4e add part of feature
</span></span><span class="line"><span class="cl">s c3d4e5f <span class="nb">complete</span> the feature and fix style</span></span></code></pre></div>
  </figure>
</div>
</li>
<li>
<p>편집기를 저장하고 종료하면, 3개 커밋의 메시지를 하나로 합치는 두 번째 편집기 창이 열립니다.</p>
</li>
<li></li>
<li>
<p>여기서 최종 커밋 메시지(예: &ldquo;Feat: Implement the full feature&rdquo;)를 깔끔하게 작성하고 저장, 종료합니다.</p>
</li>
</ul>
<p><strong>5. <code>tig</code>로 결과 확인</strong>
<code>tig</code>를 다시 실행해 보세요. 너저분했던 3개의 커밋이 <strong>하나의 깔끔한 커밋으로 합쳐진</strong> 마법 같은 결과를 볼 수 있습니다.</p>
<p>이제 이 잘 정리된 커밋을 <code>push</code>하면 됩니다.</p>
<hr>
<h4 id="모듈-5-요약">모듈 5 요약</h4>
<p>당신은 이제 Git의 가장 강력한 시간 여행 도구들을 자유자재로 다룰 수 있게 되었습니다.</p>
<p><code>tig</code>를 나침반 삼아, 안전하게 실수를 되돌리고(<code>revert</code>), 로컬 히스토리를 정리하며(<code>reset</code>, <code>rebase -i</code>), 필요한 작업만 쏙쏙 가져오는(<code>cherry-pick</code>) 방법을 체득했습니다.</p>
<p>이는 단순한 명령어 사용을 넘어, 복잡한 프로젝트 히스토리를 자신감 있게 관리하는 &lsquo;Git 전문가&rsquo;로 가는 중요한 발판입니다.</p>
<p>마지막 모듈에서는 이 모든 기술을 내 손에 맞게 최적화하는 방법을 배우겠습니다.</p>
<hr>
<h3 id="모듈-6-tig-나만의-무기로-만들기-최적화-및-활용"><strong>모듈 6: Tig, 나만의 무기로 만들기 (최적화 및 활용)</strong></h3>
<p><strong>강좌 목표:</strong> 지금까지 배운 <code>tig</code>의 기능들을 조합하여 자신만의 효율적인 Git 워크플로우를 만듭니다.</p>
<p>자주 사용하는 단축키와 팁을 익히고, <code>.tigrc</code> 설정 파일을 통해 <code>tig</code>의 외형과 동작을 커스터마이징하여 생산성을 극대화합니다.</p>
<p><code>tig</code>를 &lsquo;그냥 사용하는 도구&rsquo;에서 &lsquo;내 손에 꼭 맞는 무기&rsquo;로 진화시킵니다.</p>
<hr>
<h3 id="1-나만의-tig-워크플로우-만들기"><strong>1. 나만의 Tig 워크플로우 만들기</strong></h3>
<p>숙련된 개발자는 매일 반복하는 작업을 자신만의 루틴으로 만듭니다.</p>
<p><code>tig</code>를 사용하면 Git과 관련된 거의 모든 일상 업무를 터미널을 벗어나지 않고, 일관된 흐름으로 처리할 수 있습니다.</p>
<p><strong>예시: &ldquo;나의 하루&rdquo; 워크플로우</strong></p>
<p>아침에 출근해서 어제 하던 작업을 이어가는 상황을 가정해 봅시다.</p>
<ol>
<li>
<p><strong>(S) 상태 확인:</strong> 터미널을 열고 프로젝트 폴더에서 <code>tig</code>를 실행합니다. 가장 먼저 <strong><code>s</code></strong> 키를 눌러 <strong>Status View</strong>로 들어갑니다.</p>
<ul>
<li>어제 작업하다가 커밋하지 않은 파일은 없는지? (<code>Unstaged changes</code>)</li>
<li>실수로 추가된 불필요한 파일은 없는지?</li>
<li><strong>Action:</strong> <code>tig</code> 화면에서 바로 어제의 변경 사항을 확인합니다.</li>
</ul>
</li>
<li>
<p><strong>(F) 동료 작업 확인:</strong> **<code>q</code>**로 Main View로 돌아와, <strong><code>F</code></strong> 키(대문자)를 누릅니다. (<code>git fetch</code>와 동일)</p>
<ul>
<li><code>tig</code>가 원격 저장소(<code>origin</code>)의 최신 정보를 가져옵니다.</li>
<li><code>origin/main</code> 포인터가 앞으로 이동했다면, 밤새 동료가 새로운 작업을 <code>push</code>했다는 의미입니다.</li>
<li><strong>Action:</strong> <code>j</code>, <code>k</code>로 <code>origin/main</code>까지 이동하며 동료의 커밋 내용을 <code>Enter</code>로 훑어봅니다. 내 작업과 충돌할 부분이 있는지 미리 파악할 수 있습니다.</li>
</ul>
</li>
<li>
<p><strong>(M) 최신 내용 병합:</strong> <code>origin/main</code>의 내용을 내 로컬 브랜치로 합칩니다.</p>
<ul>
<li><strong>안전한 방법:</strong> <code>tig</code> 화면에서 <strong><code>M</code></strong> 키(대문자)를 누릅니다. <code>Merge...?</code> 프롬프트가 뜨면 <code>origin/main</code>을 입력하고 엔터. (<code>git merge origin/main</code>과 동일)</li>
<li><strong>Rebase 선호 시:</strong> 터미널에서 <code>git rebase origin/main</code>을 실행하고 <code>tig</code>로 결과를 확인합니다.</li>
</ul>
</li>
<li>
<p><strong>(작업 &amp; 커밋):</strong> 이제 내 할 일을 합니다. 코드를 작성하고 수정합니다.</p>
<ul>
<li>어느 정도 작업이 완료되면, 다시 <code>tig</code>를 켜고 <code>s</code> (Status View)로 갑니다.</li>
<li><code>u</code> 키로 스테이징하고, <code>C</code> (대문자) 키로 커밋합니다. (모듈 2에서 배운 내용) 이 과정을 반복합니다.</li>
</ul>
</li>
<li>
<p><strong>(P) 작업 내용 공유:</strong> 퇴근 전, 오늘 작업한 내용을 <code>push</code>합니다.</p>
<ul>
<li><code>tig</code> 화면에서 <strong><code>P</code></strong> 키(대문자)를 누릅니다. <code>Push...?</code> 프롬프트가 뜨면 엔터를 누릅니다. (<code>git push</code>와 동일)</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>이 워크플로우의 장점:</strong>
<code>tig</code> 라는 단일 인터페이스 안에서 <strong>상태 확인 → 동료 작업 확인 → 병합 → 내 작업 → 커밋 → 공유</strong>까지의 모든 사이클이 끊김 없이 이어집니다. 컨텍스트 전환 비용이 줄어들어 개발에 더 집중할 수 있습니다.</p></blockquote>
<hr>
<h3 id="2-유용한-단축키와-팁-생산성-부스터"><strong>2. 유용한 단축키와 팁 (생산성 부스터)</strong></h3>
<p><code>tig</code>에는 숨겨진 보석 같은 기능들이 많습니다. 이것들만 알아도 작업 속도가 몇 배는 빨라집니다.</p>
<ul>
<li>
<p><strong><code>/</code> (검색):</strong> Main View에서 <code>/</code>를 누르고 키워드를 입력하면, 커밋 메시지, 작성자, 파일명 등에서 해당 키워드를 포함한 커밋을 찾아 하이라이트해 줍니다. <code>n</code> (다음), <code>N</code> (이전)으로 검색 결과 간 이동이 가능합니다. &ldquo;특정 티켓 번호(#123)와 관련된 모든 커밋 찾기&rdquo; 등에 매우 유용합니다.</p>
</li>
<li>
<p><strong><code>@&lt;file&gt;</code> (특정 파일 히스토리 보기):</strong>
<code>tig</code>를 실행할 때 파일 경로를 함께 주면, 해당 파일의 변경 이력만 필터링해서 보여줍니다.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">tig -- README.md
</span></span><span class="line"><span class="cl"><span class="c1"># 또는 tig 실행 후, :log README.md 입력</span></span></span></code></pre></div>
  </figure>
</div>
<p><code>README.md</code> 파일이 언제, 누구에 의해, 어떻게 변해왔는지 한눈에 볼 수 있습니다.</p>
</li>
<li>
<p><strong><code>L</code> (상세 로그 보기):</strong> Main View에서 커밋을 선택하고 <strong><code>L</code></strong> (대문자) 키를 누르면 <code>git show</code> 명령어처럼 해당 커밋의 메타데이터와 전체 변경 내용을 한 번에 보여줍니다.</p>
</li>
<li>
<p><strong><code>h</code> (도움말):</strong> 어떤 뷰에서든 <code>h</code> 키를 누르면 해당 뷰에서 사용할 수 있는 모든 단축키 목록을 보여줍니다. <code>tig</code>의 모든 기능을 외울 필요가 없습니다. 궁금할 땐 <code>h</code>를 누르세요.</p>
</li>
</ul>
<hr>
<h3 id="3-1"><strong>3. <code>.tigrc</code> 파일로 커스터마이징하기</strong></h3>
<p><code>tig</code>의 진정한 화룡점정은 <strong><code>.tigrc</code></strong> 설정 파일을 통해 나만의 도구로 튜닝하는 것입니다. 이 파일은 보통 홈 디렉토리(<code>~/.tigrc</code>)에 만듭니다.</p>
<p><strong>1. <code>.tigrc</code> 파일 생성</strong></p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">touch ~/.tigrc</span></span></code></pre></div>
  </figure>
</div>
<p>이제 이 파일을 텍스트 편집기로 열어 원하는 설정을 추가하면 됩니다.</p>
<p><strong>2. 추천 커스터마이징 설정 예시</strong></p>
<p>아래 내용을 <code>~/.tigrc</code> 파일에 복사/붙여넣기하고 <code>tig</code>를 다시 실행해 보세요.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <pre tabindex="0"><code># .tigrc 예시

# 1. Main View에 브랜치/태그 정보를 항상 표시 (가장 유용한 설정!)
set main-view = date author:20,width=20 refs commit-title:*,wrap
set line-graphics = utf-8  # ASCII 그래프를 더 예쁜 문자로 표시

# 2. 작성자 이름 대신 이메일 주소 일부를 표시 (옵션)
# set author-display = email

# 3. 자주 사용하는 명령 단축키로 바인딩하기
# Main View에서 대문자 P를 누르면 git push가 바로 실행됨
bind main P !git push
# Main View에서 대문자 F를 누르면 git fetch --prune이 바로 실행됨
# (--prune: 원격에서 삭제된 브랜치를 로컬에서도 깔끔하게 정리해주는 옵션)
bind main F !git fetch --prune

# 4. 색상 테마 변경하기 (기본, blue, black 등)
# set color-scheme = blue</code></pre>
  </figure>
</div>
<p><strong>설정 설명:</strong></p>
<ul>
<li><strong><code>set main-view = ...</code>:</strong> <code>tig</code>의 메인 화면에 표시될 정보의 종류와 너비를 지정합니다. 위 설정은 <code>refs</code>(브랜치/태그)를 항상 보여주게 하여 <code>tig --all</code>을 매번 입력할 필요가 없게 만듭니다.</li>
<li><strong><code>set line-graphics = utf-8</code>:</strong> <code>|</code>, <code>*</code> 같은 기본 ASCII 문자를 <code>│</code>, <code>●</code> 등 더 보기 좋은 특수문자로 바꿔줍니다.</li>
<li><strong><code>bind &lt;view&gt; &lt;key&gt; &lt;command&gt;</code>:</strong> 특정 뷰(<code>main</code>, <code>status</code> 등)에서 특정 키(<code>&lt;key&gt;</code>)를 눌렀을 때 실행될 외부 명령어(<code>&lt;command&gt;</code>)를 지정합니다. <code>!git push</code>처럼 앞에 <code>!</code>를 붙이면 쉘 명령을 실행할 수 있습니다. 위 예시는 <code>P</code>키로 푸시, <code>F</code>키로 페치를 바로 실행하게 해줍니다.</li>
</ul>
<hr>
<h4 id="맺음말-이제-git이-두렵지-않습니다">맺음말: 이제 Git이 두렵지 않습니다</h4>
<p>이 강좌를 통해 여러분은 Git의 기본적인 개념부터 브랜치 전략, 협업, 그리고 과거를 제어하는 고급 기술까지 <code>tig</code>라는 훌륭한 나침반과 함께 항해했습니다.</p>
<ul>
<li><strong>여러분은 이제:</strong>
<ul>
<li>복잡한 Git 히스토리를 한눈에 파악하고,</li>
<li>CLI 환경에서 마우스 없이 빠르고 효율적으로 Git을 다루며,</li>
<li>Merge와 Rebase의 차이를 시각적으로 설명할 수 있고,</li>
<li><code>revert</code>, <code>cherry-pick</code> 같은 고급 기술을 자신감 있게 사용할 수 있으며,</li>
<li><code>tig</code>를 자신만의 워크플로우에 맞게 최적화할 수 있게 되었습니다.</li>
</ul>
</li>
</ul>
<p>Git은 더 이상 두려움의 대상이 아닙니다. <code>tig</code>와 함께라면 Git은 여러분의 가장 강력하고 신뢰할 수 있는 개발 파트너가 될 것입니다. 여기서 멈추지 말고, <a href="https://docs.github.com/en/get-started/quickstart/github-flow">GitHub Flow</a>, <a href="https://nvie.com/posts/a-successful-git-branching-model/">Git-flow</a>와 같은 팀의 브랜치 전략론을 학습하며 더 큰 규모의 협업에 도전해 보세요.</p>
<hr>
<h3 id="보너스-모듈-7-충돌conflict-해결의-기술"><strong>보너스 모듈 7: 충돌(Conflict) 해결의 기술</strong></h3>
<p><strong>강좌 목표:</strong> Git 협업의 필연적인 과정인 &lsquo;충돌(Conflict)&lsquo;을 더 이상 두려워하지 않고, 체계적으로 해결하는 능력을 기릅니다. <code>tig</code>를 통해 충돌 상황을 인지하고, 표준적인 도구를 이용해 해결한 뒤, 깔끔하게 정리된 히스토리를 시각적으로 확인합니다.</p>
<hr>
<h4 id="1-충돌은-왜-언제-발생하는가"><strong>1. 충돌은 왜, 언제 발생하는가?</strong></h4>
<p>충돌은 Git의 오류가 아니라, <strong>의사소통이 필요한 시점이라는 신호</strong>입니다. Git이 두 개의 다른 브랜치를 합치려 할 때, <strong>같은 파일의 같은 라인</strong>을 서로 다르게 수정한 내역을 발견하면 자동으로 결정할 수 없습니다. 이때 Git은 작업을 멈추고 사용자에게 &ldquo;이 부분은 어떻게 합쳐야 할지 당신이 직접 결정해 주세요&quot;라고 요청합니다. 이것이 바로 충돌입니다.</p>
<h4 id="2-merge-충돌-시뮬레이션-및-해결"><strong>2. Merge 충돌 시뮬레이션 및 해결</strong></h4>
<p>가장 흔한 Merge 충돌 상황을 직접 만들고 해결해 봅시다.</p>
<p><strong>1. 충돌 상황 만들기</strong></p>
<ul>
<li>
<p><code>main</code> 브랜치에서 <code>team-rules.md</code> 파일을 만듭니다.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">git checkout main
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;# 우리 팀의 규칙&#34;</span> &gt; team-rules.md
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;- 1. 일찍 출근하기&#34;</span> &gt;&gt; team-rules.md
</span></span><span class="line"><span class="cl">git add . <span class="o">&amp;&amp;</span> git commit -m <span class="s2">&#34;Docs: 팀 규칙 초기 버전 작성&#34;</span></span></span></code></pre></div>
  </figure>
</div>
</li>
<li>
<p>이제 <code>feature/rule-update</code> 브랜치를 만들어 규칙을 수정합니다.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">git checkout -b feature/rule-update
</span></span><span class="line"><span class="cl"><span class="c1"># 1번 규칙을 수정</span>
</span></span><span class="line"><span class="cl">sed -i <span class="s1">&#39;&#39;</span> <span class="s1">&#39;s/일찍 출근하기/정시 출근하기/&#39;</span> team-rules.md <span class="c1"># macOS</span>
</span></span><span class="line"><span class="cl"><span class="c1"># sed -i &#39;s/일찍 출근하기/정시 출근하기/&#39; team-rules.md  # Linux</span>
</span></span><span class="line"><span class="cl">git add . <span class="o">&amp;&amp;</span> git commit -m <span class="s2">&#34;Feat: 출근 규칙 현실화&#34;</span></span></span></code></pre></div>
  </figure>
</div>
</li>
<li>
<p>그런데 그 사이, 다른 팀원이 <code>main</code> 브랜치에서 같은 라인을 다르게 수정했다고 가정합시다.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">git checkout main
</span></span><span class="line"><span class="cl"><span class="c1"># 1번 규칙을 또 다르게 수정</span>
</span></span><span class="line"><span class="cl">sed -i <span class="s1">&#39;&#39;</span> <span class="s1">&#39;s/일찍 출근하기/자율 출근하기/&#39;</span> team-rules.md <span class="c1"># macOS</span>
</span></span><span class="line"><span class="cl"><span class="c1"># sed -i &#39;s/일찍 출근하기/자율 출근하기/&#39; team-rules.md  # Linux</span>
</span></span><span class="line"><span class="cl">git add . <span class="o">&amp;&amp;</span> git commit -m <span class="s2">&#34;Feat: 자율 출근 제도로 변경&#34;</span></span></span></code></pre></div>
  </figure>
</div>
</li>
</ul>
<p><strong>2. 충돌 발생시키기</strong>
이제 <code>main</code> 브랜치에서 <code>feature/rule-update</code> 브랜치를 <code>merge</code> 해봅시다.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">git merge feature/rule-update</span></span></code></pre></div>
  </figure>
</div>
<p>터미널에 <code>CONFLICT (content): Merge conflict in team-rules.md</code> 와 같은 메시지가 뜨며 작업이 멈춥니다.</p>
<p><strong>3. <code>tig</code>로 충돌 상태 확인하기</strong>
이때 <code>tig</code>를 실행하고 <strong><code>s</code></strong> 키를 눌러 Status View를 보면, 충돌의 증거를 명확히 볼 수 있습니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <pre tabindex="0"><code># Status View 예시
[main|MERGING] UU team-rules.md

--
status:
  Unmerged paths:
    (u)se stage 1 (base)  (2)se stage 2 (ours)  (3)se stage 3 (theirs)</code></pre>
  </figure>
</div>
<ul>
<li><code>[main|MERGING]</code>: 브랜치 이름 옆에 <code>MERGING</code> 상태가 표시됩니다.</li>
<li><code>UU</code>: Unmerged, both updated. 양쪽 브랜치에서 모두 수정되어 병합하지 못했다는 의미입니다.</li>
</ul>
<p><strong>4. 충돌 해결하기 (VS Code 활용)</strong>
충돌은 텍스트 편집기에서 직접 해결합니다. VS Code와 같은 최신 편집기는 이 과정을 매우 편리하게 도와줍니다.</p>
<ul>
<li>
<p>터미널에서 <code>code .</code> 를 입력해 VS Code를 엽니다.</p>
</li>
<li>
<p><code>team-rules.md</code> 파일을 열면, 충돌 부분이 다음과 같이 표시됩니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <pre tabindex="0"><code># 우리 팀의 규칙
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
- 1. 자율 출근하기
=======
- 1. 정시 출근하기
&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature/rule-update</code></pre>
  </figure>
</div>
</li>
<li>
<p><strong>해석:</strong></p>
<ul>
<li><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code>: <code>HEAD</code>(현재 브랜치, 즉 <code>main</code>)의 내용입니다.</li>
<li><code>=======</code>: 양쪽 브랜치 내용의 구분선입니다.</li>
<li><code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature/rule-update</code>: 병합하려던 브랜치(<code>feature/rule-update</code>)의 내용입니다.</li>
</ul>
</li>
<li>
<p>VS Code는 이 구문 위에 <strong>[Accept Current Change] | [Accept Incoming Change] | [Accept Both Changes]</strong> 와 같은 편리한 버튼을 제공합니다.</p>
</li>
<li>
<p>여기서는 팀원과 논의 후, &ldquo;자율 출근&quot;으로 결정했다고 가정하고 <strong>[Accept Current Change]</strong> 를 클릭합니다. 또는, 직접 키보드로 해당 라인들을 지우고 최종 합의된 내용(예: <code>- 1. 논의 후 자율 출근으로 결정</code>)으로 수정합니다.</p>
</li>
</ul>
<p><strong>5. 해결 완료 알리기</strong>
충돌 부분을 말끔하게 정리하고 파일을 저장했다면, Git에게 &ldquo;해결 완료!&ldquo;라고 알려주어야 합니다.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">git add team-rules.md
</span></span><span class="line"><span class="cl">git commit</span></span></code></pre></div>
  </figure>
</div>
<p><em><code>git commit</code> 시 <code>-m</code> 옵션을 주지 않으면, Git이 자동으로 &ldquo;Merge branch &lsquo;&hellip;&rsquo;&rdquo; 라는 커밋 메시지가 포함된 편집기 창을 열어줍니다. 그대로 저장하고 종료하면 됩니다.</em></p>
<p><strong>6. <code>tig</code>로 최종 결과 확인</strong>
다시 <code>tig --all</code>을 실행하면, 언제 충돌이 있었냐는 듯 깔끔한 <strong>Merge Commit</strong>이 생성되고 히스토리가 성공적으로 합쳐진 것을 시각적으로 확인할 수 있습니다.</p>
<hr>
<h3 id="보너스-모듈-8-실전-브랜치-전략-git-flow-vs-github-flow"><strong>보너스 모듈 8: 실전 브랜치 전략: Git-flow vs GitHub Flow</strong></h3>
<p><strong>강좌 목표:</strong> 대표적인 두 가지 실전 브랜치 전략의 개념과 차이점을 이해합니다. <code>tig</code>의 그래프를 통해 각 전략이 어떤 히스토리 모양을 만드는지 시각적으로 비교하고, 내 프로젝트에 어떤 전략이 더 적합할지 판단하는 능력을 기릅니다.</p>
<hr>
<h4 id="1-git-flow-체계적인-대규모-프로젝트를-위한-전략"><strong>1. Git-flow: 체계적인 대규모 프로젝트를 위한 전략</strong></h4>
<p>Git-flow는 여러 종류의 브랜치가 각자의 명확한 역할을 가지고 상호작용하는, 다소 복잡하지만 매우 체계적인 전략입니다.</p>
<p>버전 릴리즈가 중요한 소프트웨어(ex: 데스크톱 앱, 모바일 앱)에 적합합니다.</p>
<ul>
<li>
<p><strong>주요 브랜치:</strong></p>
<ul>
<li><code>main</code> (또는 <code>master</code>): <strong>배포된 버전</strong>의 코드만 모아두는 가장 안정적인 브랜치. 직접 커밋하지 않음.</li>
<li><code>develop</code>: 다음 버전에 포함될 기능들이 통합되는 <strong>개발의 중심</strong> 브랜치.</li>
</ul>
</li>
<li>
<p><strong>보조 브랜치:</strong></p>
<ul>
<li><code>feature/*</code>: 새로운 기능 개발을 위한 브랜치. <code>develop</code>에서 분기하여 작업 후, 다시 <code>develop</code>으로 병합.</li>
<li><code>release/*</code>: 배포 준비를 위한 브랜치. <code>develop</code>에서 분기하여 버전 넘버링, 최종 버그 수정 등을 진행. 완료되면 <code>main</code>과 <code>develop</code> 양쪽에 모두 병합.</li>
<li><code>hotfix/*</code>: <strong>긴급 버그 수정</strong>을 위한 브랜치. <code>main</code>에서 직접 분기하여 수정 후, <code>main</code>과 <code>develop</code> 양쪽에 모두 병합.</li>
</ul>
</li>
<li>
<p><code>tig</code>로 본 Git-flow 히스토리:**
<code>tig --all</code> 로 보면, 여러 줄기의 브랜치가 복잡하게 얽히고설키는 모습을 보입니다. <code>feature</code>는 <code>develop</code>으로, <code>release</code>와 <code>hotfix</code>는 <code>main</code>과 <code>develop</code> 양쪽으로 합쳐지는 복잡하지만 질서정연한 그래프가 그려집니다.</p>
</li>
</ul>
<h4 id="2-github-flow-빠르고-지속적인-배포를-위한-전략"><strong>2. GitHub Flow: 빠르고 지속적인 배포를 위한 전략</strong></h4>
<p>GitHub Flow는 Git-flow의 복잡성을 대폭 줄인, 매우 단순하고 빠른 전략입니다.</p>
<p>웹 애플리케이션처럼 수시로 배포가 일어나는 프로젝트(CI/CD)에 매우 적합합니다.</p>
<ul>
<li>
<p><strong>핵심 원칙:</strong> <code>main</code> 브랜치는 <strong>언제나 배포 가능한 상태</strong>로 유지한다.</p>
</li>
<li>
<p><strong>워크플로우:</strong></p>
<ol>
<li>새로운 작업(기능, 버그 수정 등)이 필요하면 <code>main</code>에서 설명적인 이름의 브랜치(<code>feature/user-auth</code>, <code>fix/login-bug</code> 등)를 만든다.</li>
<li>해당 브랜치에서 자유롭게 커밋하며 작업한다.</li>
<li>작업이 완료되면 원격 저장소에 <code>push</code>하고 **Pull Request(PR)**를 생성한다.</li>
<li>PR을 통해 팀원들의 코드 리뷰를 받고, 자동화된 테스트를 통과시킨다.</li>
<li>리뷰와 테스트가 모두 통과되면, 해당 브랜치를 <code>main</code>에 병합하고 즉시 배포한다.</li>
</ol>
</li>
<li>
<p><code>tig</code>로 본 GitHub Flow 히스토리:**
<code>tig --all</code> 로 보면, 마치 생선 뼈처럼 <code>main</code>이라는 하나의 굵은 줄기를 중심으로 짧게 뻗어 나갔다가 다시 합쳐지는 <code>feature</code> 브랜치들의 연속으로 보입니다. Git-flow에 비해 훨씬 단순하고 선형적인 그래프가 그려집니다.</p>
</li>
</ul>
<table>
  <thead>
      <tr>
          <th style="text-align: left">항목</th>
          <th style="text-align: left">Git-flow</th>
          <th style="text-align: left">GitHub Flow</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left"><strong>복잡도</strong></td>
          <td style="text-align: left">높음 (브랜치 종류가 많음)</td>
          <td style="text-align: left">낮음 (<code>main</code> + <code>feature</code>)</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>주요 브랜치</strong></td>
          <td style="text-align: left"><code>main</code>, <code>develop</code></td>
          <td style="text-align: left"><code>main</code></td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>배포 주기</strong></td>
          <td style="text-align: left">계획된 릴리즈 (주기적)</td>
          <td style="text-align: left">수시로, 지속적으로</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>적합한 프로젝트</strong></td>
          <td style="text-align: left">버전 관리 앱, 대규모 시스템</td>
          <td style="text-align: left">웹 서비스, CI/CD 환경</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>Tig 그래프 모양</strong></td>
          <td style="text-align: left">복잡한 다중 줄기 그래프</td>
          <td style="text-align: left">단순한 단일 줄기(어골형) 그래프</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="보너스-모듈-9-git-내부-동작-원리-the-internals"><strong>보너스 모듈 9: Git 내부 동작 원리 (The Internals)</strong></h3>
<p><strong>강좌 목표:</strong> Git을 블랙박스가 아닌, 내부 구조가 보이는 화이트박스로 이해합니다. Git의 3대 핵심 객체(Blob, Tree, Commit)의 관계를 파악하고, <code>.git</code> 폴더 안의 파일들이 어떻게 히스토리를 구성하는지 직접 확인하여 Git에 대한 근본적인 이해를 높입니다.</p>
<hr>
<h4 id="1-1"><strong>1. <code>.git</code> 폴더: 모든 역사가 담긴 곳</strong></h4>
<p><code>git init</code>을 실행하면 생기는 <code>.git</code> 폴더가 Git의 본체입니다. 이 안에 프로젝트의 모든 버전, 브랜치, 설정 정보가 들어있습니다.</p>
<ul>
<li><code>HEAD</code>: 현재 내가 작업 중인 브랜치가 무엇인지 가리키는 포인터. (<code>cat .git/HEAD</code> 로 열어보면 <code>ref: refs/heads/main</code> 과 같이 나옴)</li>
<li><code>refs/</code>: 브랜치, 태그 등 모든 &lsquo;참조&rsquo; 정보가 담긴 폴더. <code>refs/heads/main</code> 파일 안에는 <code>main</code> 브랜치가 가리키는 최신 커밋의 해시값이 들어있습니다.</li>
<li><code>objects/</code>: Git의 핵심 데이터베이스. 프로젝트의 모든 내용물(파일, 디렉토리 구조, 커밋 정보)이 <strong>객체</strong> 형태로 압축되어 저장됩니다.</li>
</ul>
<h4 id="2-git의-3대-핵심-객체"><strong>2. Git의 3대 핵심 객체</strong></h4>
<p>Git은 모든 것을 3가지 종류의 객체로 저장합니다. 모든 객체는 내용에 따라 고유한 40자리의 SHA-1 해시값을 가집니다.</p>
<ol>
<li>
<p><strong>Blob (Binary Large Object):</strong> <strong>파일의 내용물</strong> 그 자체입니다. 파일 이름이나 생성 날짜 같은 메타데이터는 전혀 없고, 오직 순수한 데이터 덩어리입니다. 같은 내용의 파일은 프로젝트 내에서 단 하나의 Blob 객체만 공유합니다.</p>
</li>
<li>
<p><strong>Tree:</strong> <strong>디렉토리 구조</strong>를 저장합니다. 특정 시점의 디렉토리에 어떤 파일(Blob)과 하위 디렉토리(다른 Tree)가 있었는지에 대한 목록과 각 항목의 해시값을 가지고 있습니다. 폴더의 스냅샷과 같습니다.</p>
</li>
<li>
<p><strong>Commit:</strong> <strong>하나의 스냅샷</strong>을 의미하는 가장 중요한 객체입니다. Commit 객체는 다음 정보를 가리키는 포인터를 가지고 있습니다.</p>
<ul>
<li>해당 시점의 최상위 디렉토리 구조 (<code>tree</code> 객체의 해시)</li>
<li>이전 커밋(들) (<code>parent</code> 커밋의 해시)</li>
<li>작성자, 커밋한 사람, 날짜, 그리고 커밋 메시지</li>
</ul>
</li>
</ol>
<h4 id="3-2"><strong>3. <code>git cat-file</code>로 히스토리 추적하기</strong></h4>
<p><code>git cat-file -p &lt;hash&gt;</code> 명령어는 해당 해시값의 객체 내용을 예쁘게 보여주는 마법 같은 도구입니다. 이것으로 히스토리의 연결고리를 직접 따라가 봅시다.</p>
<ol>
<li>
<p><strong>현재 브랜치의 최신 커밋 찾기:</strong></p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">cat .git/refs/heads/main
</span></span><span class="line"><span class="cl"><span class="c1"># 4e5f6g7... 와 같은 해시값이 출력됨</span></span></span></code></pre></div>
  </figure>
</div>
</li>
<li>
<p><strong>Commit 객체 내용 보기:</strong> 위에서 얻은 해시로 Commit 객체를 열어봅니다.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">git cat-file -p 4e5f6g7
</span></span><span class="line"><span class="cl"><span class="c1"># 출력 예시:</span>
</span></span><span class="line"><span class="cl"><span class="c1"># tree a1b2c3d...       &lt;-- 이 커밋의 파일/디렉토리 구조</span>
</span></span><span class="line"><span class="cl"><span class="c1"># parent 1a2b3c4...     &lt;-- 이전 커밋</span>
</span></span><span class="line"><span class="cl"><span class="c1"># author Your Name ...</span>
</span></span><span class="line"><span class="cl"><span class="c1">#</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Merge branch &#39;feature/rule-update&#39;</span></span></span></code></pre></div>
  </figure>
</div>
</li>
<li>
<p><strong>Tree 객체 내용 보기:</strong> 위에서 찾은 <code>tree</code> 해시로 Tree 객체를 열어봅니다.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">git cat-file -p a1b2c3d
</span></span><span class="line"><span class="cl"><span class="c1"># 출력 예시:</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 100644 blob b2c3d4e...  README.md</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 100644 blob c3d4e5f...  team-rules.md</span></span></span></code></pre></div>
  </figure>
</div>
</li>
<li>
<p><strong>Blob 객체 내용 보기:</strong> 위에서 찾은 <code>team-rules.md</code>의 <code>blob</code> 해시로 Blob 객체를 열어봅니다.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">git cat-file -p c3d4e5f
</span></span><span class="line"><span class="cl"><span class="c1"># 출력 예시:</span>
</span></span><span class="line"><span class="cl"><span class="c1"># # 우리 팀의 규칙</span>
</span></span><span class="line"><span class="cl"><span class="c1"># - 1. 논의 후 자율 출근으로 결정</span></span></span></code></pre></div>
  </figure>
</div>
<p>이 과정을 통해, 브랜치(<code>refs/heads/main</code>)는 커밋을, 커밋은 트리와 부모 커밋을, 트리는 블롭을 가리키는 <strong>연결 리스트</strong> 구조임을 알 수 있습니다. <strong><code>tig</code>는 바로 이 연결 구조를 읽어서 우리에게 예쁜 그래프로 시각화해주는 것입니다.</strong></p>
</li>
</ol>
<h4 id="최종-요약">최종 요약</h4>
<p>이 보너스 모듈들을 통해 당신은 이제 실전 협업의 난관인 충돌을 자신감 있게 해결하고, 프로젝트의 성격에 맞는 브랜치 전략을 논의할 수 있으며, Git이 내부적으로 어떻게 동작하는지에 대한 깊은 이해까지 갖추게 되었습니다.</p>
<p>진정한 &lsquo;Git 전문가&rsquo;의 반열에 오르신 것을 축하합니다</p>

      <div class="tag-list-single">
        <a class="btn btn-light" href="/tags/git/" role="button">git</a>
        <a class="btn btn-light" href="/tags/tig/" role="button">tig</a>
        <a class="btn btn-light" href="/tags/visual-git/" role="button">visual git</a>
        </div>
      
      <ins class="adsbygoogle"
          style="display:block"
          data-ad-format="autorelaxed"
          data-ad-client="ca-pub-7748316956330968"
          data-ad-slot="4495825428"></ins>
      <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
      </script>
    </div>
  </div>
</article>

      
      </div>
    </div>
    
    
<div class="bg-light">
    <section class="section section-related container">
      <div class="row justify-content-center">
        <div class="col-md-12 col-lg-12">
          <h2 class="section-title text-center">Related posts</h2>
        </div>
      </div>
      <div class="row justify-content-center">
        <div class="col-lg-12">
          <div class="card">
              <div class="card-body">
                <article>
                  <h2 class="h3"><a class="stretched-link text-body" href="/blog/2025-07-08-how-to-use-git-properly-expert-tips-and-secret-configs/">Git, 아직도 기본 설정으로 쓰십니까? 전문가의 비밀 설정 팁 대방출</a></h2>
                  <p>매일 사용하는 Git, 하지만 여전히 어렵게만 느껴진다면? Git 전문가의 강연을 통해 커스터마이징, 고급 검색, 충돌 해결 등 생산성을 극대화하는 비밀 설정과 팁을 알아봅니다.</p>
                  <p>
  <small>July 9, 2025<span class="stretched-link position-relative reading-time text-nowrap" title="Estimated reading time"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
        <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
        <path d="M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0"></path>
        <path d="M12 7v5l3 3"></path>
      </svg>4&nbsp;minutes</span></small>
</p>
</article>
              </div>
            </div>
          <div class="card">
              <div class="card-body">
                <article>
                  <h2 class="h3"><a class="stretched-link text-body" href="/blog/2022-09-05-how-to-use-git-stash-command/">git stash 자세히 살펴보기</a></h2>
                  <p>Git Tutorial - git stash 완벽 이해</p>
                  <p>
  <small>September 5, 2022<span class="stretched-link position-relative reading-time text-nowrap" title="Estimated reading time"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
        <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
        <path d="M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0"></path>
        <path d="M12 7v5l3 3"></path>
      </svg>3&nbsp;minutes</span></small>
</p>
</article>
              </div>
            </div>
          </div>
      </div>
    </section>
    <script src="https://utteranc.es/client.js"
      repo="cpro95/utterances_mycodings_fly_dev"
      issue-term="pathname"
      theme="github-light"
      label="blog-comment"
      crossorigin="anonymous"
    async>
    </script>
  </div>
  
    <footer class="footer text-muted">
  <div class="container-lg">
    <div class="row">
      <div class="col-lg-8 text-center text-lg-start">
        <ul class="list-inline">
          <li class="list-inline-item"><a class="text-muted" href="/about/">about</a></li>
        </ul>
      </div>
      <div class="col-lg-8 text-center text-lg-end">
        <ul class="list-inline">
          <li class="list-inline-item">Copyright (c) All Right Reserved.</li>
        </ul>
      </div>
    </div>
  </div>
</footer>

    

<script async
  src="/js/app.19b73e0182301dd61c9211c2f6890104740e2eb9eb12fe4ba8d4f31435b22ed6.js"
  integrity="sha256-Gbc&#43;AYIwHdYckhHC9okBBHQOLrnrEv5LqNTzFDWyLtY=">
</script>





<script async
  src="/js/flexsearch.5dd6433c29c3e043627f046054aed58ff3790f58fdb8423f45125bbafdcad335.js"
  integrity="sha256-XdZDPCnD4ENifwRgVK7Vj/N5D1j9uEI/RRJbuv3K0zU=">
</script>
<script async
  src="/js/search-modal.96e662d8f691fe25c859a3437074b485f2d7bed0bca612725028c6cf4322e2f2.js"
  integrity="sha256-luZi2PaR/iXIWaNDcHS0hfLXvtC8phJyUCjGz0Mi4vI=">
</script>

    <div class="d-inline-flex fixed-bottom-right pb-4 pe-4">
  <button id="toTop" type="button" class="btn btn-primary rounded-circle ms-auto p-2"><span class="visually-hidden">Top</span><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-up" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M6 15l6 -6l6 6"></path></svg></button>
</div>

    
  </body>
</html>
