<!doctype html>
<html lang="ko" data-bs-theme="auto">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><link rel="preload" href="https://mycodingshub.github.io/fonts/vendor/jost/jost-v4-latin-regular.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="https://mycodingshub.github.io/fonts/vendor/jost/jost-v4-latin-500.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="https://mycodingshub.github.io/fonts/vendor/jost/jost-v4-latin-700.woff2" as="font" type="font/woff2" crossorigin>
<script 
  src="/js/color-mode.86a91f050a481d0a3f0c72ac26543cb6228c770875981c58dcbc008fd3f875c8.js"
  integrity="sha256-hqkfBQpIHQo/DHKsJlQ8tiKMdwh1mBxY3LwAj9P4dcg=">
</script>


<link rel="stylesheet" href="/main.86b7305f5a96b7dd3a46fa6277d87b125af3bf13f48c4cfcc269be84fa9e8fb75375d45a5fe9056ce9190644b7a6e5f13f917f12d853ed38bb76d8856898f755.css" integrity="sha512-hrcwX1qWt906Rvpid9h7ElrzvxP0jEz8wmm+hPqej7dTddRaX+kFbOkZBkS3puXxP5F/EthT7Ti7dtiFaJj3VQ==" crossorigin="anonymous">

<noscript><style>img.lazyload { display: none; }</style></noscript><title>TypeScript 타입 기초 완전 정복! 2편 - 제네릭, 튜플, 유니언, never, 교차 타입</title>
<meta name="description" content="TypeScript 타입을 자유자재로 활용하는 방법을 배우는 2편! 제네릭, 튜플, 유니온, never, 교차 타입 등 강력한 타입 표현 기법을 알려드립니다." />
<link rel="canonical" href="https://mycodingshub.github.io/blog/2024-10-21-typescript-type-advanced-second/" />
<meta name="robots" content="index, follow" />

<meta property="og:type" content="article" />
<meta property="og:title" content="TypeScript 타입 기초 완전 정복! 2편 - 제네릭, 튜플, 유니언, never, 교차 타입" />
<meta property="og:description" content="TypeScript 타입을 자유자재로 활용하는 방법을 배우는 2편! 제네릭, 튜플, 유니온, never, 교차 타입 등 강력한 타입 표현 기법을 알려드립니다." />
<meta property="og:url" content="https://mycodingshub.github.io/blog/2024-10-21-typescript-type-advanced-second/" />
<meta property="og:site_name" content="Home" />
<meta property="og:image" content="https://mycodingshub.github.io/cover.png" />
<meta property="og:locale" content="en" />
<meta property="article:published_time" content="2024-10-21T12:20:18Z" />
<meta property="article:modified_time" content="2024-10-21T12:20:18Z" />
<meta property="article:tag" content="TypeScript" />
<meta property="article:tag" content="타입스크립트" />
<meta property="article:tag" content="제네릭" />
<meta property="article:tag" content="튜플" />
<meta property="article:tag" content="유니온 타입" />
<meta property="article:tag" content="타입 좁히기" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:title" content="TypeScript 타입 기초 완전 정복! 2편 - 제네릭, 튜플, 유니언, never, 교차 타입" />
<meta name="twitter:description" content="TypeScript 타입을 자유자재로 활용하는 방법을 배우는 2편! 제네릭, 튜플, 유니온, never, 교차 타입 등 강력한 타입 표현 기법을 알려드립니다." />
<meta name="twitter:image" content="https://mycodingshub.github.io/cover.png" />

<meta name="author" content="cpro95@gmail.com" />

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "\"TypeScript 타입 기초 완전 정복! 2편 - 제네릭, 튜플, 유니언, never, 교차 타입\"",
  "description": "\"TypeScript 타입을 자유자재로 활용하는 방법을 배우는 2편! 제네릭, 튜플, 유니온, never, 교차 타입 등 강력한 타입 표현 기법을 알려드립니다.\"",
  "datePublished": "\"2024-10-21T12:20:18Z\"",
  "dateModified": "\"2024-10-21T12:20:18Z\"",
  "author": {
    "@type": "Person",
    "name": "\"cpro95@gmail.com\""
  },
  "image": "\"https://mycodingshub.github.io/cover.png\"",
  "url": "\"https://mycodingshub.github.io/blog/2024-10-21-typescript-type-advanced-second/\"",
  "publisher": {
    "@type": "Organization",
    "name": "\"Home\""
  }
}
</script>




<script async src="https://www.googletagmanager.com/gtag/js?id=G-C7SBETWEJ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-C7SBETWEJ0');
</script>


<script
  async
  src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7748316956330968"
  crossOrigin="anonymous"
></script>


</head>

  
  <body class="single section blog" data-bs-spy="scroll" data-bs-target="#toc" data-bs-root-margin="0px 0px -60%" data-bs-smooth-scroll="true" tabindex="0">
    <div class="sticky-top">
<header class="navbar navbar-expand-sm">
  <div class="container-lg">
  <div class="d-flex flex-grow-1 justify-content-between">
    <div class="d-flex flex-row navbar-nav justify-content-between align-items-start gap-2">
    
    <a class="nav-link fw-bold fs-4" href="/">Home</a>

    
    
            <a class="nav-link fs-4  active" href="https://mycodingshub.github.io/blog/" aria-current="true">Blog</a>
          
        
            <a class="nav-link fs-4 " href="https://mycodingshub.github.io/life/">Life</a>
          
        
    </div>
    <div class="d-flex flex-row justify-content-between align-items-center">
      
      
      <button type="button" id="searchToggleMobile" class="btn btn-link nav-link mx-2 d-lg-none" aria-label="Search website">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
          <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
          <circle cx="10" cy="10" r="7"></circle>
          <line x1="21" y1="21" x2="15" y2="15"></line>
        </svg>
      </button>
      
      
      <button type="button" id="searchToggleDesktop" class="btn btn-link nav-link p-2 d-none d-lg-block" aria-label="Search website">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
          <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
          <circle cx="10" cy="10" r="7"></circle>
          <line x1="21" y1="21" x2="15" y2="15"></line>
        </svg>
      </button>
      
      <button id="buttonColorMode" class="btn btn-link mx-auto nav-link p-0 ms-lg-2 me-lg-1" type="button" aria-label="Toggle theme">
        <svg data-bs-theme-value="dark" xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-moon" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
          <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
          <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
        </svg>
        <svg data-bs-theme-value="light" xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-sun" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
          <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
          <path d="M12 12m-4 0a4 4 0 1 0 8 0a4 4 0 1 0 -8 0m-5 0h1m8 -9v1m8 8h1m-9 8v1m-6.4 -15.4l.7 .7m12.1 -.7l-.7 .7m0 11.4l.7 .7m-12.1 -.7l-.7 .7"></path>
        </svg>
      </button>
      </div>
        
        
        
        
        </div>
    </div>

    
    </div>
</header>
</div>

<div class="modal" id="searchModal" tabindex="-1" aria-labelledby="searchModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-fullscreen-md-down">
    <div class="modal-content">
      <div class="modal-header">
        <h1 class="modal-title fs-5 visually-hidden" id="searchModalLabel">Search</h1>
        <button type="button" class="btn-close visually-hidden" data-bs-dismiss="modal" aria-label="Close"></button>
        <div class="search-input flex-grow-1 d-none">
          <form id="search-form" class="search-form" action="#" method="post" accept-charset="UTF-8" role="search">
            <label for="query" class="visually-hidden">Search</label>
            <div class="d-flex">
              <input type="search" id="query" name="query" class="search-text form-control form-control-lg" placeholder="Search" aria-label="Search" maxlength="128" autocomplete="off">
              <button type="button" class="btn btn-link text-decoration-none px-0 ms-3 d-md-none" data-bs-dismiss="modal" aria-label="Close">Cancel</button>
            </div>
          </form>
        </div>
      </div>
      <div class="modal-body">
        <p class="search-loading status message d-none mt-3 text-center">Loading search index…</p>
        <p class="search-no-recent message d-none mt-3 text-center">No recent searches</p>
        <p class="search-no-results message d-none mt-3 text-center">No results for "<strong><span class="query-no-results">Query here</span></strong>"</p>
        <div id="searchResults" class="search-results"></div>
        <template>
          <article class="search-result list-view">
            <div class="card my-3">
              <div class="card-body">
                <header>
                  <h2 class="h5 title title-submitted mb-0"><a class="stretched-link text-decoration-none text-reset" href="#">Title here</a></h2>
                  <div class="submitted d-none"><time class="created-date">Date here</time></div>
                </header>
                <div class="content">Summary here</div>
              </div>
            </div>
          </article>
        </template>
      </div>
      <div class="modal-footer">
        <ul class="list-inline me-auto d-none d-md-block">
          <li class="list-inline-item"><kbd class="me-2"><svg width="15" height="15" aria-label="Enter key" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M12 3.53088v3c0 1-1 2-2 2H4M7 11.53088l-3-3 3-3"></path></g></svg></kbd><span class="DocSearch-Label">to select</span></li>
          <li class="list-inline-item"><kbd class="me-2"><svg width="15" height="15" aria-label="Arrow down" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M7.5 3.5v8M10.5 8.5l-3 3-3-3"></path></g></svg></kbd><kbd class="me-2"><svg width="15" height="15" aria-label="Arrow up" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M7.5 11.5v-8M10.5 6.5l-3-3-3 3"></path></g></svg></kbd><span class="DocSearch-Label">to navigate</span></li>
          <li class="list-inline-item"><kbd class="me-2"><svg width="15" height="15" aria-label="Escape key" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M13.6167 8.936c-.1065.3583-.6883.962-1.4875.962-.7993 0-1.653-.9165-1.653-2.1258v-.5678c0-1.2548.7896-2.1016 1.653-2.1016.8634 0 1.3601.4778 1.4875 1.0724M9 6c-.1352-.4735-.7506-.9219-1.46-.8972-.7092.0246-1.344.57-1.344 1.2166s.4198.8812 1.3445.9805C8.465 7.3992 8.968 7.9337 9 8.5c.032.5663-.454 1.398-1.4595 1.398C6.6593 9.898 6 9 5.963 8.4851m-1.4748.5368c-.2635.5941-.8099.876-1.5443.876s-1.7073-.6248-1.7073-2.204v-.4603c0-1.0416.721-2.131 1.7073-2.131.9864 0 1.6425 1.031 1.5443 2.2492h-2.956"></path></g></svg></kbd><span class="DocSearch-Label">to close</span></li>
        </ul>
        <p class="d-md-none">Search by <a class="text-decoration-none" href="https://github.com/nextapps-de/flexsearch">FlexSearch</a></p>
      </div>
    </div>
  </div>
</div>


    <div class="wrap container-lg" role="document">
      <div class="content">
      
        
<article>
  <div class="row justify-content-center">
    <div class="col-md-12 col-lg-12">
      
      <ins class="adsbygoogle"
        style="display:block"
        data-ad-client="ca-pub-7748316956330968"
        data-ad-slot="2971373181"
        data-ad-format="auto"
        data-full-width-responsive="true"></ins>
      <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
      </script>
      <div class="blog-header">
        <h1>TypeScript 타입 기초 완전 정복! 2편 - 제네릭, 튜플, 유니언, never, 교차 타입</h1>
        <p>
  <small>October 21, 2024<span class="stretched-link position-relative reading-time text-nowrap" title="Estimated reading time"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
        <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
        <path d="M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0"></path>
        <path d="M12 7v5l3 3"></path>
      </svg>24&nbsp;minutes</span></small>
</p>

      </div>
    </div>
      <div class="col-md-12 col-lg-12">
      
      <p>안녕하세요?</p>
<p>Typescript 타입 기초 완전 정복 2편입니다.</p>
<p>전체 강좌 링크는 아래와 같습니다.</p>
<ol>
<li>
<p><a href="https://mycodingshub.github.io/blog/2024-10-21-typescript-type-basics-first">TypeScript 타입 기초 완전 정복! 1편 - 프리미티브, 객체, 함수, 배열</a></p>
</li>
<li>
<p><a href="https://mycodingshub.github.io/blog/2024-10-21-typescript-type-advanced-second">TypeScript 타입 기초 완전 정복! 2편 - 제네릭, 튜플, 유니언, never, 교차 타입</a></p>
</li>
<li>
<p><a href="https://mycodingshub.github.io/blog/2024-10-21-typescript-type-master-third">TypeScript 타입 기초 완전 정복! 3편 - as const, unknown, Mapped, Conditional 타입 완벽 분석</a></p>
</li>
</ol>
<hr>
<p>** 목 차 **</p>
<ul>
<li><a href="#%ec%a0%9c%eb%84%a4%eb%a6%ad">제네릭</a></li>
<li><a href="#%ed%8a%9c%ed%94%8c-%ed%83%80%ec%9e%85">튜플 타입</a></li>
<li><a href="#%ed%8a%9c%ed%94%8c-%ed%83%80%ec%9e%85%ea%b3%bc-%ea%b0%80%eb%b3%80-%ec%9d%b8%ec%9e%90">튜플 타입과 가변 인자</a></li>
<li><a href="#%ed%95%a8%ec%88%98-%ed%98%b8%ec%b6%9c%ec%9d%98-%ec%8a%a4%ed%94%84%eb%a0%88%eb%93%9c%ec%99%80-%ed%8a%9c%ed%94%8c-%ed%83%80%ec%9e%85">함수 호출의 스프레드와 튜플 타입</a></li>
<li><a href="#%ed%8a%9c%ed%94%8c-%ed%83%80%ec%9e%85%ea%b3%bc-%ea%b0%80%eb%b3%80-%ec%9d%b8%ec%9e%90%ec%99%80-%ec%a0%9c%eb%84%a4%eb%a6%ad">튜플 타입과 가변 인자와 제네릭</a></li>
<li><a href="#%ec%9c%a0%eb%8b%88%ec%96%b8-%ed%83%80%ec%9e%85-%ed%95%a9%ec%a7%91%ed%95%a9-%ed%83%80%ec%9e%85">유니언 타입 (합집합 타입)</a></li>
<li><a href="#%ec%9c%a0%eb%8b%88%ec%96%b8-%ed%83%80%ec%9e%85%ec%9d%98-%ec%a2%81%ed%9e%88%ea%b8%b0">유니언 타입의 좁히기</a>
<ul>
<li><a href="#null-%ec%b2%b4%ed%81%ac">null 체크</a></li>
<li><a href="#discriminated-unions-%ec%b0%a8%eb%b3%84%ed%99%94%eb%90%9c-%ec%9c%a0%eb%8b%88%ec%96%b8">Discriminated Unions (차별화된 유니언)</a></li>
</ul>
</li>
<li><a href="#never-%ed%83%80%ec%9e%85"><code>never</code> 타입</a></li>
<li><a href="#%ea%b5%90%ec%b0%a8-%ed%83%80%ec%9e%85-intersection-%ed%83%80%ec%9e%85">교차 타입 (intersection 타입)</a>
<ul>
<li><a href="#%ec%9c%a0%eb%8b%88%ec%96%b8-%ed%83%80%ec%9e%85%ec%9d%84-%ea%b0%80%ec%a7%84-%ed%95%a8%ec%88%98%ec%99%80%ec%9d%98-%ea%b4%80%ea%b3%84">유니언 타입을 가진 함수와의 관계</a></li>
</ul>
</li>
<li><a href="#%ea%b0%9d%ec%b2%b4-%ed%83%80%ec%9e%85-%ec%9e%ac%eb%b0%a9%eb%ac%b8">객체 타입 재방문</a>
<ul>
<li><a href="#-%ec%84%a0%ed%83%9d%ec%a0%81-%ed%94%84%eb%a1%9c%ed%8d%bc%ed%8b%b0"><code>?</code>: 선택적 프로퍼티</a></li>
<li><a href="#%ec%84%a0%ed%83%9d%ec%a0%81-%ed%94%84%eb%a1%9c%ed%8d%bc%ed%8b%b0%ec%97%90-%eb%8c%80%ed%95%9c-%ec%a0%91%ea%b7%bc">선택적 프로퍼티에 대한 접근</a></li>
<li><a href="#exactoptionalpropertytypes%ec%97%90-%eb%8c%80%ed%95%98%ec%97%ac"><code>exactOptionalPropertyTypes</code>에 대하여</a></li>
<li><a href="#readonly"><code>readonly</code></a></li>
<li><a href="#%ec%9d%b8%eb%8d%b1%ec%8a%a4-%ec%8b%9c%ea%b7%b8%eb%8b%88%ec%b2%98">인덱스 시그니처</a></li>
<li><a href="#%ed%95%a8%ec%88%98-%ec%8b%9c%ea%b7%b8%eb%8b%88%ec%b2%98">함수 시그니처</a></li>
<li><a href="#new-%ec%8b%9c%ea%b7%b8%eb%8b%88%ec%b2%98">new 시그니처</a></li>
</ul>
</li>
<li><a href="#as%eb%a5%bc-%ec%9d%b4%ec%9a%a9%ed%95%9c-%eb%8b%a4%ec%9a%b4%ec%ba%90%ec%8a%a4%ed%8c%85"><code>as</code>를 이용한 다운캐스팅</a></li>
</ul>
<hr>
<h2 id="제네릭">제네릭</h2>
<p>타입이 있는 언어에는 흔히 제네릭이라는 것이 존재합니다.</p>
<p>이른바 다형성 타입(polymorphic type)과 관련된 것인데요.</p>
<p>TypeScript에도 제네릭이 있습니다.</p>
<p>타입 이름을 <code>Foo&lt;S, T&gt;</code>와 같이, 즉 이름 뒤에 <code>&lt; &gt;</code>로 둘러싼 이름의 열을 제공함으로써, 타입 정의 안에서 그 이름들을 타입 변수로 사용할 수 있습니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Foo</span><span class="p">&lt;</span><span class="nt">S</span><span class="p">,</span> <span class="na">T</span><span class="p">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span>: <span class="kt">S</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">bar</span>: <span class="kt">T</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span>: <span class="kt">Foo</span><span class="p">&lt;</span><span class="nt">number</span><span class="p">,</span> <span class="na">string</span><span class="p">&gt;</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span>: <span class="kt">3</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">bar</span><span class="o">:</span> <span class="s1">&#39;hi&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div>
  </figure>
</div>
<p>이 예제에서는 <code>Foo</code>가 두 개의 타입 변수 <code>S</code>, <code>T</code>를 가집니다.</p>
<p><code>Foo</code>를 사용하는 쪽에서는 <code>Foo&lt;number, string&gt;</code>과 같이 <code>S</code>와 <code>T</code>에 해당하는 타입을 지정합니다.</p>
<p>또한, 클래스 정의나 함수 정의에서도 타입 변수를 도입할 수 있습니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Foo</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">constructor</span><span class="p">(</span><span class="nx">obj</span>: <span class="kt">T</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Foo</span><span class="p">&lt;</span><span class="nt">string</span><span class="p">&gt;(</span><span class="s1">&#39;foo&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">func</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;(</span><span class="nx">obj</span>: <span class="kt">T</span><span class="p">)</span><span class="o">:</span> <span class="k">void</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">func</span><span class="p">&lt;</span><span class="nt">number</span><span class="p">&gt;(</span><span class="mi">3</span><span class="p">);</span></span></span></code></pre></div>
  </figure>
</div>
<p>그런데 위의 예제에서 <code>func</code>의 타입은 어떻게 될까요?</p>
<p>실제로는 <code>&lt;T&gt;(obj: T) =&gt; void</code>라는 타입이 됩니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">func</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;(</span><span class="nx">obj</span>: <span class="kt">T</span><span class="p">)</span><span class="o">:</span> <span class="k">void</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">f</span><span class="o">:</span> <span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;(</span><span class="nx">obj</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">void</span> <span class="o">=</span> <span class="nx">func</span><span class="p">;</span></span></span></code></pre></div>
  </figure>
</div>
<p>이렇게 함수의 경우 호출할 때까지 어떤 타입 인수로 호출될지 알 수 없기 때문에, 타입에도 타입 변수가 남아 있게 됩니다.</p>
<p>여담이지만, 타입 인수(<code>func&lt;number&gt;(3)</code>의 <code>&lt;number&gt;</code> 부분)는 생략할 수 있습니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">identity</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;(</span><span class="nx">value</span>: <span class="kt">T</span><span class="p">)</span><span class="o">:</span> <span class="nx">T</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">value</span> <span class="o">=</span> <span class="nx">identity</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 오류: Type &#39;3&#39; is not assignable to type &#39;string&#39;.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">str</span>: <span class="kt">string</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span></span></span></code></pre></div>
  </figure>
</div>
<p>이 예제에서 <code>identity</code>는 타입 변수 <code>T</code>를 가집니다만, <code>identity</code>를 호출하는 쪽에서는 <code>T</code>의 지정을 생략했습니다.</p>
<p>이 경우 인수의 정보로부터 <code>T</code>가 추론됩니다.</p>
<p>실제로 이번에 인수로 주어진 <code>3</code>은 <code>3</code> 타입의 값이므로, <code>T</code>가 <code>3</code>으로 추론됩니다.</p>
<p><code>identity</code>의 반환 타입은 <code>T</code> 즉 <code>3</code>이므로, 변수 <code>value</code>의 타입은 <code>3</code>이 됩니다.</p>
<p><code>3</code> 타입의 값은 <code>string</code> 타입의 변수에 넣을 수 없으므로 최종 행에서는 오류가 발생합니다.</p>
<p>이 예제에서 <code>T</code>가 올바르게 추론되고 있음을 알 수 있습니다.</p>
<p>다만, 복잡한 작업을 할 경우 타입 변수를 추론할 수 없는 경우도 있습니다.</p>
<hr>
<h2 id="튜플-타입">튜플 타입</h2>
<p>TypeScript는 튜플 타입이라는 것도 제공하는데요.</p>
<p>하지만 JavaScript에는 튜플이라는 개념이 없습니다.</p>
<p>그래서 TypeScript에서는 배열을 튜플 대신 사용하고 있습니다.</p>
<p>이는 함수에서 여러 값을 반환하고 싶을 때 배열에 담아 한꺼번에 반환하는 등의 유스케이스를 상정한 것 같습니다.</p>
<p>튜플 타입은 <code>[string, number]</code>와 같이 작성합니다.</p>
<p>이는 실제로 길이가 2인 배열로, 0번째에는 문자열이, 1번째에는 숫자가 들어있는 것을 나타냅니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">foo</span><span class="o">:</span> <span class="p">[</span><span class="kt">string</span><span class="p">,</span> <span class="kt">number</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">str</span>: <span class="kt">string</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">makePair</span><span class="p">(</span><span class="nx">x</span>: <span class="kt">string</span><span class="p">,</span> <span class="nx">y</span>: <span class="kt">number</span><span class="p">)</span><span class="o">:</span> <span class="p">[</span><span class="kt">string</span><span class="p">,</span> <span class="kt">number</span><span class="p">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
  </figure>
</div>
<p>하지만 튜플 타입의 사용에는 주의가 필요합니다.</p>
<p>TypeScript가 튜플이라고 부르는 것은 어디까지나 배열이기 때문에, 배열의 메서드로 조작할 수 있습니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">tuple</span><span class="o">:</span> <span class="p">[</span><span class="kt">string</span><span class="p">,</span> <span class="kt">number</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">tuple</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">tuple</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s1">&#39;Hey!&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">num</span>: <span class="kt">number</span> <span class="o">=</span> <span class="nx">tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span></span></span></code></pre></div>
  </figure>
</div>
<p>이 코드는 TypeScript에서 에러 없이 컴파일되지만, 실제로 실행해보면 변수 <code>num</code>에 들어가는 것은 숫자가 아니라 문자열입니다.</p>
<p>이 부분은 TypeScript의 타입 시스템의 한계이므로, 튜플 타입을 사용할 때는 주의하거나, 애초에 이런 방식으로 튜플 타입을 사용하는 것은 피하는 것이 좋을지도 모릅니다.</p>
<p>참고로, 요소가 0개인 튜플 타입도 만들 수 있습니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">unit</span><span class="o">:</span> <span class="p">[]</span> <span class="o">=</span> <span class="p">[];</span></span></span></code></pre></div>
  </figure>
</div>
<p>또한, TypeScript의 튜플 타입은 가변 길이의 튜플 타입 선언이 가능합니다.</p>
<p>그것이 과연 튜플인가라는 의문이 남지만, 이는 실질적으로 처음 몇 개의 요소의 타입이 특별히 취급되는 배열의 타입이 됩니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">type</span> <span class="nx">NumAndStrings</span> <span class="o">=</span> <span class="p">[</span><span class="kt">number</span><span class="p">,</span> <span class="p">...</span><span class="kt">string</span><span class="p">[]];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">a1</span>: <span class="kt">NumAndStrings</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">a2</span>: <span class="kt">NumAndStrings</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 오류: Type &#39;string&#39; is not assignable to type &#39;number&#39;.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">a3</span>: <span class="kt">NumAndStrings</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">];</span></span></span></code></pre></div>
  </figure>
</div>
<p>이처럼, 가변 길이 튜플 타입은 마지막에 <code>...</code>(배열 타입)이라는 요소를 추가한 튜플 타입으로 표현됩니다.</p>
<p>여기서 정의한 <code>NumAndStrings</code> 타입은 첫 번째 요소가 숫자이고, 나머지는 문자열인 배열의 타입입니다.</p>
<p>변수 <code>a3</code>는 첫 번째 요소가 숫자가 아니기 때문에 오류가 발생합니다.</p>
<p>물론 <code>[number, string, ...any[]]</code>처럼 타입이 지정된 요소가 여러 개여도 괜찮습니다.</p>
<p><code>...</code> 배열은 튜플 타입의 다른 위치에도 쓸 수 있습니다.</p>
<p>예를 들어, 마지막 요소만 <code>number</code> 타입이고 나머지는 <code>string</code> 타입인 배열은 다음과 같이 쓸 수 있습니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">type</span> <span class="nx">StrsAndNumber</span> <span class="o">=</span> <span class="p">[...</span><span class="kt">string</span><span class="p">[],</span> <span class="kt">number</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">b1</span>: <span class="kt">StrsAndNumber</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;baz&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">b2</span>: <span class="kt">StrsAndNumber</span> <span class="o">=</span> <span class="p">[</span><span class="mi">123</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 오류:
</span></span></span><span class="line"><span class="cl"><span class="c1">// Type &#39;[string, string]&#39; is not assignable to type &#39;StrsAndNumber&#39;.
</span></span></span><span class="line"><span class="cl"><span class="c1">//   Type at position 1 in source is not compatible with type at position 1 in target.
</span></span></span><span class="line"><span class="cl"><span class="c1">//     Type &#39;string&#39; is not assignable to type &#39;number&#39;.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">b3</span>: <span class="kt">StrsAndNumber</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">];</span></span></span></code></pre></div>
  </figure>
</div>
<p>하지만 <code>...</code>를 쓸 수 있는 것은 튜플 타입의 어느 위치든 한 번만 가능합니다.</p>
<p>예를 들어 &ldquo;먼저 숫자가 늘어서 오고 그 다음에 문자열이 오는 배열의 타입&quot;으로 <code>[...number[], ...string[]]</code> 같은 타입을 생각할 수 있지만, 이는 <code>...</code>를 두 번 사용하므로 안 됩니다.</p>
<p>또한, 선택적 요소를 가지는 튜플 타입도 있습니다.</p>
<p>이는 <code>[string, number?]</code>처럼 타입에 <code>?</code>가 붙은 요소를 가지는 튜플 타입입니다.</p>
<p>이 경우 두 번째 요소는 있어도 되고 없어도 된다는 의미입니다.</p>
<p>있는 경우에는 <code>number</code> 타입이어야 합니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">type</span> <span class="nx">T</span> <span class="o">=</span> <span class="p">[</span><span class="kt">string</span><span class="p">,</span> <span class="kt">number</span><span class="o">?</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">t1</span>: <span class="kt">T</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">t2</span>: <span class="kt">T</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span></span></span></code></pre></div>
  </figure>
</div>
<p>선택적 요소는 여러 개여도 되지만, 그렇지 않은 요소보다 뒤에 와야 합니다.</p>
<p>예를 들어 <code>[string?, number]</code>와 같은 타입은 안 됩니다.</p>
<hr>
<h2 id="튜플-타입과-가변-인자">튜플 타입과 가변 인자</h2>
<p>TypeScript 3.0 부터 튜플 타입의 재미있는 사용 방법이 추가되었습니다.</p>
<p>그것은 튜플 타입을 함수의 가변 인자 타입을 나타내는 데 사용할 수 있다는 것입니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">type</span> <span class="nx">Args</span> <span class="o">=</span> <span class="p">[</span><span class="kt">string</span><span class="p">,</span> <span class="kt">number</span><span class="p">,</span> <span class="kr">boolean</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">func</span> <span class="o">=</span> <span class="p">(...</span><span class="nx">args</span>: <span class="kt">Args</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">args</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">v</span> <span class="o">=</span> <span class="nx">func</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// v의 타입은 number
</span></span></span></code></pre></div>
  </figure>
</div>
<p>조금 전에 가변 인자의 타입으로 배열을 사용한다고 소개했는데요.</p>
<p>실제로 배열 대신 튜플 타입을 사용할 수 있습니다.</p>
<p>위의 예제에서는 가변 인자 <code>args</code>의 타입이 <code>Args</code>, 즉 <code>[string, number, boolean]</code>입니다.</p>
<p>이에 맞추기 위해, 즉 인자의 열 <code>args</code>가 타입 <code>Args</code>를 가지도록 하기 위해서는 함수 <code>func</code>의 첫 번째 인자의 타입은 <code>string</code>, 다음은 <code>number</code>, 그 다음은 <code>boolean</code>이어야 합니다.</p>
<p>가변 인자라는 이름과는 달리 고정된 개수의 인자를 받게 되지만, 이렇게 튜플 타입을 타입의 열로 사용함으로써 여러 인자의 타입을 한꺼번에 지정할 수 있는 것이죠.</p>
<p>여기서 가변 길이 튜플을 사용한 경우, 인자의 가변성이 유지됩니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">type</span> <span class="nx">Args</span> <span class="o">=</span> <span class="p">[</span><span class="kt">string</span><span class="p">,</span> <span class="p">...</span><span class="kt">number</span><span class="p">[]];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">func</span> <span class="o">=</span> <span class="p">(</span><span class="nx">f</span>: <span class="kt">string</span><span class="p">,</span> <span class="p">...</span><span class="nx">args</span>: <span class="kt">Args</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">v1</span> <span class="o">=</span> <span class="nx">func</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">v2</span> <span class="o">=</span> <span class="nx">func</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span></span></span></code></pre></div>
  </figure>
</div>
<p>또한, 마찬가지로 선택적 요소를 가진 튜플 타입을 사용한 경우에는 선택적 인자를 가진 함수 타입이 됩니다.</p>
<hr>
<h2 id="함수-호출의-스프레드와-튜플-타입">함수 호출의 스프레드와 튜플 타입</h2>
<p>그런데 JavaScript에서는 <code>...</code>라는 표기를 함수 호출 시에도 사용할 수 있습니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">func</span> <span class="o">=</span> <span class="p">(...</span><span class="nx">args</span>: <span class="kt">string</span><span class="p">[])</span> <span class="o">=&gt;</span> <span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">strings</span>: <span class="kt">string</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;baz&#39;</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">func</span><span class="p">(...</span><span class="nx">strings</span><span class="p">);</span></span></span></code></pre></div>
  </figure>
</div>
<p><code>func(...strings)</code>의 의미는 배열 <code>strings</code>의 내용을 <code>func</code>의 인자로 펼쳐 호출한다는 것입니다.</p>
<p>즉, <code>func</code>의 첫 번째 인자는 <code>strings</code>의 첫 번째 요소가 되고, 두 번째 인자는 두 번째 요소가 되는 식입니다.</p>
<p>튜플 타입은 여기서도 사용할 수 있습니다.</p>
<p>적절한 튜플 타입의 배열을 <code>...</code>로 펼침으로써, 타입에 맞는 함수를 호출할 수 있습니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">func</span> <span class="o">=</span> <span class="p">(</span><span class="nx">str</span>: <span class="kt">string</span><span class="p">,</span> <span class="nx">num</span>: <span class="kt">number</span><span class="p">,</span> <span class="nx">b</span>: <span class="kt">boolean</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nx">args</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">args</span><span class="o">:</span> <span class="p">[</span><span class="kt">string</span><span class="p">,</span> <span class="kt">number</span><span class="p">,</span> <span class="kr">boolean</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="kc">false</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">func</span><span class="p">(...</span><span class="nx">args</span><span class="p">);</span></span></span></code></pre></div>
  </figure>
</div>
<hr>
<h2 id="튜플-타입과-가변-인자와-제네릭">튜플 타입과 가변 인자와 제네릭</h2>
<p>이제까지의 지식과 제네릭을 결합함으로써 재미있는 일을 할 수 있는데요.</p>
<p>튜플 타입을 취하는 타입 변수를 사용함으로써, 함수의 인자 열을 제네릭으로 다룰 수 있는 겁니다.</p>
<p>예를 들어, 함수의 첫 번째 인자가 미리 정해져 있는 새로운 함수를 만드는 함수 <code>bind</code>를 작성해보겠습니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">bind</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">,</span> <span class="na">U</span> <span class="na">extends</span> <span class="na">any</span><span class="err">[]</span><span class="p">,</span> <span class="na">R</span><span class="p">&gt;(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">func</span><span class="o">:</span> <span class="p">(</span><span class="nx">arg1</span>: <span class="kt">T</span><span class="p">,</span> <span class="p">...</span><span class="nx">rest</span>: <span class="kt">U</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">R</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">value</span>: <span class="kt">T</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="o">:</span> <span class="p">((...</span><span class="nx">args</span>: <span class="kt">U</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">R</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">(...</span><span class="nx">args</span>: <span class="kt">U</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">func</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="p">...</span><span class="nx">args</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">add</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span>: <span class="kt">number</span><span class="p">,</span> <span class="nx">y</span>: <span class="kt">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">add1</span> <span class="o">=</span> <span class="nx">bind</span><span class="p">(</span><span class="nx">add</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">add1</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span> <span class="c1">// 6
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// Argument of type &#39;&#34;foo&#34;&#39; is not assignable to parameter of type &#39;number&#39;.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">add1</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">);</span></span></span></code></pre></div>
  </figure>
</div>
<p>함수 <code>bind</code>는 두 개의 인자 <code>func</code>와 <code>value</code>를 받아, 새로운 함수 <code>(...args: U) =&gt; func(value, ...args)</code>를 반환합니다.</p>
<p>이 함수는 받은 인자 열 <code>args</code>에 더해 첫 번째 인자로 <code>value</code>를 <code>func</code>에 전달하여 호출한 반환값을 그대로 반환하는 함수입니다.</p>
<p>포인트는 먼저 <code>U extends any[]</code> 부분인데요.</p>
<p>이는 새로운 표기법으로, 타입 인수 <code>U</code>는 <code>any[]</code>의 부분 타입이어야 한다는 의미입니다.</p>
<p><code>string[]</code> 등의 배열 타입에 더해 튜플 타입도 모두 <code>any[]</code>의 부분 타입입니다.</p>
<p>이 제한을 추가함으로써 <code>...rest: U</code>처럼 가변 인자의 타입으로 <code>U</code>를 사용할 수 있습니다.</p>
<p>또한 <code>bind(add, 1)</code>의 호출에서는 타입 변수가 각각 <code>T = number</code>, <code>U = [number]</code>, <code>R = number</code>로 추론됩니다.</p>
<p>반환 타입은 <code>(...args: U) =&gt; R</code> 즉 <code>(arg: number) =&gt; number</code>가 됩니다.</p>
<p>특히 <code>U</code>가 튜플 타입으로 추론되는 것이 스마트하죠.</p>
<p>이를 통해 <code>add</code>의 인자 정보가 손실되지 않고 <code>add1</code>에 이어집니다.</p>
<p>좀더 상세하게 타입스크립트가 어떻게 타입을 추론하는지 단계별로 설명해 보면,</p>
<ol>
<li>
<p><strong><code>bind(add, 1)</code> 호출:</strong></p>
<p><code>bind</code> 함수가 <code>add</code> 함수와 값 <code>1</code>을 인수로 받아 호출됩니다.  이때 TypeScript 컴파일러는 제네릭 타입 매개변수 <code>T</code>, <code>U</code>, <code>R</code>을 추론하기 시작합니다.</p>
</li>
<li>
<p><strong>타입 추론:</strong></p>
</li>
</ol>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">bind</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">,</span> <span class="na">U</span> <span class="na">extends</span> <span class="na">any</span><span class="err">[]</span><span class="p">,</span> <span class="na">R</span><span class="p">&gt;(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">func</span><span class="o">:</span> <span class="p">(</span><span class="nx">arg1</span>: <span class="kt">T</span><span class="p">,</span> <span class="p">...</span><span class="nx">rest</span>: <span class="kt">U</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">R</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">value</span>: <span class="kt">T</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="o">:</span> <span class="p">((...</span><span class="nx">args</span>: <span class="kt">U</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">R</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">(...</span><span class="nx">args</span>: <span class="kt">U</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">func</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="p">...</span><span class="nx">args</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
  </figure>
</div>
<ul>
<li>
<p><strong><code>T</code>의 추론:</strong> <code>bind</code> 함수의 두 번째 인수 <code>value</code>는 <code>1</code> (숫자)입니다.  따라서 <code>T</code>는 <code>number</code>로 추론됩니다.</p>
</li>
<li>
<p><strong><code>R</code>의 추론:</strong>  <code>add</code> 함수의 타입 시그니처는 <code>(x: number, y: number) =&gt; number</code> 입니다.  <code>bind</code> 함수의 첫 번째 인수의 타입 시그니처를 분석하여 <code>R</code>을 추론합니다. 따라서 <code>R</code>은 <code>number</code>로 추론됩니다.</p>
</li>
<li>
<p><strong><code>U</code>의 추론:</strong> <code>add</code> 함수의 타입 시그니처를 보면, 첫 번째 인수(<code>x</code>)는 <code>T</code> (이미 <code>number</code>로 추론됨)이고, 나머지 인수(<code>y</code>)는 가변 인수(<code>...rest</code>)로 처리됩니다.  <code>bind</code> 함수는 <code>add</code> 함수의 나머지 인수(<code>y</code>)를 <code>U</code>로 처리합니다. <code>y</code>의 타입은 <code>number</code>이므로  <code>U</code>는 <code>[number]</code> (number 타입의 요소를 하나만 가지는 튜플)로 추론됩니다.  <code>U extends any[]</code> 제약 조건을 만족합니다.  만약 <code>add</code> 함수가 <code>(x: number, y: number, z: string) =&gt; number</code>였다면, <code>U</code>는 <code>[number, string]</code> (number와 string 타입의 요소를 각각 하나씩 가지는 튜플)로 추론되었을 것입니다.</p>
</li>
</ul>
<p>여기서 추가 설명이 필요한 부분은 <code>U extends any[]</code> 제약 조건인데요.</p>
<p><code>U extends any[]</code> 는 TypeScript의 제네릭 타입 제약 조건입니다.</p>
<p>이를 쉽게 설명하면,  &ldquo;<strong><code>U</code> 타입은 반드시 배열 타입이어야 한다</strong>&ldquo;는 의미입니다.</p>
<p><code>any[]</code> 는 모든 타입의 요소를 가질 수 있는 배열을 의미합니다.  <code>U extends any[]</code> 는 <code>U</code> 가 <code>any[]</code> 의 <em>부분 타입(subtype)</em> 이어야 함을 의미합니다.</p>
<p>부분 타입이란,  더 제한적인 타입을 의미합니다.  <code>any[]</code> 는 모든 배열 타입을 포함하는 가장 넓은 타입이므로,  <code>U</code> 는 <code>any[]</code> 보다 더 제한적인 배열 타입이어야 합니다.</p>
<p>예를 들어, 다음 타입들은 모두 <code>any[]</code> 의 부분 타입입니다.</p>
<ul>
<li><code>number[]</code>: 숫자만을 요소로 가지는 배열.</li>
<li><code>string[]</code>: 문자열만을 요소로 가지는 배열.</li>
<li><code>[number, string]</code>: 숫자 하나와 문자열 하나를 요소로 가지는 튜플 (튜플은 특수한 형태의 배열).</li>
<li><code>[number, string, boolean]</code>:  숫자, 문자열, 불리언을 요소로 가지는 튜플.</li>
</ul>
<p>반대로, 다음 타입들은 <code>any[]</code> 의 부분 타입이 <strong>아닙니다</strong>.</p>
<ul>
<li><code>number</code>: 단순한 숫자 타입.</li>
<li><code>string</code>: 단순한 문자열 타입.</li>
<li><code>MyCustomType</code>: 사용자 정의 타입.</li>
</ul>
<p>결론적으로 <code>...rest</code> 가 배열을 <em>생성</em>하고,  그 배열의 타입이 <code>U</code> 로 지정되고,  <code>U</code> 는 배열 타입이어야 한다는 제약 조건이 있는 것입니다.</p>
<ol start="3">
<li>
<p><strong>새로운 함수 생성:</strong></p>
<p><code>bind</code> 함수 내부에서 새로운 함수가 생성됩니다.  이 함수의 타입은 <code>((...args: U) =&gt; R)</code> 즉 <code>((...args: [number]) =&gt; number)</code> 입니다.  이는 숫자 하나를 인수로 받아 숫자를 반환하는 함수입니다.  이 함수의 몸체는 <code>(...args: U) =&gt; func(value, ...args)</code> 이므로, <code>(...args: [number]) =&gt; add(1, ...args)</code> 와 같습니다.</p>
</li>
<li>
<p><strong><code>add1</code> 변수에 할당:</strong></p>
<p>추론된 타입을 바탕으로 생성된 새로운 함수가 <code>add1</code> 변수에 할당됩니다.  <code>add1</code>의 타입은 <code>(arg: number) =&gt; number</code> 입니다.</p>
</li>
<li>
<p><strong><code>add1(5)</code> 호출:</strong></p>
<p><code>add1(5)</code>를 호출하면,  내부적으로 <code>add(1, 5)</code>가 실행되고,  결과값 6이 반환됩니다.  TypeScript는 이 호출이 타입 안전함을 검증합니다.  만약 <code>add1(&quot;hello&quot;)</code> 와 같이 문자열을 전달했다면, 타입 오류가 발생합니다.</p>
</li>
</ol>
<hr>
<h2 id="유니언-타입-합집합-타입">유니언 타입 (합집합 타입)</h2>
<p>지금까지 설명한 요소들 중 많은 부분은 타입이 있는 언어라면 일반적으로 존재하는 것들이라고 생각합니다.</p>
<p>그러나 여기서 소개할 유니언 타입을 가진 언어는 그리 많지 않을 것 같습니다.</p>
<p>TypeScript는 이 유니언 타입의 지원에 힘을 쏟고 있습니다.</p>
<p>유니언 타입은 값이 여러 타입 중 하나에 해당하는 타입을 나타냅니다.</p>
<p>표기로는 여러 타입을 <code>|</code>로 연결합니다.</p>
<p>예를 들어 <code>string | number</code>라는 타입은 &lsquo;string 또는 number인 값의 타입&rsquo;, 즉 &lsquo;문자열 또는 숫자 타입&rsquo;이 됩니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">value</span>: <span class="kt">string</span> <span class="o">|</span> <span class="kt">number</span> <span class="o">=</span> <span class="s1">&#39;foo&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">value</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">value</span> <span class="o">=</span> <span class="s1">&#39;bar&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 오류: Type &#39;true&#39; is not assignable to type &#39;string | number&#39;.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">value</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span></span></span></code></pre></div>
  </figure>
</div>
<p>이 예제에서는 변수 <code>value</code>가 <code>string | number</code> 타입의 변수이므로, 문자열이나 숫자를 할당할 수 있지만, 불리언 값은 할당할 수 없습니다.</p>
<p>물론, 프리미티브 타입뿐만 아니라 객체 타입에서도 유니언 타입을 만들 수 있습니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span>: <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">bar</span>: <span class="kt">number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Bar</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span>: <span class="kt">number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">baz</span>: <span class="kt">boolean</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">type</span> <span class="nx">FooBar</span> <span class="o">=</span> <span class="nx">Foo</span> <span class="o">|</span> <span class="nx">Bar</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span>: <span class="kt">FooBar</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;hello&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">bar</span>: <span class="kt">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div>
  </figure>
</div>
<p>여기서 <code>type</code> 문이 등장하는데요, 이는 TypeScript 고유의 문법으로, 새로운 타입을 정의하고 이름을 붙일 수 있는 문입니다.</p>
<p>이 예제에서는 <code>FooBar</code>라는 타입을 <code>Foo | Bar</code>로 정의하고 있습니다.</p>
<hr>
<h2 id="유니언-타입의-좁히기">유니언 타입의 좁히기</h2>
<p>TypeScript에서 유니온 타입은 여러 타입을 하나로 합쳐서 사용할 수 있게 해줍니다.</p>
<p>하지만 유니온 타입의 변수는 모든 가능한 타입의 공통된 속성만 접근할 수 있다는 단점이 있습니다.</p>
<p>이 문제를 해결하기 위해 &ldquo;타입 좁히기(Type Narrowing)&ldquo;라는 기법을 사용합니다.</p>
<p>타입 좁히기는 유니온 타입 변수가 실제로 어떤 타입인지 확인하여, 그에 맞는 속성에 접근할 수 있도록 타입을 좁히는 방법입니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span>: <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">bar</span>: <span class="kt">number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Bar</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span>: <span class="kt">number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">baz</span>: <span class="kt">boolean</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">type</span> <span class="nx">FooBar</span> <span class="o">=</span> <span class="nx">Foo</span> <span class="o">|</span> <span class="nx">Bar</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span>: <span class="kt">FooBar</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;hello&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">bar</span>: <span class="kt">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div>
  </figure>
</div>
<p>예를 들어, 위에서 정의한 <code>FooBar</code> 타입의 객체는 <code>bar</code> 프로퍼티를 참조할 수 없습니다.</p>
<p>왜냐하면 <code>FooBar</code> 타입의 값은 <code>Foo</code>일 수도 있고 <code>Bar</code>일 수도 있는데, <code>bar</code> 프로퍼티는 <code>Foo</code>에는 있지만 <code>Bar</code>에는 없기 때문입니다.</p>
<p>없을 가능성이 있는 프로퍼티를 참조할 수는 없습니다.</p>
<p>마찬가지로 <code>baz</code> 프로퍼티도 참조할 수 없습니다.</p>
<p>왜냐하면 bar는 Foo에만 있고, baz는 Bar에만 있기 때문입니다.</p>
<p>어떤 속성이 있는지 알 수 없으므로, 컴파일러는 오류를 발생시킵니다.</p>
<p><code>foo</code> 프로퍼티는 둘 다 가지고 있으므로 참조 가능합니다.</p>
<p>보통은 <code>Foo | Bar</code>와 같은 타입의 값이 주어질 경우, 먼저 그 값이 실제로 어느 것인지 실행 시에 판단해야 합니다.</p>
<p>그래서 TypeScript에서는 그러한 판단을 감지하여 적절하게 타입을 좁혀주는 기능이 있습니다.</p>
<p><strong><code>in</code> 연산자를 이용한 타입 좁히기 (주의 필요)</strong></p>
<p>과거에는 <code>in</code> 연산자를 사용하여 타입을 좁히는 방법이 있었지만, 최신 TypeScript 버전에서는 안전하지 않을 수 있으므로 권장되지 않습니다.</p>
<p><strong><code>typeof</code>를 사용한 좁히기</strong></p>
<p>더 단순하고 안전한 방법은 <code>typeof</code> 연산자를 사용하는 것입니다.</p>
<p><code>typeof</code> 연산자는 주어진 값의 타입을 문자열로 반환하는 연산자입니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">func</span><span class="p">(</span><span class="nx">value</span>: <span class="kt">string</span> <span class="o">|</span> <span class="kt">number</span><span class="p">)</span><span class="o">:</span> <span class="kt">number</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;string&#39;</span> <span class="o">===</span> <span class="k">typeof</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// value는 string 타입이므로 length 프로퍼티를 볼 수 있습니다.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nx">value</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// value는 number 타입입니다.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
  </figure>
</div>
<p>복잡한 객체가 관련되어 있지 않으므로, 이 방법은 안전합니다.</p>
<hr>
<h3 id="null-체크">null 체크</h3>
<p>또 하나 유니언 타입이 자주 사용되는 경우가 있습니다.</p>
<p>그것은 nullable한 값을 다루고자 할 때입니다. (JavaScript이므로 undefined도 있지만요.)</p>
<p>예를 들어, 문자열 값이 있을 수도 있고 null일 수도 있는 상황은 <code>string | null</code>이라는 타입으로 표현할 수 있습니다.</p>
<p><code>string | null</code> 타입의 값은 null일 수도 있으므로, 문자열로 취급하거나 프로퍼티를 참조할 수 없습니다.</p>
<p>이에 대해 null이 아니라면 처리하고 싶은 경우가 자주 있습니다.</p>
<p>JavaScript에서의 일반적인 방법은 <code>value != null</code>과 같이 if문으로 null 체크를 하는 방법인데, TypeScript는 이를 적절하게 해석하여 타입을 좁혀줍니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">func</span><span class="p">(</span><span class="nx">value</span>: <span class="kt">string</span> <span class="o">|</span> <span class="kc">null</span><span class="p">)</span><span class="o">:</span> <span class="kt">number</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">value</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// value는 null이 아니므로 string 타입으로 좁혀집니다.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nx">value</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
  </figure>
</div>
<p>또한, <code>&amp;&amp;</code>나 <code>||</code>의 단락 실행(short-circuit evaluation)을 이용한 테크닉도 JavaScript에서는 자주 사용되는데, 이것도 TypeScript는 적절하게 타입 검사를 해줍니다.</p>
<p>위의 함수 <code>func</code>는 다음과 같이도 쓸 수 있습니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">func</span><span class="p">(</span><span class="nx">value</span>: <span class="kt">string</span> <span class="o">|</span> <span class="kc">null</span><span class="p">)</span><span class="o">:</span> <span class="kt">number</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">value</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="nx">value</span><span class="p">.</span><span class="nx">length</span> <span class="o">||</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
  </figure>
</div>
<p>상기 코드의 구체적인 설명을 하자면,</p>
<ol>
<li>
<p><strong><code>value != null</code></strong>:</p>
<ul>
<li>이 부분은 <code>value</code>가 <code>null</code>이 아닌지 검사합니다. TypeScript는 이 표현식을 평가할 때, <code>value</code>의 타입을 좁힙니다. 즉, <code>value</code>가 <code>null</code>이 아니라면 <code>value</code>의 타입은 <code>string</code>으로 좁혀집니다.</li>
<li><code>value != null</code>은 <code>value !== null &amp;&amp; value !== undefined</code>와 동일한 의미입니다. TypeScript에서는 <code>null</code>과 <code>undefined</code> 모두를 검사할 때 이와 같은 표현을 사용합니다.</li>
</ul>
</li>
<li>
<p><strong><code>value.length</code></strong>:</p>
<ul>
<li><code>value != null</code>이 <code>true</code>일 경우, <code>value</code>는 <code>string</code> 타입으로 좁혀졌으므로 <code>value.length</code>를 호출할 수 있습니다. 이는 <code>string</code>의 길이를 반환합니다.</li>
</ul>
</li>
<li>
<p><strong><code>|| 0</code></strong>:</p>
<ul>
<li>이 부분은 단락 실행(short-circuit evaluation)을 사용합니다. <code>value != null</code>이 <code>false</code>일 경우, <code>value.length</code>는 실행되지 않고 바로 <code>0</code>이 반환됩니다.</li>
<li>즉, <code>value</code>가 <code>null</code>이거나 <code>undefined</code>인 경우, 함수는 <code>0</code>을 반환합니다.</li>
</ul>
</li>
</ol>
<hr>
<h3 id="discriminated-unions-차별화된-유니언">Discriminated Unions (차별화된 유니언)</h3>
<p>과거에는  리터럴 타입과 유니언 타입을 조합하여 이른바 대수적 데이터 타입(태그된 유니언)을 재현하는 방법이 권장되었지만, 최신 TypeScript에서는 <strong>Discriminated Unions (차별화된 유니언)</strong> 이라는 더 명확하고 안전한 방법을 사용합니다.</p>
<p>Discriminated Unions 은 유니언 타입의 각 구성 요소에 공통적인 <strong>리터럴 타입 프로퍼티</strong> (discriminated property) 를 추가하여 타입을 구분합니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Some</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">type</span><span class="o">:</span> <span class="s1">&#39;Some&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">value</span>: <span class="kt">T</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">None</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">type</span><span class="o">:</span> <span class="s1">&#39;None&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">type</span> <span class="nx">Option</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;</span> <span class="o">=</span> <span class="nx">Some</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;</span> <span class="o">|</span> <span class="nx">None</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">map</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">,</span> <span class="na">U</span><span class="p">&gt;(</span><span class="nx">obj</span>: <span class="kt">Option</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;,</span> <span class="nx">f</span><span class="o">:</span> <span class="p">(</span><span class="nx">obj</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">U</span><span class="p">)</span><span class="o">:</span> <span class="nx">Option</span><span class="p">&lt;</span><span class="nt">U</span><span class="p">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">switch</span> <span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="kr">type</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// discriminated property를 사용한 타입 좁히기
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">case</span> <span class="s1">&#39;Some&#39;</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kr">type</span><span class="o">:</span> <span class="s1">&#39;Some&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">value</span>: <span class="kt">f</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">value</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="s1">&#39;None&#39;</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kr">type</span><span class="o">:</span> <span class="s1">&#39;None&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
  </figure>
</div>
<p>이는 값이 있을 수도 있고 없을 수도 있음을 나타내는 이른바 option 타입을 TypeScript로 표현한 예입니다.</p>
<p><code>Option&lt;T&gt;</code> 타입은 값이 있는 경우의 객체 타입인 <code>Some&lt;T&gt;</code> 타입과 없는 경우의 타입인 <code>None</code> 타입의 유니언으로 표현되어 있습니다.</p>
<p>핵심은 이들에 공통되는 프로퍼티인 <code>type</code>입니다.</p>
<p><code>type</code> 프로퍼티는 <strong>discriminanted property</strong> 역할을 하며, 이 객체의 종류(<code>Some</code>인지 <code>None</code>인지)를 나타내는 <strong>리터럴 타입</strong> 문자열을 값으로 가집니다.</p>
<p>TypeScript 컴파일러는 <code>switch</code> 문에서 discriminated property <code>obj.type</code> 값을 검사하여, 각 case 문 내부에서 <code>obj</code>의 타입을 자동으로 좁혀줍니다.</p>
<p>Discriminated Unions는 타입 안전성을 보장하면서도 코드를 간결하게 유지할 수 있는 효과적인 방법입니다.</p>
<hr>
<h2 id="never-타입"><code>never</code> 타입</h2>
<p>유니언 타입을 다루기 시작하면 가끔 등장하는 것이 <code>never</code> 타입입니다. <code>never</code> 타입은 &ldquo;속하는 값이 존재하지 않는 타입&quot;이며, 부분 타입 관계의 맨 아래에 있는(임의의 타입의 부분 타입인) 타입입니다. 어떤 값도 <code>never</code> 타입의 변수에 넣을 수 없습니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="c1">// 오류: Type &#39;0&#39; is not assignable to type &#39;never&#39;.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">n</span>: <span class="kt">never</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></span></span></code></pre></div>
  </figure>
</div>
<p>한편, <code>never</code> 타입의 값은 어떤 타입에도 넣을 수 있습니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="c1">// never 타입의 값을 만드는 방법이 없으므로 declare로 선언만 합니다.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">declare</span> <span class="kr">const</span> <span class="nx">n</span>: <span class="kt">never</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">foo</span>: <span class="kt">string</span> <span class="o">=</span> <span class="nx">n</span><span class="p">;</span></span></span></code></pre></div>
  </figure>
</div>
<p>이렇게 들으면 <code>any</code> 타입처럼 위험한 타입이라고 생각할 수 있지만, 그렇지 않습니다.</p>
<p><code>never</code> 타입에 해당하는 값은 존재하지 않으므로, <code>never</code> 타입의 값을 실제로 만들 수 없습니다.</p>
<p>따라서 (TypeScript의 타입 시스템을 속이지 않는 한) <code>never</code> 타입의 값을 가지고 있다는 상황이 있을 수 없어서, <code>never</code> 타입의 값을 다른 타입의 변수에 넣는다는 것이 소스 코드 상에 있더라도 실제로는 일어날 수 없는 것입니다.</p>
<p>무슨 말을 하는지 모르는 사람도 있을 수 있지만, 타입 시스템을 생각할 때 이러한 타입은 꽤 자연스럽게 나타납니다.</p>
<p>우선 구체적인 예를 살펴보겠습니다. 이는 앞서의 <code>Option&lt;T&gt;</code> 예제를 조금 변경한 것입니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Some</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">type</span><span class="o">:</span> <span class="s1">&#39;Some&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">value</span>: <span class="kt">T</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">None</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">type</span><span class="o">:</span> <span class="s1">&#39;None&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">type</span> <span class="nx">Option</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;</span> <span class="o">=</span> <span class="nx">Some</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;</span> <span class="o">|</span> <span class="nx">None</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">map</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">,</span> <span class="na">U</span><span class="p">&gt;(</span><span class="nx">obj</span>: <span class="kt">Option</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;,</span> <span class="nx">f</span><span class="o">:</span> <span class="p">(</span><span class="nx">obj</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">U</span><span class="p">)</span><span class="o">:</span> <span class="nx">Option</span><span class="p">&lt;</span><span class="nt">U</span><span class="p">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">switch</span> <span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="kr">type</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="s1">&#39;Some&#39;</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kr">type</span><span class="o">:</span> <span class="s1">&#39;Some&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">value</span>: <span class="kt">f</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">value</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="s1">&#39;None&#39;</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kr">type</span><span class="o">:</span> <span class="s1">&#39;None&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="k">default</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 여기서 obj는 never 타입이 됩니다.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="kr">const</span> <span class="nx">unreachable</span>: <span class="kt">never</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">&#34;unreachable&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
  </figure>
</div>
<p><code>switch</code> 문에 <code>default</code> 케이스가 추가되었습니다.</p>
<p>사실 이 안에서 <code>obj</code>의 타입은 <code>never</code>가 됩니다.</p>
<p>왜냐하면, 이전 <code>case</code> 문들에 의해 <code>obj</code>의 가능성이 모두 조사되었기 때문입니다.</p>
<p>이것이 의미하는 바는, 실제로는 <code>default</code> 절이 실행될 가능성이 없으며, 이 안에서는 <code>obj</code>의 값의 후보가 전혀 없다는 것입니다.</p>
<p>그런 상황을 <code>obj</code>에 <code>never</code> 타입을 부여함으로써 표현하고 있습니다.</p>
<p>또 하나 <code>never</code> 타입이 나올 가능성이 있는 곳은 함수의 반환값입니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">func</span><span class="p">()</span><span class="o">:</span> <span class="kt">never</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;Hi&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">result</span>: <span class="kt">never</span> <span class="o">=</span> <span class="nx">func</span><span class="p">();</span></span></span></code></pre></div>
  </figure>
</div>
<p>함수의 반환 타입이 <code>never</code> 타입이 되는 것은 함수가 값을 반환할 가능성이 없을 때입니다.</p>
<p>이는 반환값이 없음을 나타내는 <code>void</code> 타입과는 달리, 애초에 함수가 정상적으로 종료되어 값을 반환하는 일이 있을 수 없다는 것을 나타냅니다.</p>
<p>위의 예제에서 함수 <code>func</code>는 반드시 <code>throw</code> 합니다.</p>
<p>즉, 함수의 실행이 중단되고 값을 반환하지 않고 함수를 빠져나갑니다.</p>
<p>특히, 위의 예제에서 <code>func</code>의 반환값을 변수 <code>result</code>에 할당하고 있지만, 실제로는 <code>result</code>에 무언가가 할당될 가능성은 없습니다.</p>
<p>따라서 <code>result</code>에는 <code>never</code> 타입을 붙일 수 있는 것입니다.</p>
<p>참고로, 위의 예제에서 <code>func</code>의 반환값에 타입 주석으로 <code>never</code>라고 적었는데, 이를 생략하면 반환 타입은 <code>void</code>로 추론됩니다.</p>
<p>이는 값을 반환하지 않는다는 것을 명시하고 싶을 때는 <code>never</code>로 타입 주석을 명시해야 합니다.</p>
<p>만약 반환 타입을 <code>never</code>로 하는 것이 불가능(어떤 값이 반환될 가능성을 부정할 수 없음)한 경우에는 제대로 타입 에러가 발생하니 안심하시면 됩니다.</p>
<hr>
<h2 id="교차-타입-intersection-타입">교차 타입 (intersection 타입)</h2>
<p>유니언 타입과 어떤 의미에서 대응되는 것으로 교차 타입(intersection 타입)이 있는데요.</p>
<p>두 개의 타입 <code>T</code>, <code>U</code>에 대해 <code>T &amp; U</code>라고 쓰면, <code>T</code>이면서 <code>U</code>인 타입을 나타냅니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span>: <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">bar</span>: <span class="kt">number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Bar</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span>: <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">baz</span>: <span class="kt">boolean</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span>: <span class="kt">Foo</span> <span class="o">&amp;</span> <span class="nx">Bar</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;foooooooo&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">bar</span>: <span class="kt">3</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">baz</span>: <span class="kt">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div>
  </figure>
</div>
<p>예를 들어 이 예제에서 <code>Foo &amp; Bar</code>라는 것은 <code>Foo</code>이면서 <code>Bar</code>인 타입을 나타내는데요.</p>
<p>따라서 이 타입의 값은 <code>string</code> 타입의 프로퍼티 <code>foo</code>와 <code>number</code> 타입의 프로퍼티 <code>bar</code>, 그리고 <code>boolean</code> 타입의 프로퍼티 <code>baz</code>를 가져야 합니다.</p>
<p>참고로, 유니언 타입과 교차 타입을 조합하면 재미있습니다.</p>
<p>다음 예제를 보세요.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">type</span><span class="o">:</span> <span class="s1">&#39;Foo&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span>: <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Bar</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">type</span><span class="o">:</span> <span class="s1">&#39;Bar&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">bar</span>: <span class="kt">number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Fuga</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">baz</span>: <span class="kt">boolean</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">type</span> <span class="nx">Obj</span> <span class="o">=</span> <span class="p">(</span><span class="nx">Foo</span> <span class="o">|</span> <span class="nx">Bar</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nx">Fuga</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">func</span><span class="p">(</span><span class="nx">obj</span>: <span class="kt">Obj</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// obj는 Fuga이므로 baz를 참조 가능
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">baz</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="kr">type</span> <span class="o">===</span> <span class="s1">&#39;Foo&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 여기서는 obj가 Foo &amp; Fuga
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 여기서는 obj가 Bar &amp; Fuga
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">bar</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
  </figure>
</div>
<p><code>Obj</code> 타입은 <code>(Foo | Bar) &amp; Fuga</code>인데, 사실 이는 <code>(Foo &amp; Fuga) | (Bar &amp; Fuga)</code>와 동일하게 볼 수 있습니다. 따라서 유니언 타입일 때와 마찬가지로 <code>if</code> 문으로 타입을 좁힐 수 있는 거죠.</p>
<h3 id="유니언-타입을-가진-함수와의-관계">유니언 타입을 가진 함수와의 관계</h3>
<p>잠깐만 교차 타입에서 유니언 타입으로 다시 돌아와볼게요. 아까는 생략했지만, 함수 타입을 포함하는 유니언 타입도 생각할 수 있습니다. 당연히 함수와 그 외의 유니언 타입을 만들었을 때는 이를 함수로 호출할 수 없습니다. 아래 예제에서는 <code>Func | MyObj</code> 타입의 값 <code>obj</code>가 <code>MyObj</code> 타입일 가능성이 있으므로, <code>obj(123)</code>처럼 함수로 사용할 수 없습니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">type</span> <span class="nx">Func</span> <span class="o">=</span> <span class="p">(</span><span class="nx">arg</span>: <span class="kt">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">MyObj</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">prop</span>: <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span>: <span class="kt">Func</span> <span class="o">|</span> <span class="nx">MyObj</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">prop</span><span class="o">:</span> <span class="s1">&#39;&#39;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 오류: 호출 시그니처가 없는 타입의 표현식을 호출할 수 없습니다.
</span></span></span><span class="line"><span class="cl"><span class="c1">//       Type &#39;MyObj&#39; has no compatible call signatures.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">obj</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span></span></span></code></pre></div>
  </figure>
</div>
<p>그렇다면 유니언 타입의 구성 요소가 모두 함수라면 호출할 수 있을 것 같은데요. 다음 예제를 볼까요?</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">type</span> <span class="nx">StrFunc</span> <span class="o">=</span> <span class="p">(</span><span class="nx">arg</span>: <span class="kt">string</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">type</span> <span class="nx">NumFunc</span> <span class="o">=</span> <span class="p">(</span><span class="nx">arg</span>: <span class="kt">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">declare</span> <span class="kr">const</span> <span class="nx">obj</span>: <span class="kt">StrFunc</span> <span class="o">|</span> <span class="nx">NumFunc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 오류: Argument of type &#39;123&#39; is not assignable to parameter of type &#39;string &amp; number&#39;.
</span></span></span><span class="line"><span class="cl"><span class="c1">//       Type &#39;123&#39; is not assignable to type &#39;string&#39;.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">obj</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span></span></span></code></pre></div>
  </figure>
</div>
<p>이 예제에서는 <code>StrFunc | NumFunc</code> 타입의 변수 <code>obj</code>를 만들었는데요.</p>
<p><code>StrFunc</code> 타입은 문자열을 받아 문자열을 반환하는 함수 타입이고, <code>NumFunc</code> 타입은 숫자를 받아 문자열을 반환하는 함수 타입입니다.</p>
<p>하지만 <code>obj</code>를 호출하는 부분에서 여전히 에러가 발생합니다.</p>
<p>에러 메시지에서 짐작하셨겠지만, 이 <code>StrFunc | NumFunc</code> 타입의 함수를 호출하는 것은 실질적으로 불가능한데요.</p>
<p>왜냐하면 <code>obj</code>는 <code>StrFunc</code> 타입일 수도 있어서 인수가 문자열이어야 하고, 한편 <code>NumFunc</code> 타입일 수도 있어서 인수가 숫자여야 하기 때문입니다.</p>
<p>즉, 인수가 문자열이면서 동시에 숫자여야 하는데, 이는 불가능하죠.</p>
<p>에러 메시지에 나오는 <code>string &amp; number</code>라는 타입은 이를 나타냅니다.</p>
<p>문자열이면서 동시에 숫자인 값(즉, <code>string &amp; number</code> 타입의 값)은 존재하지 않으므로, 이 함수를 호출할 수 없는 겁니다.</p>
<p>이처럼 함수들끼리 유니언을 만들 때, 결과 함수의 인수는 원래의 인수들끼리 교차 타입이 될 필요가 있습니다.</p>
<p>왜 그럴까에 대해 궁금한 분은 함수의 인수 위치가 타입 계층에서 반공변임을 생각해 보세요.</p>
<p>어려운 말로 하면, 이는 함수의 인수 타입이 반공변(contravariant) 위치에 있기 때문입니다.</p>
<p>인수의 타입이 교차 타입으로 표현된다는 점에서, 교차 타입을 써도 의미가 있는 예를 보겠습니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span>: <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">bar</span>: <span class="kt">number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Bar</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span>: <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">baz</span>: <span class="kt">boolean</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">type</span> <span class="nx">FooFunc</span> <span class="o">=</span> <span class="p">(</span><span class="nx">arg</span>: <span class="kt">Foo</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">type</span> <span class="nx">BarFunc</span> <span class="o">=</span> <span class="p">(</span><span class="nx">arg</span>: <span class="kt">Bar</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kr">boolean</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">declare</span> <span class="kr">const</span> <span class="nx">func</span>: <span class="kt">FooFunc</span> <span class="o">|</span> <span class="nx">BarFunc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// res는 number | boolean 타입
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="nx">func</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">bar</span>: <span class="kt">123</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">baz</span>: <span class="kt">false</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span></span></span></code></pre></div>
  </figure>
</div>
<p>이 예제에서 <code>func</code>는 <code>FooFunc | BarFunc</code> 타입인데요. <code>FooFunc</code>의 인수는 <code>Foo</code>이고, <code>BarFunc</code>의 인수는 <code>Bar</code>이므로, <code>func</code>의 인수 타입은 <code>Foo &amp; Bar</code> 타입이어야 합니다.</p>
<p>따라서 <code>Foo &amp; Bar</code> 타입을 가진 객체를 만들어 <code>func</code>를 호출할 수 있습니다.</p>
<p>이 예제에서 <code>res</code>의 타입은 <code>number | boolean</code> 타입이 되는데요.</p>
<p>이는 <code>func</code>의 타입이 <code>FooFunc</code>인 경우 반환값이 <code>number</code>이고, <code>BarFunc</code>인 경우 반환값이 <code>boolean</code>이기 때문입니다.</p>
<p>이처럼 함수들끼리의 유니언 타입을 가진 함수를 호출하고 싶을 때 교차 타입의 지식이 유용합니다.</p>
<p>특히, 앞서 본 것처럼 에러 메시지에 교차 타입이 나타나므로, 교차 타입에 대해서도 알아두는 게 좋을 거예요. (그런 기회가 얼마나 있을지는 묻지 마세요.)</p>
<p>참고로, 이 부분의 처리는 다루기 어렵기 때문인지 현재로서는 제한이 있습니다. 구체적으로는 함수 오버로드가 있는 경우나 제네릭이 관련된 경우에 함수를 호출할 수 없거나, 인수 타입을 추론할 수 없는 경우가 있습니다. 일단 예제만 보여드리지만, 곤란을 겪을 일은 그다지 없을 거예요.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">arr</span>: <span class="kt">string</span><span class="p">[]</span> <span class="o">|</span> <span class="kt">number</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[];</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 오류: Parameter &#39;x&#39; implicitly has an &#39;any&#39; type.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">arr</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 오류: 호출 시그니처가 없는 타입의 표현식을 호출할 수 없습니다.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">arr2</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">);</span></span></span></code></pre></div>
  </figure>
</div>
<h2 id="객체-타입-재방문">객체 타입 재방문</h2>
<p>자, 유니언 타입을 소개했으니, 객체 타입에 좀 더 깊이 들어가 설명할 수 있는데요. 객체 타입은 <code>프로퍼티명: 타입;</code>이라는 정의의 모음이었지만, 사실 프로퍼티에 대해 수식어를 붙일 수 있습니다. 수식어에는 <code>?</code>와 <code>readonly</code> 두 가지가 있습니다.</p>
<h3 id="-선택적-프로퍼티"><code>?</code>: 선택적 프로퍼티</h3>
<p><code>?</code>를 붙여 선언한 프로퍼티는 선택적으로 사용할 수 있습니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">MyObj</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span>: <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">bar?</span>: <span class="kt">number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">obj</span>: <span class="kt">MyObj</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;string&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">bar</span>: <span class="kt">100</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div>
  </figure>
</div>
<p>이 예제에서 <code>bar</code>는 선택적 프로퍼티인데요. <code>bar</code>는 선택 사항이므로, <code>foo</code>만 가진 객체와 <code>foo</code>와 <code>bar</code> 둘 다 가진 객체 모두 <code>MyObj</code> 타입의 값으로 인정됩니다.</p>
<h3 id="선택적-프로퍼티에-대한-접근">선택적 프로퍼티에 대한 접근</h3>
<p>그런데 실제 JavaScript에서는 존재하지 않는 프로퍼티에 접근하면 <code>undefined</code>가 반환됩니다.</p>
<p>그렇다면 <code>MyObj</code> 타입의 값에 대해 <code>bar</code> 프로퍼티를 얻으려고 하면 <code>undefined</code>일 가능성이 있다는 건데요.</p>
<p>이를 반영해서 <code>MyObj</code>의 <code>bar</code> 프로퍼티에 접근했을 때 얻는 타입은 <code>number | undefined</code>가 됩니다.</p>
<p>이렇게 <code>?</code> 수식어가 붙은 프로퍼티를 얻을 때는 자동으로 <code>undefined</code> 타입과의 유니언 타입이 됩니다.</p>
<p>따라서 이를 사용하는 쪽에서는 이렇게 <code>undefined</code> 체크를 해야 합니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">func</span><span class="p">(</span><span class="nx">obj</span>: <span class="kt">MyObj</span><span class="p">)</span><span class="o">:</span> <span class="kt">number</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">bar</span> <span class="o">!==</span> <span class="kc">undefined</span> <span class="o">?</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">bar</span> <span class="o">*</span> <span class="nx">100</span> : <span class="kt">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
  </figure>
</div>
<p>참고로, <code>?</code>를 쓰지 않고 직접 <code>bar</code>의 타입을 <code>number | undefined</code>로 해도 같은 의미가 되지 않습니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">MyObj</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span>: <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">bar</span>: <span class="kt">number</span> <span class="o">|</span> <span class="kc">undefined</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 오류:
</span></span></span><span class="line"><span class="cl"><span class="c1">// Type &#39;{ foo: string; }&#39; is not assignable to type &#39;MyObj&#39;.
</span></span></span><span class="line"><span class="cl"><span class="c1">//   Property &#39;bar&#39; is missing in type &#39;{ foo: string; }&#39;.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">obj</span>: <span class="kt">MyObj</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;string&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div>
  </figure>
</div>
<p><code>?</code> 수식어를 사용하지 않는 경우, 비록 <code>undefined</code>가 허용된 프로퍼티라도 꼭 선언해야 합니다.</p>
<p>대부분의 경우 <code>bar?: number;</code>보다 <code>bar: number | undefined;</code>를 우선적으로 사용하는 것을 추천합니다.</p>
<p>전자는 <code>bar</code>가 없을 때 정말 없는 것인지, 작성자가 빼먹은 건지 구별할 수 없어 실수의 원인이 됩니다. 후자의 경우는 빼먹는 것을 방지할 수 있습니다.</p>
<p>정말로 &ldquo;없어도 괜찮은&rdquo; 상황은 함수에 옵션 객체를 전달할 때 정도인데요.</p>
<p>아래 소개하는 기사에서도 &ldquo;그 외의 객체가 장기간 생존하는 경우에는 애초에 선택적 프로퍼티 자체를 피하자&quot;고 합니다.</p>
<p>필자도 이에 동의하며, &ldquo;편의성&quot;보다 &ldquo;안전성&quot;을 택하고자 하는 많은 상황에서 선택적 프로퍼티보다 <code>undefined</code> 등의 유니언 타입으로 하는 것이 현명합니다.</p>
<blockquote>
<p><a href="https://spicy-jelly.com/articles/958">exactOptionalPropertyTypes 에 관하여 - Object.create(null)</a></p></blockquote>
<h3 id="exactoptionalpropertytypes에-대하여"><code>exactOptionalPropertyTypes</code>에 대하여</h3>
<p>선택적 프로퍼티의 동작은 <code>exactOptionalPropertyTypes</code> 컴파일러 옵션이 유효한지 여부에 따라 달라집니다.</p>
<p>기본적으로 이 옵션은 비활성화되어 있고, 비교적 최근(TypeScript 4.4)에 추가된 옵션이라서 비활성화된 프로젝트가 많을 거예요.</p>
<p>이 옵션이 비활성화된 경우 <code>bar?: number;</code>라는 것은 <code>bar?: number | undefined;</code>라고 쓴 것과 같은 의미가 됩니다.</p>
<p>즉, 선택적 프로퍼티에 명시적으로 <code>undefined</code>를 넣을 수 있습니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="c1">// exactOptionalPropertyTypes가 비활성화된 경우
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">interface</span> <span class="nx">MyObj</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span>: <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">bar?</span>: <span class="kt">number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 모두 OK
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">obj1</span>: <span class="kt">MyObj</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;pichu&#39;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj2</span>: <span class="kt">MyObj</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;pikachu&#39;</span><span class="p">,</span> <span class="nx">bar</span>: <span class="kt">25</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj3</span>: <span class="kt">MyObj</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;raichu&#39;</span><span class="p">,</span> <span class="nx">bar</span>: <span class="kt">undefined</span> <span class="p">};</span></span></span></code></pre></div>
  </figure>
</div>
<p>한편, <code>exactOptionalPropertyTypes</code>가 활성화된 경우 선택적 프로퍼티에 <code>undefined</code>를 넣을 수 없게 됩니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="c1">// exactOptionalPropertyTypes가 활성화된 경우
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">interface</span> <span class="nx">MyObj</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span>: <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">bar?</span>: <span class="kt">number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj1</span>: <span class="kt">MyObj</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;pichu&#39;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj2</span>: <span class="kt">MyObj</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;pikachu&#39;</span><span class="p">,</span> <span class="nx">bar</span>: <span class="kt">25</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 오류: Type &#39;undefined&#39; is not assignable to type &#39;number&#39;.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">obj3</span>: <span class="kt">MyObj</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;raichu&#39;</span><span class="p">,</span> <span class="nx">bar</span>: <span class="kt">undefined</span> <span class="p">};</span></span></span></code></pre></div>
  </figure>
</div>
<p>지금까지 <code>bar?: number;</code>라고 쓰면 자동으로 <code>bar: undefined</code>가 가능해지는 것은 별로 직관적인 동작이 아니었는데요.</p>
<p><code>exactOptionalPropertyTypes</code>를 활성화하여 이를 개선할 수 있습니다.</p>
<p>또한, 이 옵션이 활성화된 상태에서는 <code>bar?: number;</code>로 선언된 프로퍼티에 대해 &ldquo;number 타입의 값이 들어있다&rdquo; 또는 &ldquo;프로퍼티가 존재하지 않는다&rdquo; 중 하나가 됩니다.</p>
<p>따라서 <code>in</code> 연산자(프로퍼티가 존재하는지 판정하는 연산자)를 사용하여 타입을 좁힐 수 있게 됩니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="c1">// exactOptionalPropertyTypes가 활성화된 상태에서
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">interface</span> <span class="nx">MyObj</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span>: <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">bar?</span>: <span class="kt">number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">func</span><span class="p">(</span><span class="nx">obj</span>: <span class="kt">MyObj</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;bar&#39;</span> <span class="k">in</span> <span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 여기서 obj.bar는 number 타입
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">bar</span><span class="p">.</span><span class="nx">toFixed</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
  </figure>
</div>
<p>다만, 다른 라이브러리에서 제공된 타입 정의에 선택적 프로퍼티가 있는 경우에는 주의가 필요합니다.</p>
<p>왜냐하면, 그쪽 라이브러리는 <code>exactOptionalPropertyTypes</code>가 비활성화된 상태에서 만들어졌을 수 있고, 그렇다면 이쪽 설정에서는 활성화되어 있어도 &ldquo;undefined 타입의 값이 들어 있다&quot;는 상태가 될 가능성이 있기 때문입니다.</p>
<h3 id="readonly"><code>readonly</code></h3>
<p>프로퍼티에 대해 또 다른 수식어로 <code>readonly</code>가 있습니다.</p>
<p>이를 붙여 선언된 프로퍼티는 재할당할 수 없게 됩니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">MyObj</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">readonly</span> <span class="nx">foo</span>: <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span>: <span class="kt">MyObj</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;Hey!&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 오류: Cannot assign to &#39;foo&#39; because it is a constant or a read-only property.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="s1">&#39;Hi&#39;</span><span class="p">;</span></span></span></code></pre></div>
  </figure>
</div>
<p>한마디로, <code>const</code>의 프로퍼티 버전이라고 생각하면 되는데요.</p>
<p>순수 JavaScript에서는 프로퍼티의 <code>writable</code> 속성에 해당하지만, 프로퍼티의 속성을 타입 시스템에 포함시키는 것은 무리가 있기 때문에 TypeScript에서는 이런 독자적인 방법을 취한 것 같습니다.</p>
<p>하지만 <code>readonly</code>를 과신해서는 안 됩니다.</p>
<p>다음 예시에서 보듯이, <code>readonly</code>가 아닌 타입을 통해 변경이 가능하기 때문입니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">MyObj</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">readonly</span> <span class="nx">foo</span>: <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">MyObj2</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span>: <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span>: <span class="kt">MyObj</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;Hey!&#39;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj2</span>: <span class="kt">MyObj2</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">obj2</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="s1">&#39;Hi&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">);</span> <span class="c1">// &#39;Hi&#39;
</span></span></span></code></pre></div>
  </figure>
</div>
<h3 id="인덱스-시그니처">인덱스 시그니처</h3>
<p>객체 타입에는 사실 지금까지 소개한 것 외에도 표기법이 있습니다.</p>
<p>그중 하나가 인덱스 시그니처입니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">MyObj</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="nx">key</span>: <span class="kt">string</span><span class="p">]</span><span class="o">:</span> <span class="kt">number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">obj</span>: <span class="kt">MyObj</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">num</span>: <span class="kt">number</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">num2</span>: <span class="kt">number</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">bar</span><span class="p">;</span></span></span></code></pre></div>
  </figure>
</div>
<p><code>[key: string]: number;</code> 부분이 새로운데요.</p>
<p>이렇게 쓰면 <code>string</code> 타입인 임의의 프로퍼티명에 대해 <code>number</code> 타입을 갖는다는 의미가 됩니다.</p>
<p><code>obj</code>에 그런 타입을 부여했으니 <code>obj.foo</code>나 <code>obj.bar</code> 등은 모두 <code>number</code> 타입을 갖고 있습니다.</p>
<p>이것은 편리하지만 분명히 위험한데요.</p>
<p><code>obj</code>는 실제로 <code>{}</code>이므로 <code>obj.foo</code> 등은 <code>undefined</code>가 될 텐데, 그 가능성이 무시되고 있습니다.</p>
<p>그렇게 위험한 타입이 버젓이 허용되는 이유는 객체를 사전처럼 사용하는 경우에 필요하다든가, 배열 타입의 정의에도 필요하다든가 그런 곳일 겁니다.</p>
<p>실제로 배열 타입의 정의는 대체로 아래와 같습니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nb">Array</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="nx">idx</span>: <span class="kt">number</span><span class="p">]</span><span class="o">:</span> <span class="nx">T</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">length</span>: <span class="kt">number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 메서드 정의가 이어짐
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div>
  </figure>
</div>
<p>참고로, 이 예제처럼 인덱스 시그니처 외에 프로퍼티가 있을 경우, 그쪽이 우선됩니다.</p>
<p>일반적으로 인덱스 시그니처의 사용은 최대한 피하는 것이 좋습니다.</p>
<p>객체를 사전처럼 사용하는 경우 대신 <code>Map</code>을 사용하세요.</p>
<p>배열의 경우는 인덱스를 통한 접근을 피하고 <code>for-of</code> 문을 사용하는 등의 방법으로 피할 수 있습니다.</p>
<h3 id="함수-시그니처">함수 시그니처</h3>
<p>사실, 객체 타입의 표기로 함수 타입을 표현하는 방법이 있습니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Func</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nx">arg</span>: <span class="kt">number</span><span class="p">)</span><span class="o">:</span> <span class="k">void</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">f</span>: <span class="kt">Func</span> <span class="o">=</span> <span class="p">(</span><span class="nx">arg</span>: <span class="kt">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arg</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div>
  </figure>
</div>
<p><code>(arg: number): void;</code> 부분에서, 이 객체는 <code>number</code> 타입의 인수를 하나 받는 함수임을 나타냅니다.</p>
<p>이 표기는 일반적인 프로퍼티 선언과 동시에 사용할 수 있어서, 함수면서 동시에 특정 프로퍼티를 가진 객체를 나타낼 수 있습니다.</p>
<p>더 나아가, 여러 개의 함수 시그니처를 쓸 수 있어 오버로딩을 표현할 수 있습니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Func</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">foo</span>: <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nx">arg</span>: <span class="kt">number</span><span class="p">)</span><span class="o">:</span> <span class="k">void</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nx">arg</span>: <span class="kt">string</span><span class="p">)</span><span class="o">:</span> <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
  </figure>
</div>
<p>이 타입이 나타내는 값은 <code>string</code> 타입의 <code>foo</code> 프로퍼티를 가진 객체이며, <code>number</code> 타입의 인수를 받아 함수로 호출할 수 있고 그 경우 아무것도 반환하지 않으며, <code>string</code> 타입의 인수로 호출할 수도 있고 그 경우 <code>string</code> 타입의 값을 반환하는 함수입니다.</p>
<h3 id="new-시그니처">new 시그니처</h3>
<p>유사한 것으로, 생성자를 나타내는 시그니처도 있습니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Ctor</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">new</span> <span class="p">()</span><span class="o">:</span> <span class="nx">T</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">public</span> <span class="nx">bar</span>: <span class="kt">number</span> <span class="o">|</span> <span class="kc">undefined</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">f</span>: <span class="kt">Ctor</span><span class="p">&lt;</span><span class="nt">Foo</span><span class="p">&gt;</span> <span class="o">=</span> <span class="nx">Foo</span><span class="p">;</span></span></span></code></pre></div>
  </figure>
</div>
<p>여기서 만든 <code>Ctor&lt;T&gt;</code> 타입은 인수가 없을 때 <code>new</code> 하면 <code>T</code> 타입의 값이 반환되는 함수를 나타냅니다.</p>
<p>여기서 정의한 클래스 <code>Foo</code>는 <code>new</code> 하면 <code>Foo</code>의 인스턴스(즉, <code>Foo</code> 타입의 값)가 반환되므로 <code>Ctor&lt;Foo&gt;</code>에 할당 가능합니다.</p>
<p>참고로, 함수의 타입을 <code>(foo: string) =&gt; number</code>처럼 쓸 수 있었던 것처럼, <code>new</code> 시그니처만 있는 경우 생성자의 타입을 <code>new () =&gt; Foo</code>처럼 쓸 수도 있습니다.</p>
<hr>
<h2 id="as를-이용한-다운캐스팅"><code>as</code>를 이용한 다운캐스팅</h2>
<p>여기서 타입과 관련된 이야기로 <code>as</code>를 이용한 다운캐스팅을 소개할게요.</p>
<p>이는 TypeScript 고유의 문법으로, <code>식 as 타입</code>으로 씁니다.</p>
<p>다운캐스팅이니 당연히 타입 안전하지 않지만, TypeScript를 작성하다 보면 가끔 필요할 때가 있습니다.</p>
<p>참고로, 다운캐스팅은 파생 타입의 값을 부분 타입으로 취급하기 위한 것입니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">value</span> <span class="o">=</span> <span class="nx">rand</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">num</span> <span class="o">=</span> <span class="nx">value</span> <span class="kr">as</span> <span class="kt">number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">num</span> <span class="o">*</span> <span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">rand</span><span class="p">()</span><span class="o">:</span> <span class="kt">string</span> <span class="o">|</span> <span class="kt">number</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="s1">&#39;hello&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">123</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
  </figure>
</div>
<p>이 예제에서 <code>value</code>는 <code>string | number</code> 타입의 값인데요, <code>value as number</code> 구문을 통해 <code>number</code> 타입으로 취급하고 있습니다.</p>
<p>따라서 변수 <code>num</code>은 <code>number</code> 타입이 됩니다.</p>
<p>이것은 안전하지 않은데요. 왜냐하면 <code>value</code>는 실제로 <code>string</code> 타입, 즉 문자열일 수도 있어서, 변수 <code>num</code>에 문자열이 들어갈 가능성이 있기 때문입니다.</p>
<p>참고로, <code>as</code>를 써도 전혀 관계없는 두 값의 변환은 할 수 없습니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">value</span> <span class="o">=</span> <span class="s1">&#39;foo&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 오류: Type &#39;string&#39; cannot be converted to type &#39;number&#39;.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">num</span> <span class="o">=</span> <span class="nx">value</span> <span class="kr">as</span> <span class="kt">number</span><span class="p">;</span></span></span></code></pre></div>
  </figure>
</div>
<p>이 경우, <code>any</code> 타입이나 뒤에서 설명할 <code>unknown</code> 타입을 거치면 변환이 가능합니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">value</span> <span class="o">=</span> <span class="s1">&#39;foo&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">num</span> <span class="o">=</span> <span class="nx">value</span> <span class="kr">as</span> <span class="kt">unknown</span> <span class="kr">as</span> <span class="kt">number</span><span class="p">;</span></span></span></code></pre></div>
  </figure>
</div>
<p>덧붙여, 이 예제에서 보이듯이, <code>as</code>는 업캐스팅도 가능합니다.</p>
<p>첫 번째 <code>as unknown</code>에서 이루어지는 것은 다운캐스팅이 아니라 업캐스팅이며, 그 후 <code>as number</code>로 다운캐스팅하고 있습니다.</p>
<p>다른 업캐스팅 예로는 <code>const foo: string = 'foo';</code> 대신 <code>const foo = 'foo' as string;</code>처럼 쓰는 경우를 들 수 있습니다( <code>'foo'</code> 타입을 <code>string</code> 타입으로 업캐스팅).</p>
<p>업캐스팅 자체는 <code>as</code>를 쓰지 않아도 가능한 안전한 작업입니다.</p>
<p>업캐스팅에 <code>as</code>를 사용하는 것은 위험한 다운캐스팅과 구별이 가지 않으므로 피하는 것이 좋습니다.</p>
<hr>
<p>3편에서 계속 이어서 뵙겠습니다.</p>
<p>그럼.</p>
<hr>

      <div class="tag-list-single">
        <a class="btn btn-light" href="/tags/typescript/" role="button">TypeScript</a>
        <a class="btn btn-light" href="/tags/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/" role="button">타입스크립트</a>
        <a class="btn btn-light" href="/tags/%EC%A0%9C%EB%84%A4%EB%A6%AD/" role="button">제네릭</a>
        <a class="btn btn-light" href="/tags/%ED%8A%9C%ED%94%8C/" role="button">튜플</a>
        <a class="btn btn-light" href="/tags/%EC%9C%A0%EB%8B%88%EC%98%A8-%ED%83%80%EC%9E%85/" role="button">유니온 타입</a>
        <a class="btn btn-light" href="/tags/%ED%83%80%EC%9E%85-%EC%A2%81%ED%9E%88%EA%B8%B0/" role="button">타입 좁히기</a>
        </div>
      
      <ins class="adsbygoogle"
          style="display:block"
          data-ad-format="autorelaxed"
          data-ad-client="ca-pub-7748316956330968"
          data-ad-slot="4495825428"></ins>
      <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
      </script>
    </div>
  </div>
</article>

      
      </div>
    </div>
    
    
<div class="bg-light">
    <section class="section section-related container">
      <div class="row justify-content-center">
        <div class="col-md-12 col-lg-12">
          <h2 class="section-title text-center">Related posts</h2>
        </div>
      </div>
      <div class="row justify-content-center">
        <div class="col-lg-12">
          <div class="card">
              <div class="card-body">
                <article>
                  <h2 class="h3"><a class="stretched-link text-body" href="/blog/2024-10-21-typescript-type-master-third/">TypeScript 타입 기초 완전 정복! 3편 - as const, unknown, Mapped, Conditional 타입 완벽 분석</a></h2>
                  <p>TypeScript 타입 시스템의 최고봉을 향해! `as const`, `unknown`, `keyof`, Lookup, Mapped, Conditional 타입 등 고급 타입 개념을 파헤쳐 봅니다.</p>
                  <p>
  <small>October 21, 2024<span class="stretched-link position-relative reading-time text-nowrap" title="Estimated reading time"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
        <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
        <path d="M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0"></path>
        <path d="M12 7v5l3 3"></path>
      </svg>19&nbsp;minutes</span></small>
</p>
</article>
              </div>
            </div>
          <div class="card">
              <div class="card-body">
                <article>
                  <h2 class="h3"><a class="stretched-link text-body" href="/blog/2024-10-21-typescript-type-basics-first/">TypeScript 타입 기초 완전 정복! 1편 - 프리미티브, 객체, 함수, 배열</a></h2>
                  <p>TypeScript 타입 시스템의 기본기를 다지는 1편! 프리미티브 타입부터 객체, 함수, 배열까지, TypeScript 타입 시스템의 핵심 개념을 쉽고 명확하게 설명합니다.</p>
                  <p>
  <small>October 21, 2024<span class="stretched-link position-relative reading-time text-nowrap" title="Estimated reading time"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
        <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
        <path d="M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0"></path>
        <path d="M12 7v5l3 3"></path>
      </svg>12&nbsp;minutes</span></small>
</p>
</article>
              </div>
            </div>
          <div class="card">
              <div class="card-body">
                <article>
                  <h2 class="h3"><a class="stretched-link text-body" href="/blog/2025-08-16-typescript-readonly-array-for-safer-code/">TypeScript 배열, `T[]` 대신 `ReadonlyArray&lt;T&gt;`를 써야 하는 이유</a></h2>
                  <p>함수 하나 호출했을 뿐인데 원본 배열이 망가진 경험, 있으신가요? 이런 사이드 이펙트 버그를 원천 차단하는 TypeScript의 강력한 무기, `ReadonlyArray<T>`의 모든 것을 알려드립니다. 이제 불변성은 선택이 아닌 필수입니다.</p>
                  <p>
  <small>August 17, 2025<span class="stretched-link position-relative reading-time text-nowrap" title="Estimated reading time"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
        <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
        <path d="M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0"></path>
        <path d="M12 7v5l3 3"></path>
      </svg>5&nbsp;minutes</span></small>
</p>
</article>
              </div>
            </div>
          </div>
      </div>
    </section>
    <script src="https://utteranc.es/client.js"
      repo="cpro95/utterances_mycodings_fly_dev"
      issue-term="pathname"
      theme="github-light"
      label="blog-comment"
      crossorigin="anonymous"
    async>
    </script>
  </div>
  
    <footer class="footer text-muted">
  <div class="container-lg">
    <div class="row">
      <div class="col-lg-8 text-center text-lg-start">
        <ul class="list-inline">
          <li class="list-inline-item"><a class="text-muted" href="/about/">about</a></li>
        </ul>
      </div>
      <div class="col-lg-8 text-center text-lg-end">
        <ul class="list-inline">
          <li class="list-inline-item">Copyright (c) All Right Reserved.</li>
        </ul>
      </div>
    </div>
  </div>
</footer>

    

<script async
  src="/js/app.19b73e0182301dd61c9211c2f6890104740e2eb9eb12fe4ba8d4f31435b22ed6.js"
  integrity="sha256-Gbc&#43;AYIwHdYckhHC9okBBHQOLrnrEv5LqNTzFDWyLtY=">
</script>





<script async
  src="/js/flexsearch.5dd6433c29c3e043627f046054aed58ff3790f58fdb8423f45125bbafdcad335.js"
  integrity="sha256-XdZDPCnD4ENifwRgVK7Vj/N5D1j9uEI/RRJbuv3K0zU=">
</script>
<script async
  src="/js/search-modal.96e662d8f691fe25c859a3437074b485f2d7bed0bca612725028c6cf4322e2f2.js"
  integrity="sha256-luZi2PaR/iXIWaNDcHS0hfLXvtC8phJyUCjGz0Mi4vI=">
</script>

    <div class="d-inline-flex fixed-bottom-right pb-4 pe-4">
  <button id="toTop" type="button" class="btn btn-primary rounded-circle ms-auto p-2"><span class="visually-hidden">Top</span><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-up" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M6 15l6 -6l6 6"></path></svg></button>
</div>

    
  </body>
</html>
