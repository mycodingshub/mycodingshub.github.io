<!doctype html>
<html lang="ko" data-bs-theme="auto">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><link rel="preload" href="https://mycodingshub.github.io/fonts/vendor/jost/jost-v4-latin-regular.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="https://mycodingshub.github.io/fonts/vendor/jost/jost-v4-latin-500.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="https://mycodingshub.github.io/fonts/vendor/jost/jost-v4-latin-700.woff2" as="font" type="font/woff2" crossorigin>
<script 
  src="/js/color-mode.86a91f050a481d0a3f0c72ac26543cb6228c770875981c58dcbc008fd3f875c8.js"
  integrity="sha256-hqkfBQpIHQo/DHKsJlQ8tiKMdwh1mBxY3LwAj9P4dcg=">
</script>


<link rel="stylesheet" href="/main.86b7305f5a96b7dd3a46fa6277d87b125af3bf13f48c4cfcc269be84fa9e8fb75375d45a5fe9056ce9190644b7a6e5f13f917f12d853ed38bb76d8856898f755.css" integrity="sha512-hrcwX1qWt906Rvpid9h7ElrzvxP0jEz8wmm+hPqej7dTddRaX+kFbOkZBkS3puXxP5F/EthT7Ti7dtiFaJj3VQ==" crossorigin="anonymous">

<noscript><style>img.lazyload { display: none; }</style></noscript><title>타입스크립트로 Excel 수식 엔진 직접 만들기 (ANTLR, 스택 VM)</title>
<meta name="description" content="수천 개의 의존성을 가진 복잡한 Excel 수식이 느려지는 문제를 해결하기 위해, 타입스크립트를 이용해 파싱부터 실행까지 직접 수식 엔진을 만들어 본 경험을 공유합니다. ANTLR, 역폴란드 표기법(RPN), 스택 VM의 원리를 파헤쳐 봅니다." />
<link rel="canonical" href="https://mycodingshub.github.io/blog/2025-08-27-building-excel-formula-engine-with-typescript-from-scratch/" />
<meta name="robots" content="index, follow" />

<meta property="og:type" content="article" />
<meta property="og:title" content="타입스크립트로 Excel 수식 엔진 직접 만들기 (ANTLR, 스택 VM)" />
<meta property="og:description" content="수천 개의 의존성을 가진 복잡한 Excel 수식이 느려지는 문제를 해결하기 위해, 타입스크립트를 이용해 파싱부터 실행까지 직접 수식 엔진을 만들어 본 경험을 공유합니다. ANTLR, 역폴란드 표기법(RPN), 스택 VM의 원리를 파헤쳐 봅니다." />
<meta property="og:url" content="https://mycodingshub.github.io/blog/2025-08-27-building-excel-formula-engine-with-typescript-from-scratch/" />
<meta property="og:site_name" content="Home" />
<meta property="og:image" content="https://mycodingshub.github.io/cover.png" />
<meta property="og:locale" content="en" />
<meta property="article:published_time" content="2025-08-31T05:12:09Z" />
<meta property="article:modified_time" content="2025-08-31T05:12:09Z" />
<meta property="article:tag" content="타입스크립트" />
<meta property="article:tag" content="Excel" />
<meta property="article:tag" content="수식 엔진" />
<meta property="article:tag" content="ANTLR" />
<meta property="article:tag" content="역폴란드 표기법" />
<meta property="article:tag" content="스택 VM" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:title" content="타입스크립트로 Excel 수식 엔진 직접 만들기 (ANTLR, 스택 VM)" />
<meta name="twitter:description" content="수천 개의 의존성을 가진 복잡한 Excel 수식이 느려지는 문제를 해결하기 위해, 타입스크립트를 이용해 파싱부터 실행까지 직접 수식 엔진을 만들어 본 경험을 공유합니다. ANTLR, 역폴란드 표기법(RPN), 스택 VM의 원리를 파헤쳐 봅니다." />
<meta name="twitter:image" content="https://mycodingshub.github.io/cover.png" />

<meta name="author" content="cpro95@gmail.com" />

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "\"타입스크립트로 Excel 수식 엔진 직접 만들기 (ANTLR, 스택 VM)\"",
  "description": "\"수천 개의 의존성을 가진 복잡한 Excel 수식이 느려지는 문제를 해결하기 위해, 타입스크립트를 이용해 파싱부터 실행까지 직접 수식 엔진을 만들어 본 경험을 공유합니다. ANTLR, 역폴란드 표기법(RPN), 스택 VM의 원리를 파헤쳐 봅니다.\"",
  "datePublished": "\"2025-08-31T05:12:09Z\"",
  "dateModified": "\"2025-08-31T05:12:09Z\"",
  "author": {
    "@type": "Person",
    "name": "\"cpro95@gmail.com\""
  },
  "image": "\"https://mycodingshub.github.io/cover.png\"",
  "url": "\"https://mycodingshub.github.io/blog/2025-08-27-building-excel-formula-engine-with-typescript-from-scratch/\"",
  "publisher": {
    "@type": "Organization",
    "name": "\"Home\""
  }
}
</script>




<script async src="https://www.googletagmanager.com/gtag/js?id=G-C7SBETWEJ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-C7SBETWEJ0');
</script>


<script
  async
  src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7748316956330968"
  crossOrigin="anonymous"
></script>


</head>

  
  <body class="single section blog" data-bs-spy="scroll" data-bs-target="#toc" data-bs-root-margin="0px 0px -60%" data-bs-smooth-scroll="true" tabindex="0">
    <div class="sticky-top">
<header class="navbar navbar-expand-sm">
  <div class="container-lg">
  <div class="d-flex flex-grow-1 justify-content-between">
    <div class="d-flex flex-row navbar-nav justify-content-between align-items-start gap-2">
    
    <a class="nav-link fw-bold fs-4" href="/">Home</a>

    
    
            <a class="nav-link fs-4  active" href="https://mycodingshub.github.io/blog/" aria-current="true">Blog</a>
          
        
            <a class="nav-link fs-4 " href="https://mycodingshub.github.io/life/">Life</a>
          
        
    </div>
    <div class="d-flex flex-row justify-content-between align-items-center">
      
      
      <button type="button" id="searchToggleMobile" class="btn btn-link nav-link mx-2 d-lg-none" aria-label="Search website">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
          <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
          <circle cx="10" cy="10" r="7"></circle>
          <line x1="21" y1="21" x2="15" y2="15"></line>
        </svg>
      </button>
      
      
      <button type="button" id="searchToggleDesktop" class="btn btn-link nav-link p-2 d-none d-lg-block" aria-label="Search website">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
          <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
          <circle cx="10" cy="10" r="7"></circle>
          <line x1="21" y1="21" x2="15" y2="15"></line>
        </svg>
      </button>
      
      <button id="buttonColorMode" class="btn btn-link mx-auto nav-link p-0 ms-lg-2 me-lg-1" type="button" aria-label="Toggle theme">
        <svg data-bs-theme-value="dark" xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-moon" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
          <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
          <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
        </svg>
        <svg data-bs-theme-value="light" xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-sun" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
          <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
          <path d="M12 12m-4 0a4 4 0 1 0 8 0a4 4 0 1 0 -8 0m-5 0h1m8 -9v1m8 8h1m-9 8v1m-6.4 -15.4l.7 .7m12.1 -.7l-.7 .7m0 11.4l.7 .7m-12.1 -.7l-.7 .7"></path>
        </svg>
      </button>
      </div>
        
        
        
        
        </div>
    </div>

    
    </div>
</header>
</div>

<div class="modal" id="searchModal" tabindex="-1" aria-labelledby="searchModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-fullscreen-md-down">
    <div class="modal-content">
      <div class="modal-header">
        <h1 class="modal-title fs-5 visually-hidden" id="searchModalLabel">Search</h1>
        <button type="button" class="btn-close visually-hidden" data-bs-dismiss="modal" aria-label="Close"></button>
        <div class="search-input flex-grow-1 d-none">
          <form id="search-form" class="search-form" action="#" method="post" accept-charset="UTF-8" role="search">
            <label for="query" class="visually-hidden">Search</label>
            <div class="d-flex">
              <input type="search" id="query" name="query" class="search-text form-control form-control-lg" placeholder="Search" aria-label="Search" maxlength="128" autocomplete="off">
              <button type="button" class="btn btn-link text-decoration-none px-0 ms-3 d-md-none" data-bs-dismiss="modal" aria-label="Close">Cancel</button>
            </div>
          </form>
        </div>
      </div>
      <div class="modal-body">
        <p class="search-loading status message d-none mt-3 text-center">Loading search index…</p>
        <p class="search-no-recent message d-none mt-3 text-center">No recent searches</p>
        <p class="search-no-results message d-none mt-3 text-center">No results for "<strong><span class="query-no-results">Query here</span></strong>"</p>
        <div id="searchResults" class="search-results"></div>
        <template>
          <article class="search-result list-view">
            <div class="card my-3">
              <div class="card-body">
                <header>
                  <h2 class="h5 title title-submitted mb-0"><a class="stretched-link text-decoration-none text-reset" href="#">Title here</a></h2>
                  <div class="submitted d-none"><time class="created-date">Date here</time></div>
                </header>
                <div class="content">Summary here</div>
              </div>
            </div>
          </article>
        </template>
      </div>
      <div class="modal-footer">
        <ul class="list-inline me-auto d-none d-md-block">
          <li class="list-inline-item"><kbd class="me-2"><svg width="15" height="15" aria-label="Enter key" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M12 3.53088v3c0 1-1 2-2 2H4M7 11.53088l-3-3 3-3"></path></g></svg></kbd><span class="DocSearch-Label">to select</span></li>
          <li class="list-inline-item"><kbd class="me-2"><svg width="15" height="15" aria-label="Arrow down" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M7.5 3.5v8M10.5 8.5l-3 3-3-3"></path></g></svg></kbd><kbd class="me-2"><svg width="15" height="15" aria-label="Arrow up" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M7.5 11.5v-8M10.5 6.5l-3-3-3 3"></path></g></svg></kbd><span class="DocSearch-Label">to navigate</span></li>
          <li class="list-inline-item"><kbd class="me-2"><svg width="15" height="15" aria-label="Escape key" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M13.6167 8.936c-.1065.3583-.6883.962-1.4875.962-.7993 0-1.653-.9165-1.653-2.1258v-.5678c0-1.2548.7896-2.1016 1.653-2.1016.8634 0 1.3601.4778 1.4875 1.0724M9 6c-.1352-.4735-.7506-.9219-1.46-.8972-.7092.0246-1.344.57-1.344 1.2166s.4198.8812 1.3445.9805C8.465 7.3992 8.968 7.9337 9 8.5c.032.5663-.454 1.398-1.4595 1.398C6.6593 9.898 6 9 5.963 8.4851m-1.4748.5368c-.2635.5941-.8099.876-1.5443.876s-1.7073-.6248-1.7073-2.204v-.4603c0-1.0416.721-2.131 1.7073-2.131.9864 0 1.6425 1.031 1.5443 2.2492h-2.956"></path></g></svg></kbd><span class="DocSearch-Label">to close</span></li>
        </ul>
        <p class="d-md-none">Search by <a class="text-decoration-none" href="https://github.com/nextapps-de/flexsearch">FlexSearch</a></p>
      </div>
    </div>
  </div>
</div>


    <div class="wrap container-lg" role="document">
      <div class="content">
      
        
<article>
  <div class="row justify-content-center">
    <div class="col-md-12 col-lg-12">
      
      <ins class="adsbygoogle"
        style="display:block"
        data-ad-client="ca-pub-7748316956330968"
        data-ad-slot="2971373181"
        data-ad-format="auto"
        data-full-width-responsive="true"></ins>
      <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
      </script>
      <div class="blog-header">
        <h1>타입스크립트로 Excel 수식 엔진 직접 만들기 (ANTLR, 스택 VM)</h1>
        <p>
  <small>August 31, 2025<span class="stretched-link position-relative reading-time text-nowrap" title="Estimated reading time"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
        <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
        <path d="M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0"></path>
        <path d="M12 7v5l3 3"></path>
      </svg>8&nbsp;minutes</span></small>
</p>

      </div>
    </div>
      <div class="col-md-12 col-lg-12">
      
      <p>안녕하세요, 여러분.<br /><br /> 오늘은 좀 재미있는 주제를 가져왔는데요.<br /><br /> 바로 타입스크립트로 &lsquo;Excel 수식 엔진&rsquo;을 처음부터 끝까지 만들어보는 여정입니다.<br /><br />
&lsquo;굳이 그걸 왜 만들어?&rsquo; 싶으실 수도 있거든요.<br /><br /> 저희가 개발하는 서비스 중 하나가 Excel 파일을 그대로 웹에서 사용할 수 있게 해주는 기능인데, 셀 참조나 수식의 의존성이 5,000개를 넘어가는 순간 엄청나게 느려지는 문제가 있었습니다.<br /><br />
기존에는 <code>math.js</code> 같은 라이브러리를 사용해 수식을 계산했는데요.<br /><br /> 유연성은 정말 좋지만, 계산할 때마다 매번 수식을 분석하고 평가하는 방식이라 어쩔 수 없는 성능 저하가 있었습니다.<br /><br />
이 문제를 해결하려면 결국 계산 한 번 한 번의 속도를 올리는 수밖에 없다는 결론에 이르렀거든요.<br /><br /> 그래서 직접 수식 엔진을 만들기로 결심했고, 그 결과는 놀라웠습니다.<br /><br /> 무려 &lsquo;100배&rsquo;나 빨라졌으니까요.<br /><br />
그런데 만들다 보니 이 과정이 마치 하나의 작은 프로그래밍 언어를 설계하는 것 같아 너무 흥미로웠는데요.<br /><br /> 오늘은 그 핵심 원리를 사칙연산과 <code>IF</code> 함수를 예로 들어 최대한 쉽게 풀어보려고 합니다.<br /><br /></p>
<h2 id="전체-그림-그려보기">전체 그림 그려보기</h2>
<p>가장 먼저 전체적인 동작 흐름부터 살펴보는 게 좋겠네요.<br /><br /> 우리가 만들 수식 엔진은 크게 세 가지 단계를 거쳐 동작하는데요.<br /><br /></p>
<ol>
<li><strong>구문 분석 (Parsing)</strong>: <code>ANTLR</code>라는 도구를 사용해서 &ldquo;=A1+B1*2&rdquo; 같은 수식 문자열을 컴퓨터가 이해할 수 있는 &lsquo;구문 트리(Parse Tree)&rsquo; 구조로 변환합니다.<br /><br /></li>
<li><strong>RPN 변환 (Conversion)</strong>: 이 구문 트리를 &lsquo;역폴란드 표기법(RPN)&lsquo;이라는 특별한 형태로 바꾸어 중간 표현(IR)을 생성합니다.<br /><br /></li>
<li><strong>실행 (Execution)</strong>: 마지막으로 &lsquo;스택 가상 머신(Stack VM)&lsquo;이 이 RPN 코드를 읽어서 최종 결과값을 계산해냅니다.<br /><br /></li>
</ol>
<p>말로만 들으면 조금 복잡하게 느껴질 수 있는데요.<br /><br /> 아래 그림을 보시면 바로 감이 오실 겁니다.<br /><br /></p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <pre tabindex="0"><code>&#34;=A1+B1*2&#34;  (수식 문자열)
     ↓
[구문 분석기 ANTLR]  →  문자열을 조각내고(토큰화) 구조를 파악
     ↓
       [+] (구문 트리)
      /   \
   [A1]   [*]
          / \
       [B1] [2]
     ↓
[RPN 변환기]  →  컴퓨터가 계산하기 쉬운 순서로 재배열
     ↓
   RPN: [&#34;A1&#34;, &#34;B1&#34;, &#34;2&#34;, &#34;*&#34;, &#34;+&#34;]
     ↓
[스택 VM 실행]  →  스택에 값을 쌓아가며 순서대로 계산
     ↓
   [10] [3] [2]  →  [10] [6]  →  [16]
     ↓
   결과: 16</code></pre>
  </figure>
</div>
<p>기존 <code>math.js</code>가 수식 문자열을 받아서 바로 해석하고 실행하는 &lsquo;인터프리터&rsquo; 방식이었다면, 이번에 저희가 만든 건 미리 계산 가능한 형태로 번역해두는 &lsquo;컴파일러&rsquo; 방식에 가깝습니다.<br /><br /> 이렇게 한 단계 거치는 게 오히려 실행 속도를 극적으로 끌어올리는 비결이거든요.<br /><br />
자, 그럼 이제 각 단계를 하나씩 자세히 들여다볼 시간입니다.<br /><br /></p>
<h2 id="1단계-구문-분석-antlr로-언어의-뼈대-세우기">1단계 구문 분석 ANTLR로 언어의 뼈대 세우기</h2>
<p>첫 단계는 수식이라는 문자열을 컴퓨터가 이해할 수 있는 구조로 만들어주는 &lsquo;구문 분석&rsquo;인데요.<br /><br /> 저희는 이 작업을 위해 <code>ANTLR</code>라는 아주 강력한 &lsquo;파서 생성기&rsquo;를 활용했습니다.<br /><br />
ANTLR는 &lsquo;언어의 문법&rsquo;을 미리 정의해두면, 그 문법에 맞춰 문자열을 분석하는 &lsquo;어휘 분석기(Lexer)&lsquo;와 &lsquo;구문 분석기(Parser)&rsquo; 코드를 자동으로 만들어주는 도구거든요.<br /><br /> 마치 언어의 &lsquo;청사진&rsquo;을 그려주는 것과 같습니다.<br /><br />
아래가 바로 사칙연산, <code>SUM</code>, <code>IF</code> 함수, 그리고 셀 참조를 처리하기 위해 저희가 정의한 문법 파일(<code>Formula.g4</code>)의 일부인데요.<br /><br /> 처음 보면 낯설 수 있지만, 아래쪽부터 읽어 올라가면 이해하기 훨씬 수월합니다.<br /><br /></p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">// Formula.g4: 사칙연산, SUM, IF, 셀 참조 문법 정의
</span></span><span class="line"><span class="cl">grammar Formula<span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 시작 규칙: 수식은 등호<span class="o">(=)</span>로 시작할 수도 있고, 표현식<span class="o">(</span>expr<span class="o">)</span>으로 구성됨
</span></span><span class="line"><span class="cl">formula: EQ? expr EOF<span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 표현식 규칙: 덧셈/뺄셈 식에 비교 연산자가 붙는 형태
</span></span><span class="line"><span class="cl">expr: additiveExpr <span class="o">(</span> <span class="o">(</span>GT <span class="p">|</span> LT <span class="p">|</span> GTEQ <span class="p">|</span> LTEQ <span class="p">|</span> EQ <span class="p">|</span> NEQ<span class="o">)</span> additiveExpr <span class="o">)</span>?<span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 덧셈/뺄셈 규칙: 덧셈/뺄셈 식 뒤에 곱셈/나눗셈 식이 오거나, 곱셈/나눗셈 식만 올 수 있음
</span></span><span class="line"><span class="cl">additiveExpr
</span></span><span class="line"><span class="cl">    : additiveExpr <span class="o">(</span>PLUS <span class="p">|</span> MINUS<span class="o">)</span> multiplicativeExpr
</span></span><span class="line"><span class="cl">    <span class="p">|</span> multiplicativeExpr
</span></span><span class="line"><span class="cl">    <span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 곱셈/나눗셈 규칙: 곱셈/나눗셈 식 뒤에 단항 식이 오거나, 단항 식만 올 수 있음
</span></span><span class="line"><span class="cl">multiplicativeExpr
</span></span><span class="line"><span class="cl">    : multiplicativeExpr <span class="o">(</span>MUL <span class="p">|</span> DIV<span class="o">)</span> unaryExpr
</span></span><span class="line"><span class="cl">    <span class="p">|</span> unaryExpr
</span></span><span class="line"><span class="cl">    <span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// ... <span class="o">(</span>중략<span class="o">)</span> ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// <span class="o">=====</span> Lexer 규칙들 <span class="o">(</span>토큰 정의<span class="o">)</span> <span class="o">=====</span>
</span></span><span class="line"><span class="cl">IF  : <span class="o">[</span>Ii<span class="o">]</span> <span class="o">[</span>Ff<span class="o">]</span> <span class="p">;</span> // <span class="s1">&#39;IF&#39;</span> 또는 <span class="s1">&#39;if&#39;</span>는 IF 토큰
</span></span><span class="line"><span class="cl">SUM : <span class="o">[</span>Ss<span class="o">]</span> <span class="o">[</span>Uu<span class="o">]</span> <span class="o">[</span>Mm<span class="o">]</span> <span class="p">;</span> // <span class="s1">&#39;SUM&#39;</span> 또는 <span class="s1">&#39;sum&#39;</span>은 SUM 토큰
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">EQ   : <span class="s1">&#39;=&#39;</span> <span class="p">;</span>      // <span class="s1">&#39;=&#39;</span>는 EQ 토큰
</span></span><span class="line"><span class="cl">PLUS : <span class="s1">&#39;+&#39;</span> <span class="p">;</span>      // <span class="s1">&#39;+&#39;</span>는 PLUS 토큰
</span></span><span class="line"><span class="cl">MUL  : <span class="s1">&#39;*&#39;</span> <span class="p">;</span>      // <span class="s1">&#39;*&#39;</span>는 MUL 토큰
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">CELL_REF : <span class="o">[</span>A-Z<span class="o">]</span>+ <span class="o">[</span>1-9<span class="o">][</span>0-9<span class="o">]</span>* <span class="p">;</span> // <span class="s1">&#39;A1&#39;</span>, <span class="s1">&#39;B12&#39;</span> 등은 CELL_REF 토큰
</span></span><span class="line"><span class="cl">NUMBER   : <span class="o">[</span>0-9<span class="o">]</span>+ <span class="o">(</span><span class="s1">&#39;.&#39;</span> <span class="o">[</span>0-9<span class="o">]</span>+<span class="o">)</span>? <span class="p">;</span> // 숫자는 NUMBER 토큰
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">WS : <span class="o">[</span> <span class="se">\t\r\n</span><span class="o">]</span>+ -&gt; skip <span class="p">;</span> // 공백은 무시</span></span></code></pre></div>
  </figure>
</div>
<p>여기서 정말 중요한 부분이 바로 <code>additiveExpr</code>와 <code>multiplicativeExpr</code> 규칙인데요.<br /><br /> <code>additiveExpr</code> 규칙 안에 <code>multiplicativeExpr</code>가 포함된 구조로 정의함으로써, 곱셈/나눗셈이 덧셈/뺄셈보다 &lsquo;연산자 우선순위&rsquo;가 높다는 것을 자연스럽게 표현한 겁니다.<br /><br />
이 문법 파일을 빌드하면 <code>FormulaParser</code>, <code>FormulaVisitor</code> 등의 클래스가 생성되거든요.<br /><br /> 이제 이 클래스들을 이용해서 실제 파싱을 진행하는 코드를 한번 보시죠.<br /><br /></p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">import</span> <span class="p">{</span> <span class="nx">CharStream</span><span class="p">,</span> <span class="nx">CommonTokenStream</span> <span class="p">}</span> <span class="kr">from</span> <span class="s2">&#34;antlr4&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nx">FormulaLexer</span> <span class="kr">from</span> <span class="s2">&#34;./antlr/generated/FormulaLexer&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nx">FormulaParser</span> <span class="kr">from</span> <span class="s2">&#34;./antlr/generated/FormulaParser&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 1. 수식 문자열을 입력 스트림으로 만듭니다.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">inputStream</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">CharStream</span><span class="p">(</span><span class="nx">formula</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 2. Lexer가 문자열을 토큰 단위로 쪼갭니다. (&#34;=&#34;, &#34;A1&#34;, &#34;+&#34;, &#34;B1&#34;, ...)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">lexer</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">FormulaLexer</span><span class="p">(</span><span class="nx">inputStream</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">tokenStream</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">CommonTokenStream</span><span class="p">(</span><span class="nx">lexer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 3. Parser가 토큰 스트림을 읽어 구문 트리를 생성합니다.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">parser</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">FormulaParser</span><span class="p">(</span><span class="nx">tokenStream</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">tree</span> <span class="o">=</span> <span class="nx">parser</span><span class="p">.</span><span class="nx">formula</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 이제 &#39;tree&#39;라는 결과물을 가지고 다음 단계로 넘어갑니다.
</span></span></span></code></pre></div>
  </figure>
</div>
<p>이렇게 해서 얻은 <code>tree</code> 객체가 바로 저희가 원했던 &lsquo;구문 분석 트리&rsquo;인데요.<br /><br /> 이제 이 트리를 컴퓨터가 계산하기 가장 좋은 형태인 &lsquo;역폴란드 표기법(RPN)&lsquo;으로 변환할 차례입니다.<br /><br /></p>
<h2 id="2단계-rpn-변환-계산을-위한-최적의-레시피-만들기">2단계 RPN 변환 계산을 위한 최적의 레시피 만들기</h2>
<p>&lsquo;역폴란드 표기법&rsquo;, 줄여서 RPN은 연산자를 숫자 뒤에 놓는 표기법을 말하는데요.<br /><br /> 예를 들어 <code>10 + (20 * 30)</code> 이라는 수식은 RPN으로 바꾸면 <code>10 20 30 * +</code> 가 됩니다.<br /><br />
굳이 이렇게 복잡하게 바꾸는 이유가 있거든요.<br /><br /> 바로 RPN이 &lsquo;스택(Stack)&rsquo; 자료구조를 이용해서 계산하기에 정말 완벽한 형태이기 때문입니다.<br /><br /> 앞에서부터 순서대로 읽다가 숫자는 스택에 넣고, 연산자를 만나면 스택에서 숫자 두 개를 꺼내 계산한 뒤 다시 결과를 넣기만 하면 되거든요.<br /><br /> 복잡한 괄호나 연산자 우선순위를 전혀 신경 쓸 필요가 없어지는 겁니다.<br /><br />
이 변환 작업은 ANTLR가 만들어준 <code>Visitor</code> 패턴을 사용하면 아주 우아하게 구현할 수 있는데요.<br /><br /> 구문 트리의 각 노드(덧셈 노드, 숫자 노드 등)를 방문하면서 RPN 토큰을 차곡차곡 쌓아나가는 방식입니다.<br /><br /></p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="c1">// FormulaToRPNConverter.ts
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">class</span> <span class="nx">FormulaToRPNConverter</span> <span class="kr">extends</span> <span class="nx">FormulaVisitor</span><span class="p">&lt;</span><span class="nt">void</span><span class="p">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">private</span> <span class="nx">tokens</span>: <span class="kt">RPNToken</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[];</span>
</span></span><span class="line"><span class="cl">  <span class="kr">private</span> <span class="nx">dependencies</span>: <span class="kt">Set</span><span class="p">&lt;</span><span class="nt">string</span><span class="p">&gt;</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 덧셈/뺄셈 노드를 방문했을 때 호출됩니다.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">visitAdditiveExpr</span> <span class="o">=</span> <span class="p">(</span><span class="nx">ctx</span>: <span class="kt">AdditiveExprContext</span><span class="p">)</span><span class="o">:</span> <span class="k">void</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">additiveExpr</span> <span class="o">=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">additiveExpr</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">multiplicativeExpr</span> <span class="o">=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">multiplicativeExpr</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">additiveExpr</span> <span class="o">&amp;&amp;</span> <span class="nx">multiplicativeExpr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 1. 왼쪽 식을 먼저 방문해서 처리합니다. (재귀 호출)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">this</span><span class="p">.</span><span class="nx">visit</span><span class="p">(</span><span class="nx">additiveExpr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 2. 오른쪽 식을 방문해서 처리합니다.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">this</span><span class="p">.</span><span class="nx">visit</span><span class="p">(</span><span class="nx">multiplicativeExpr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">// 3. 마지막으로 연산자 토큰을 추가합니다.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if</span> <span class="p">(</span><span class="nx">ctx</span><span class="p">.</span><span class="nx">PLUS</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="nx">tokens</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span> <span class="kr">type</span><span class="o">:</span> <span class="nx">TokenType</span><span class="p">.</span><span class="nx">ADD</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">ctx</span><span class="p">.</span><span class="nx">MINUS</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="nx">tokens</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span> <span class="kr">type</span><span class="o">:</span> <span class="nx">TokenType</span><span class="p">.</span><span class="nx">SUBTRACT</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">multiplicativeExpr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">this</span><span class="p">.</span><span class="nx">visit</span><span class="p">(</span><span class="nx">multiplicativeExpr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 셀 참조 노드를 방문했을 때
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">visitCellRef</span> <span class="o">=</span> <span class="p">(</span><span class="nx">ctx</span>: <span class="kt">CellRefContext</span><span class="p">)</span><span class="o">:</span> <span class="k">void</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">ref</span> <span class="o">=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">getText</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">dependencies</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">ref</span><span class="p">);</span> <span class="c1">// 의존성 목록에 추가
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">tokens</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span> <span class="kr">type</span><span class="o">:</span> <span class="nx">TokenType</span><span class="p">.</span><span class="nx">CELL_REF</span><span class="p">,</span> <span class="nx">value</span>: <span class="kt">ref</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 숫자 노드를 방문했을 때
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">visitNumberExpr</span> <span class="o">=</span> <span class="p">(</span><span class="nx">ctx</span>: <span class="kt">NumberExprContext</span><span class="p">)</span><span class="o">:</span> <span class="k">void</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">value</span> <span class="o">=</span> <span class="nb">parseFloat</span><span class="p">(</span><span class="nx">ctx</span><span class="p">.</span><span class="nx">getText</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">tokens</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span> <span class="kr">type</span><span class="o">:</span> <span class="nx">TokenType</span><span class="p">.</span><span class="nx">NUMBER</span><span class="p">,</span> <span class="nx">value</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div>
  </figure>
</div>
<p><code>visitAdditiveExpr</code>를 보시면, 왼쪽과 오른쪽 자식 노드를 먼저 <code>visit</code>하고 마지막에 연산자를 추가하는 것을 볼 수 있는데요.<br /><br /> 이런 &lsquo;후위 순회(Post-order traversal)&rsquo; 방식이 바로 구문 트리를 RPN으로 변환하는 핵심 원리입니다.<br /><br /></p>
<h3 id="if-함수-단순한-함수를-넘어선-제어문">IF 함수 단순한 함수를 넘어선 제어문</h3>
<p>RPN 변환 과정에서 가장 흥미로운 부분은 바로 <code>IF</code> 함수 처리인데요.<br /><br /> <code>IF(조건, 참일_때_값, 거짓일_때_값)</code>은 단순히 값을 계산하는 걸 넘어서 프로그램의 &lsquo;흐름을 제어&rsquo;해야 하기 때문입니다.<br /><br />
만약 조건이 <code>참</code>이라면 &lsquo;거짓일_때_값&rsquo; 부분은 아예 계산조차 하지 않는 게 효율적이거든요.<br /><br /> 이걸 구현하기 위해 저희는 &lsquo;점프(JUMP)&lsquo;라는 특별한 명령어를 도입했습니다.<br /><br /></p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="c1">// visitIfFunction의 일부
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">visitIfFunction</span> <span class="o">=</span> <span class="p">(</span><span class="nx">ctx</span>: <span class="kt">IfFunctionContext</span><span class="p">)</span><span class="o">:</span> <span class="k">void</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 1. 조건식을 먼저 평가하도록 RPN 토큰을 생성합니다.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">this</span><span class="p">.</span><span class="nx">visit</span><span class="p">(</span><span class="nx">exprs</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 2. &#39;조건이 거짓이면 점프하라&#39;는 명령어를 일단 넣어둡니다. (목적지는 미정)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">jumpToElseIndex</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">tokens</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="p">.</span><span class="nx">tokens</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span> <span class="kr">type</span><span class="o">:</span> <span class="nx">TokenType</span><span class="p">.</span><span class="nx">JUMP_IF_FALSE</span><span class="p">,</span> <span class="nx">offset</span>: <span class="kt">0</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 3. &#39;참일_때_값&#39;에 대한 RPN 토큰을 생성합니다.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">this</span><span class="p">.</span><span class="nx">visit</span><span class="p">(</span><span class="nx">exprs</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 4. &#39;참&#39; 브랜치 실행 후 &#39;거짓&#39; 브랜치를 건너뛸 &#39;무조건 점프&#39; 명령어를 넣습니다.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">jumpToEndIndex</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">tokens</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="p">.</span><span class="nx">tokens</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span> <span class="kr">type</span><span class="o">:</span> <span class="nx">TokenType</span><span class="p">.</span><span class="nx">JUMP</span><span class="p">,</span> <span class="nx">offset</span>: <span class="kt">0</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 5. &#39;거짓&#39; 브랜치가 시작될 위치를 기록합니다.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">elseStartIndex</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">tokens</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 6. &#39;거짓일_때_값&#39;에 대한 RPN 토큰을 생성합니다.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">this</span><span class="p">.</span><span class="nx">visit</span><span class="p">(</span><span class="nx">exprs</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 7. 이제 모든 위치가 정해졌으니, 아까 넣어뒀던 점프 명령어들의 목적지(offset)를 채워줍니다.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">this</span><span class="p">.</span><span class="nx">tokens</span><span class="p">[</span><span class="nx">jumpToElseIndex</span><span class="p">].</span><span class="nx">offset</span> <span class="o">=</span> <span class="nx">elseStartIndex</span> <span class="o">-</span> <span class="nx">jumpToElseIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="p">.</span><span class="nx">tokens</span><span class="p">[</span><span class="nx">jumpToEndIndex</span><span class="p">].</span><span class="nx">offset</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">tokens</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="nx">jumpToEndIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
  </figure>
</div>
<p>조금 복잡해 보이지만 핵심은 간단한데요.<br /><br /> <code>JUMP_IF_FALSE</code>는 조건식의 결과가 <code>거짓</code>일 때 특정 위치로 실행 순서를 건너뛰게 만드는 명령어입니다.<br /><br /> 덕분에 불필요한 계산을 원천적으로 차단할 수 있었고, 이게 성능 향상에 아주 큰 도움이 됐습니다.<br /><br />
자, 이제 계산을 위한 완벽한 레시피, RPN 토큰들이 준비되었습니다.<br /><br /> 마지막으로 이 레시피를 요리할 주방장, &lsquo;스택 VM&rsquo;을 만나볼 차례입니다.<br /><br /></p>
<h2 id="3단계-실행-스택-vm으로-최종-결과값-계산하기">3단계 실행 스택 VM으로 최종 결과값 계산하기</h2>
<p>스택 VM은 RPN 토큰을 실행하기 위해 만든 아주 작은 가상 머신인데요.<br /><br /> 세상에서 가장 단순한 계산기라고 생각하시면 편합니다.<br /><br /> 이 계산기가 가진 건 값을 임시로 저장하는 &lsquo;스택&rsquo;과, 다음에 실행할 명령어를 가리키는 &lsquo;프로그램 카운터(PC)&lsquo;가 전부이거든요.<br /><br />
동작 원리는 정말 간단합니다.<br /><br /> 프로그램 카운터를 하나씩 증가시키면서 RPN 토큰을 순서대로 읽고, 토큰의 종류에 따라 정해진 작업을 수행할 뿐입니다.<br /><br /></p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="c1">// StackVM.ts
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">class</span> <span class="nx">StackVM</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">private</span> <span class="nx">stack</span>: <span class="kt">unknown</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[];</span>
</span></span><span class="line"><span class="cl">  <span class="kr">private</span> <span class="nx">pc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 프로그램 카운터
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="nx">evaluate</span><span class="p">(</span><span class="nx">tokens</span>: <span class="kt">RPNToken</span><span class="p">[],</span> <span class="nx">context</span>: <span class="kt">EvaluationContext</span><span class="p">)</span><span class="o">:</span> <span class="kt">unknown</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">stack</span> <span class="o">=</span> <span class="p">[];</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">pc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">pc</span> <span class="o">&lt;</span> <span class="nx">tokens</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kr">const</span> <span class="nx">token</span> <span class="o">=</span> <span class="nx">tokens</span><span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">pc</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">switch</span> <span class="p">(</span><span class="nx">token</span><span class="p">.</span><span class="kr">type</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nx">TokenType.NUMBER</span>:
</span></span><span class="line"><span class="cl">          <span class="kt">this.stack.push</span><span class="p">(</span><span class="nx">token</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nx">TokenType</span><span class="p">.</span><span class="nx">CELL_REF</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">          <span class="c1">// context에서 셀 값을 가져와 스택에 넣습니다.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="kr">const</span> <span class="nx">value</span> <span class="o">=</span> <span class="nx">context</span><span class="p">.</span><span class="nx">dependencies</span><span class="p">.</span><span class="kr">get</span><span class="p">(</span><span class="nx">token</span><span class="p">.</span><span class="nx">value</span> <span class="kr">as</span> <span class="kt">string</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="k">this</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nx">TokenType.ADD</span>:
</span></span><span class="line"><span class="cl">          <span class="kt">const</span> <span class="nx">b</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">popNumber</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">          <span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">popNumber</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">          <span class="k">this</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// ... 다른 연산자들도 비슷하게 처리 ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nx">TokenType.JUMP_IF_FALSE</span>:
</span></span><span class="line"><span class="cl">          <span class="kt">const</span> <span class="nx">condition</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">condition</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 조건이 거짓이면 프로그램 카운터를 offset만큼 점프시킵니다.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">this</span><span class="p">.</span><span class="nx">pc</span> <span class="o">+=</span> <span class="nx">token</span><span class="p">.</span><span class="nx">offset</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">          <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nx">TokenType.JUMP</span>:
</span></span><span class="line"><span class="cl">          <span class="kt">this.pc</span> <span class="o">+=</span> <span class="nx">token</span><span class="p">.</span><span class="nx">offset</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">this</span><span class="p">.</span><span class="nx">pc</span><span class="o">++</span><span class="p">;</span> <span class="c1">// 다음 명령어로 이동
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// 최종 결과는 스택에 남은 마지막 값
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
  </figure>
</div>
<p><code>IF(A1 &gt; 1, 1+1, 2+2)</code> 수식을 <code>A1=0</code> (거짓) 조건으로 실행하는 과정을 한번 따라가 볼까요?<br /><br /></p>
<ol>
<li><code>A1</code> 값(0)과 <code>1</code>을 스택에 넣고, <code>GREATER_THAN</code> 연산자로 비교합니다.<br /><br /> 결과는 <code>false</code>가 되고, 이 값이 스택에 들어갑니다.<br /><br /></li>
<li>다음 명령어는 <code>JUMP_IF_FALSE</code>인데요.<br /><br /> 스택에서 <code>false</code>를 꺼내보고, 조건이 거짓이므로 프로그램 카운터(PC)를 <code>offset</code> 만큼 점프시킵니다.<br /><br /></li>
<li>점프한 결과 <code>1+1</code> 계산 로직은 완전히 건너뛰고, 곧바로 <code>2+2</code>를 계산하는 위치로 이동하게 됩니다.<br /><br /></li>
<li>결국 <code>4</code>라는 최종 결과가 스택에 남게 되는 것이죠.<br /><br /></li>
</ol>
<p>바로 이 점프 로직 덕분에 불필요한 연산을 건너뛸 수 있었던 겁니다.<br /><br /></p>
<h2 id="여기서-한-걸음-더-나아간다면">여기서 한 걸음 더 나아간다면?</h2>
<p>물론 오늘 만든 엔진은 핵심 원리를 보여주기 위한 간소화된 버전인데요.<br /><br /> 실제 Excel처럼 동작하려면 몇 가지 더 넘어야 할 산들이 있습니다.<br /><br />
<code>SUM(A1:B5)</code>처럼 셀 &lsquo;범위&rsquo;를 다루는 기능이나, <code>A1=B1</code>, <code>B1=A1</code>처럼 서로를 참조하는 &lsquo;순환 참조&rsquo; 오류를 감지하는 로직도 필요하거든요.<br /><br /> 특히 순환 참조는 계산을 시작하기 전에 의존성 그래프를 만들고 &lsquo;위상 정렬(Topological Sort)&lsquo;을 통해 찾아내는 과정이 필수적입니다.<br /><br />
<code>#DIV/0!</code>이나 <code>#NAME?</code> 같은 다양한 에러 처리 역시 실제 제품 수준에서는 아주 중요한 부분이고요.<br /><br /></p>
<h2 id="마무리하며">마무리하며</h2>
<p>오늘은 Excel 수식 엔진을 직접 만들어보면서 그 내부 동작 원리를 깊숙이 들여다봤는데요.<br /><br /> 문자열을 파싱해서 컴퓨터가 이해하는 구조로 만들고, 그걸 다시 가장 효율적인 실행 코드로 변환한 뒤, 가상 머신 위에서 실행하는 전체 과정이 정말 하나의 언어 컴파일러를 만드는 축소판 같았습니다.<br /><br />
특히 기존 <code>math.js</code>에서는 구현하기 까다로웠던 <code>IF</code> 함수의 조건부 실행을 점프 명령어로 깔끔하게 구현했을 때 개인적으로 정말 뿌듯했거든요.<br /><br />
이번 프로젝트를 진행하면서 AI의 도움도 정말 많이 받았는데요.<br /><br /> 이런 이론이 잘 정립된 분야는 AI가 정말 초안 코드를 빠르게 잘 짜주는 것 같습니다.<br /><br /> 물론 AI가 준 코드가 한 번에 완벽하게 돌아가지는 않기 때문에, 그걸 이해하고 디버깅하며 우리 시스템에 맞게 수정하는 개발자의 역할은 여전히, 그리고 앞으로도 중요할 거라는 생각을 다시 한번 하게 됐습니다.<br /><br />
이번 이야기가 프로그래밍 언어의 동작 원리나 컴파일러에 관심 있는 분들께 작은 재미와 영감을 드렸으면 좋겠네요.<br /><br /></p>

      <div class="tag-list-single">
        <a class="btn btn-light" href="/tags/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/" role="button">타입스크립트</a>
        <a class="btn btn-light" href="/tags/excel/" role="button">Excel</a>
        <a class="btn btn-light" href="/tags/%EC%88%98%EC%8B%9D-%EC%97%94%EC%A7%84/" role="button">수식 엔진</a>
        <a class="btn btn-light" href="/tags/antlr/" role="button">ANTLR</a>
        <a class="btn btn-light" href="/tags/%EC%97%AD%ED%8F%B4%EB%9E%80%EB%93%9C-%ED%91%9C%EA%B8%B0%EB%B2%95/" role="button">역폴란드 표기법</a>
        <a class="btn btn-light" href="/tags/%EC%8A%A4%ED%83%9D-vm/" role="button">스택 VM</a>
        <a class="btn btn-light" href="/tags/%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC/" role="button">컴파일러</a>
        </div>
      
      <ins class="adsbygoogle"
          style="display:block"
          data-ad-format="autorelaxed"
          data-ad-client="ca-pub-7748316956330968"
          data-ad-slot="4495825428"></ins>
      <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
      </script>
    </div>
  </div>
</article>

      
      </div>
    </div>
    
    
<div class="bg-light">
    <section class="section section-related container">
      <div class="row justify-content-center">
        <div class="col-md-12 col-lg-12">
          <h2 class="section-title text-center">Related posts</h2>
        </div>
      </div>
      <div class="row justify-content-center">
        <div class="col-lg-12">
          <div class="card">
              <div class="card-body">
                <article>
                  <h2 class="h3"><a class="stretched-link text-body" href="/blog/2025-08-16-typescript-readonly-array-for-safer-code/">TypeScript 배열, `T[]` 대신 `ReadonlyArray&lt;T&gt;`를 써야 하는 이유</a></h2>
                  <p>함수 하나 호출했을 뿐인데 원본 배열이 망가진 경험, 있으신가요? 이런 사이드 이펙트 버그를 원천 차단하는 TypeScript의 강력한 무기, `ReadonlyArray<T>`의 모든 것을 알려드립니다. 이제 불변성은 선택이 아닌 필수입니다.</p>
                  <p>
  <small>August 17, 2025<span class="stretched-link position-relative reading-time text-nowrap" title="Estimated reading time"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
        <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
        <path d="M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0"></path>
        <path d="M12 7v5l3 3"></path>
      </svg>5&nbsp;minutes</span></small>
</p>
</article>
              </div>
            </div>
          <div class="card">
              <div class="card-body">
                <article>
                  <h2 class="h3"><a class="stretched-link text-body" href="/blog/2025-08-16-typescript-enum-alternatives-deep-dive/">TypeScript enum, 아직도 쓰고 계신가요?</a></h2>
                  <p>TypeScript 개발자라면 누구나 한번쯤 써봤을 enum. 하지만 왜 많은 전문가들이 enum 사용을 망설이는 걸까요? enum의 숨겨진 문제점부터 가장 확실한 대안인 Object as const 패턴까지, 이제는 알아야 할 모든 것을 알려드립니다.</p>
                  <p>
  <small>August 17, 2025<span class="stretched-link position-relative reading-time text-nowrap" title="Estimated reading time"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
        <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
        <path d="M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0"></path>
        <path d="M12 7v5l3 3"></path>
      </svg>5&nbsp;minutes</span></small>
</p>
</article>
              </div>
            </div>
          <div class="card">
              <div class="card-body">
                <article>
                  <h2 class="h3"><a class="stretched-link text-body" href="/blog/2025-07-25-golang-gorm-gin-tutorial-4-fullstack-react-frontend-ui-app/">Golang, Gin, GORM 실전 API 개발 4편 - 최첨단 Full-Stack 완성편 Vite, TanStack, Zustand, shadcn/ui</a></h2>
                  <p>React 개발의 최신 트렌드를 모두 담아 프론트엔드를 재구축합니다. Vite의 빠른 개발 환경, TanStack의 강력한 라우팅 및 데이터 관리, Zustand의 간결한 상태 관리, shadcn/ui의 미려한 UI를 통해 프로덕션급 풀스택 애플리케이션을 완성합니다.</p>
                  <p>
  <small>July 26, 2025<span class="stretched-link position-relative reading-time text-nowrap" title="Estimated reading time"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
        <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
        <path d="M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0"></path>
        <path d="M12 7v5l3 3"></path>
      </svg>5&nbsp;minutes</span></small>
</p>
</article>
              </div>
            </div>
          </div>
      </div>
    </section>
    <script src="https://utteranc.es/client.js"
      repo="cpro95/utterances_mycodings_fly_dev"
      issue-term="pathname"
      theme="github-light"
      label="blog-comment"
      crossorigin="anonymous"
    async>
    </script>
  </div>
  
    <footer class="footer text-muted">
  <div class="container-lg">
    <div class="row">
      <div class="col-lg-8 text-center text-lg-start">
        <ul class="list-inline">
          <li class="list-inline-item"><a class="text-muted" href="/about/">about</a></li>
        </ul>
      </div>
      <div class="col-lg-8 text-center text-lg-end">
        <ul class="list-inline">
          <li class="list-inline-item">Copyright (c) All Right Reserved.</li>
        </ul>
      </div>
    </div>
  </div>
</footer>

    

<script async
  src="/js/app.19b73e0182301dd61c9211c2f6890104740e2eb9eb12fe4ba8d4f31435b22ed6.js"
  integrity="sha256-Gbc&#43;AYIwHdYckhHC9okBBHQOLrnrEv5LqNTzFDWyLtY=">
</script>





<script async
  src="/js/flexsearch.5dd6433c29c3e043627f046054aed58ff3790f58fdb8423f45125bbafdcad335.js"
  integrity="sha256-XdZDPCnD4ENifwRgVK7Vj/N5D1j9uEI/RRJbuv3K0zU=">
</script>
<script async
  src="/js/search-modal.96e662d8f691fe25c859a3437074b485f2d7bed0bca612725028c6cf4322e2f2.js"
  integrity="sha256-luZi2PaR/iXIWaNDcHS0hfLXvtC8phJyUCjGz0Mi4vI=">
</script>

    <div class="d-inline-flex fixed-bottom-right pb-4 pe-4">
  <button id="toTop" type="button" class="btn btn-primary rounded-circle ms-auto p-2"><span class="visually-hidden">Top</span><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-up" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M6 15l6 -6l6 6"></path></svg></button>
</div>

    
  </body>
</html>
