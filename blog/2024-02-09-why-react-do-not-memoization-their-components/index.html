<!doctype html>
<html lang="ko" data-bs-theme="auto">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><link rel="preload" href="https://mycodingshub.github.io/fonts/vendor/jost/jost-v4-latin-regular.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="https://mycodingshub.github.io/fonts/vendor/jost/jost-v4-latin-500.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="https://mycodingshub.github.io/fonts/vendor/jost/jost-v4-latin-700.woff2" as="font" type="font/woff2" crossorigin>
<script 
  src="/js/color-mode.86a91f050a481d0a3f0c72ac26543cb6228c770875981c58dcbc008fd3f875c8.js"
  integrity="sha256-hqkfBQpIHQo/DHKsJlQ8tiKMdwh1mBxY3LwAj9P4dcg=">
</script>


<link rel="stylesheet" href="/main.86b7305f5a96b7dd3a46fa6277d87b125af3bf13f48c4cfcc269be84fa9e8fb75375d45a5fe9056ce9190644b7a6e5f13f917f12d853ed38bb76d8856898f755.css" integrity="sha512-hrcwX1qWt906Rvpid9h7ElrzvxP0jEz8wmm+hPqej7dTddRaX+kFbOkZBkS3puXxP5F/EthT7Ti7dtiFaJj3VQ==" crossorigin="anonymous">

<noscript><style>img.lazyload { display: none; }</style></noscript><title>왜 React는 기본적으로 Component를 메모(memo)화하지 않는 걸까?</title>
<meta name="description" content="왜 React는 기본적으로 Component를 메모(memo)화하지 않는 걸까?" />
<link rel="canonical" href="https://mycodingshub.github.io/blog/2024-02-09-why-react-do-not-memoization-their-components/" />
<meta name="robots" content="index, follow" />

<meta property="og:type" content="article" />
<meta property="og:title" content="왜 React는 기본적으로 Component를 메모(memo)화하지 않는 걸까?" />
<meta property="og:description" content="왜 React는 기본적으로 Component를 메모(memo)화하지 않는 걸까?" />
<meta property="og:url" content="https://mycodingshub.github.io/blog/2024-02-09-why-react-do-not-memoization-their-components/" />
<meta property="og:site_name" content="Home" />
<meta property="og:image" content="https://mycodingshub.github.io/cover.png" />
<meta property="og:locale" content="en" />
<meta property="article:published_time" content="2024-02-09T02:51:09Z" />
<meta property="article:modified_time" content="2024-02-09T02:51:09Z" />
<meta property="article:tag" content="react" />
<meta property="article:tag" content="memo" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:title" content="왜 React는 기본적으로 Component를 메모(memo)화하지 않는 걸까?" />
<meta name="twitter:description" content="왜 React는 기본적으로 Component를 메모(memo)화하지 않는 걸까?" />
<meta name="twitter:image" content="https://mycodingshub.github.io/cover.png" />

<meta name="author" content="cpro95@gmail.com" />

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "\"왜 React는 기본적으로 Component를 메모(memo)화하지 않는 걸까?\"",
  "description": "\"왜 React는 기본적으로 Component를 메모(memo)화하지 않는 걸까?\"",
  "datePublished": "\"2024-02-09T02:51:09Z\"",
  "dateModified": "\"2024-02-09T02:51:09Z\"",
  "author": {
    "@type": "Person",
    "name": "\"cpro95@gmail.com\""
  },
  "image": "\"https://mycodingshub.github.io/cover.png\"",
  "url": "\"https://mycodingshub.github.io/blog/2024-02-09-why-react-do-not-memoization-their-components/\"",
  "publisher": {
    "@type": "Organization",
    "name": "\"Home\""
  }
}
</script>




<script async src="https://www.googletagmanager.com/gtag/js?id=G-C7SBETWEJ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-C7SBETWEJ0');
</script>


<script
  async
  src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7748316956330968"
  crossOrigin="anonymous"
></script>


</head>

  
  <body class="single section blog" data-bs-spy="scroll" data-bs-target="#toc" data-bs-root-margin="0px 0px -60%" data-bs-smooth-scroll="true" tabindex="0">
    <div class="sticky-top">
<header class="navbar navbar-expand-sm">
  <div class="container-lg">
  <div class="d-flex flex-grow-1 justify-content-between">
    <div class="d-flex flex-row navbar-nav justify-content-between align-items-start gap-2">
    
    <a class="nav-link fw-bold fs-4" href="/">Home</a>

    
    
            <a class="nav-link fs-4  active" href="https://mycodingshub.github.io/blog/" aria-current="true">Blog</a>
          
        
            <a class="nav-link fs-4 " href="https://mycodingshub.github.io/life/">Life</a>
          
        
    </div>
    <div class="d-flex flex-row justify-content-between align-items-center">
      
      
      <button type="button" id="searchToggleMobile" class="btn btn-link nav-link mx-2 d-lg-none" aria-label="Search website">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
          <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
          <circle cx="10" cy="10" r="7"></circle>
          <line x1="21" y1="21" x2="15" y2="15"></line>
        </svg>
      </button>
      
      
      <button type="button" id="searchToggleDesktop" class="btn btn-link nav-link p-2 d-none d-lg-block" aria-label="Search website">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
          <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
          <circle cx="10" cy="10" r="7"></circle>
          <line x1="21" y1="21" x2="15" y2="15"></line>
        </svg>
      </button>
      
      <button id="buttonColorMode" class="btn btn-link mx-auto nav-link p-0 ms-lg-2 me-lg-1" type="button" aria-label="Toggle theme">
        <svg data-bs-theme-value="dark" xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-moon" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
          <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
          <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
        </svg>
        <svg data-bs-theme-value="light" xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-sun" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
          <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
          <path d="M12 12m-4 0a4 4 0 1 0 8 0a4 4 0 1 0 -8 0m-5 0h1m8 -9v1m8 8h1m-9 8v1m-6.4 -15.4l.7 .7m12.1 -.7l-.7 .7m0 11.4l.7 .7m-12.1 -.7l-.7 .7"></path>
        </svg>
      </button>
      </div>
        
        
        
        
        </div>
    </div>

    
    </div>
</header>
</div>

<div class="modal" id="searchModal" tabindex="-1" aria-labelledby="searchModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-fullscreen-md-down">
    <div class="modal-content">
      <div class="modal-header">
        <h1 class="modal-title fs-5 visually-hidden" id="searchModalLabel">Search</h1>
        <button type="button" class="btn-close visually-hidden" data-bs-dismiss="modal" aria-label="Close"></button>
        <div class="search-input flex-grow-1 d-none">
          <form id="search-form" class="search-form" action="#" method="post" accept-charset="UTF-8" role="search">
            <label for="query" class="visually-hidden">Search</label>
            <div class="d-flex">
              <input type="search" id="query" name="query" class="search-text form-control form-control-lg" placeholder="Search" aria-label="Search" maxlength="128" autocomplete="off">
              <button type="button" class="btn btn-link text-decoration-none px-0 ms-3 d-md-none" data-bs-dismiss="modal" aria-label="Close">Cancel</button>
            </div>
          </form>
        </div>
      </div>
      <div class="modal-body">
        <p class="search-loading status message d-none mt-3 text-center">Loading search index…</p>
        <p class="search-no-recent message d-none mt-3 text-center">No recent searches</p>
        <p class="search-no-results message d-none mt-3 text-center">No results for "<strong><span class="query-no-results">Query here</span></strong>"</p>
        <div id="searchResults" class="search-results"></div>
        <template>
          <article class="search-result list-view">
            <div class="card my-3">
              <div class="card-body">
                <header>
                  <h2 class="h5 title title-submitted mb-0"><a class="stretched-link text-decoration-none text-reset" href="#">Title here</a></h2>
                  <div class="submitted d-none"><time class="created-date">Date here</time></div>
                </header>
                <div class="content">Summary here</div>
              </div>
            </div>
          </article>
        </template>
      </div>
      <div class="modal-footer">
        <ul class="list-inline me-auto d-none d-md-block">
          <li class="list-inline-item"><kbd class="me-2"><svg width="15" height="15" aria-label="Enter key" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M12 3.53088v3c0 1-1 2-2 2H4M7 11.53088l-3-3 3-3"></path></g></svg></kbd><span class="DocSearch-Label">to select</span></li>
          <li class="list-inline-item"><kbd class="me-2"><svg width="15" height="15" aria-label="Arrow down" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M7.5 3.5v8M10.5 8.5l-3 3-3-3"></path></g></svg></kbd><kbd class="me-2"><svg width="15" height="15" aria-label="Arrow up" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M7.5 11.5v-8M10.5 6.5l-3-3-3 3"></path></g></svg></kbd><span class="DocSearch-Label">to navigate</span></li>
          <li class="list-inline-item"><kbd class="me-2"><svg width="15" height="15" aria-label="Escape key" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M13.6167 8.936c-.1065.3583-.6883.962-1.4875.962-.7993 0-1.653-.9165-1.653-2.1258v-.5678c0-1.2548.7896-2.1016 1.653-2.1016.8634 0 1.3601.4778 1.4875 1.0724M9 6c-.1352-.4735-.7506-.9219-1.46-.8972-.7092.0246-1.344.57-1.344 1.2166s.4198.8812 1.3445.9805C8.465 7.3992 8.968 7.9337 9 8.5c.032.5663-.454 1.398-1.4595 1.398C6.6593 9.898 6 9 5.963 8.4851m-1.4748.5368c-.2635.5941-.8099.876-1.5443.876s-1.7073-.6248-1.7073-2.204v-.4603c0-1.0416.721-2.131 1.7073-2.131.9864 0 1.6425 1.031 1.5443 2.2492h-2.956"></path></g></svg></kbd><span class="DocSearch-Label">to close</span></li>
        </ul>
        <p class="d-md-none">Search by <a class="text-decoration-none" href="https://github.com/nextapps-de/flexsearch">FlexSearch</a></p>
      </div>
    </div>
  </div>
</div>


    <div class="wrap container-lg" role="document">
      <div class="content">
      
        
<article>
  <div class="row justify-content-center">
    <div class="col-md-12 col-lg-12">
      
      <ins class="adsbygoogle"
        style="display:block"
        data-ad-client="ca-pub-7748316956330968"
        data-ad-slot="2971373181"
        data-ad-format="auto"
        data-full-width-responsive="true"></ins>
      <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
      </script>
      <div class="blog-header">
        <h1>왜 React는 기본적으로 Component를 메모(memo)화하지 않는 걸까?</h1>
        <p>
  <small>February 9, 2024<span class="stretched-link position-relative reading-time text-nowrap" title="Estimated reading time"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
        <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
        <path d="M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0"></path>
        <path d="M12 7v5l3 3"></path>
      </svg>9&nbsp;minutes</span></small>
</p>

      </div>
    </div>
      <div class="col-md-12 col-lg-12">
      
      <p>안녕하세요!</p>
<p>이번에는 React의 메모(memo)화에 대해 고민하다가 &lsquo;왜 React는 기본적으로 Component를 메모화하지 않는 걸까?&rsquo; 라는 의문을 해결하기 위해 여러 가지를 조사하고 생각한 내용을 정리해 보았습니다.</p>
<p>중간에 렌더링 타이밍이나, 메모(memo)화로 재렌더링을 억제하는 이유 등의 기본 지식 복습도 포함되어 있어서, 메모(memo)화에 대해 잘 모르시는 분들도 메모(memo)화에 대한 공부가 될 것 같은데요.</p>
<p>두서 없이 여기 저기 공부한 내용의 복습이라 아시는 분은 패스하시길 바랍니다.</p>
<p>** 목 차 **</p>
<ul>
<li>
<ol>
<li><a href="#1">서론</a>]</li>
</ol>
</li>
<li>
<ol start="2">
<li><a href="#ReactComponent">React의 Component는 언제 재렌더링되는가?</a></li>
</ol>
</li>
<li>
<ol start="3">
<li><a href="#ReactComponent-1">React의 Component가 재렌더링되는 타이밍</a></li>
</ol>
</li>
<li>
<ol start="4">
<li><a href="#React.memo">React.memo()를 통해 왜 재렌더링을 억제할 수 있는가?</a></li>
</ol>
</li>
<li>
<ol start="5">
<li><a href="#React.memo-1">React.memo()에 의해 재렌더링이 억제되는 이유</a></li>
</ol>
<ul>
<li>5.1. <a href="#ReactComponent-2">React의 Component가 재렌더링되는 타이밍</a></li>
<li>5.2. <a href="#React.memo-2">React.memo()에 의해 재렌더링이 억제되는 이유</a></li>
</ul>
</li>
<li>
<ol start="6">
<li><a href="#Component">Component를 메모화할지의 판단 기준</a></li>
</ol>
</li>
<li>
<ol start="7">
<li><a href="#propsComponent">props에 변경이 없어도 재렌더링하길 원하는 Component는 존재하는가?</a></li>
</ol>
</li>
<li>
<ol start="8">
<li><a href="#Componentmemo">거의 모든 Component는 메모(memo)화하는 것이 좋은가?</a></li>
</ol>
</li>
<li>
<ol start="9">
<li><a href="#ReactComponent-3">왜 React는 기본적으로 Component를 메모화하지 않는가?</a></li>
</ol>
</li>
<li>
<ol start="10">
<li><a href="#React">React의 소스 코드를 살펴보자</a></li>
</ol>
</li>
<li>
<ol start="11">
<li><a href="#2">결론</a></li>
</ol>
</li>
<li>
<ol start="12">
<li><a href="#3">실제 속도 차이는?</a></li>
</ol>
</li>
<li>
<ol start="13">
<li><a href="#RecordTupleComponent">Record＆Tuple이 도입되면, 표준으로 Component가 메모화될 수도 있을까?</a></li>
</ol>
</li>
</ul>
<hr>
<h2 id="1-서론">1. <a name="1"></a>서론</h2>
<p>왜 이런 의문을 가지게 되었는가?</p>
<p>먼저, 제가 제목에 있는 의문을 가지게 된 배경입니다.</p>
<p>의문을 가지게 된 생각의 과정은 이런 식입니다.</p>
<ol>
<li>&lsquo;재렌더링이 불필요하게 많이 일어나서 화면이 무거워져서 결론적으로 최적화하고 싶다&rsquo;</li>
<li>&lsquo;React.memo()를 사용해서 Component를 메모(memo)화하자!&rsquo;</li>
<li>&lsquo;Component마다 메모(memo)화할지 말지 고민하는 게 귀찮다.&rsquo;</li>
<li>&lsquo;계속 고민하는 것도 귀찮으니까, 그냥 모두 메모(memo)화하면 되지 않을까?&rsquo;</li>
<li>&lsquo;그리고 메모(memo)화하면 문제가 되는 Component 같은 건 없는 것 같은데?&rsquo;</li>
<li>&lsquo;그럼 왜 React는 기본적으로 모든 Component를 메모(memo)화하지 않는 걸까?&rsquo;</li>
</ol>
<p>간단히 말하자면, &lsquo;React.memo()를 사용하면 성능이 향상되고, 메모화하면 문제가 되는 Component 같은 건 없는 것 같으니, 왜 기본적으로 메모화하지 않는 걸까?&rsquo;
입니다.</p>
<p>그래서, React.memo()에 대해 여러 가지를 공부한 것을 토대로 주제에 공부를 진행해 볼까 합니다.</p>
<p>먼저, 기본 지식의 복습을 위해,</p>
<ol>
<li>React Component는 언제 재렌더링되는 건가?</li>
<li>React.memo()에 의해 왜 재렌더링을 억제할 수 있는 건가?</li>
</ol>
<p>라는 물음에 대해 간단하게 알아보고 진행하려 합니다.</p>
<hr>
<h2 id="2-react의-component는-언제-재렌더링되는가">2. <a name='ReactComponent'></a>React의 Component는 언제 재렌더링되는가?</h2>
<p>일반적으로, React의 Component가 재렌더링되는 타이밍은 아래와 같습니다.</p>
<ul>
<li>부모 Component가 재렌더링될 때</li>
<li>state가 업데이트될 때</li>
<li>useState의 setter가 실행될 때</li>
<li>useReducer의 dispatch()가 실행될 때</li>
<li>Class Component의 this.setState()가 실행될 때</li>
</ul>
<p>구글에서 &ldquo;React　render는 언제 일어나는가?&ldquo;라고 검색하면, 대부분의 자료에서는 props가 업데이트될 때도 React가 재렌더링된다고 합니다. 하지만 이 같은 경우는 앞으로 설명할 메모화된 Component에만 해당됩니다.</p>
<p>React는 부모 Component가 재렌더링될 때에, 조건 없이 모든 자식 Component를 재렌더링하기 때문에, props가 업데이트되었는지 여부를 확인하지 않습니다.</p>
<p>여기서 잠깐 재미난 테스트를 진행해 볼까 합니다.</p>
<p>만약 같은 값으로 setState()를 처리 했을 때 과연 React는 재렌더링되는가? 입니다.</p>
<p>잠깐 삼천포로 빠지는 감도 없지는 않지만, state를 변경하기 전의 값과 같은 값으로 setState()를 처리 했을 때 재렌더링이 일어나는지 한 번 궁금할 수 있는데요.</p>
<p>정답은 바로 아래와 같습니다.</p>
<ul>
<li>state가 프리미티브일 경우 → 재렌더링되지 않음</li>
<li>state가 객체일 경우 → 동일한 객체라면 재렌더링되지 않음</li>
</ul>
<p>실제 React 소스코드에서는 state가 변경될 때 React 내부에서는 변경 전후의 state를 얕은 비교(shallow comparison)를 하고, 만약 같다면 재렌더링하지 않습니다.</p>
<p>예를 들어 useState의 setter를 실행하면, useReducer의 dispatch()와 같은 dispatchSetState()라는 함수가 실행되고, 그 안에서는 아래 코드와 같은 로직이 수행됩니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// react/packages/react-reconciler/src/ReactFiberHooks.new.js
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="nx">objectIs</span><span class="p">(</span><span class="nx">eagerState</span><span class="p">,</span> <span class="nx">currentState</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Fast path. We can bail out without scheduling React to re-render.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// It&#39;s still possible that we&#39;ll need to rebase this update later,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// if the Componentre-renders for a different reason and by that
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// time the reducer has changed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
  </figure>
</div>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// react/packages/shared/objectIs.js
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * inlined Object.is polyfill to avoid requiring consumers ship their own
</span></span></span><span class="line"><span class="cl"><span class="cm"> * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">is</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="nx">x</span> <span class="o">===</span> <span class="nx">y</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">x</span> <span class="o">!==</span> <span class="mi">0</span> <span class="o">||</span> <span class="mi">1</span> <span class="o">/</span> <span class="nx">x</span> <span class="o">===</span> <span class="mi">1</span> <span class="o">/</span> <span class="nx">y</span><span class="p">))</span> <span class="o">||</span> <span class="p">(</span><span class="nx">x</span> <span class="o">!==</span> <span class="nx">x</span> <span class="o">&amp;&amp;</span> <span class="nx">y</span> <span class="o">!==</span> <span class="nx">y</span><span class="p">)</span> <span class="c1">// eslint-disable-line no-self-compare
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">objectIs</span> <span class="o">=</span> <span class="k">typeof</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">is</span> <span class="o">===</span> <span class="s2">&#34;function&#34;</span> <span class="o">?</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">is</span> <span class="o">:</span> <span class="nx">is</span><span class="p">;</span></span></span></code></pre></div>
  </figure>
</div>
<p>위와 같이 얕은 비교를 하고, 같다면 return되어 처리가 멈추고, 재렌더링이 일어나지 않습니다.</p>
<p>(코드 중간의 주석에도 without schedulingReactto re-render라고 적혀 있네요!)</p>
<p>그래서 state가 프리미티브라면 같은 값을, 객체라면 동일한 객체를 변경 후의 state로 setter에 전달하여 실행해도, 재렌더링이 일어나지 않는 것을 확인할 수 있습니다.</p>
<p>반대로 말하면, 객체는 내부의 값이 완전히 같아도 다른 객체라면 state가 변경되었다고 인식되고, 재렌더링이 일어나므로 주의해야 합니다.</p>
<p><em><strong>객체의 얕은 비교 예시</strong></em></p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">kim</span> <span class="o">=</span> <span class="p">{</span><span class="nx">bar</span><span class="o">:</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;foo&#39;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">park</span> <span class="o">=</span> <span class="p">{</span><span class="nx">bar</span><span class="o">:</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;foo&#39;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">kim</span> <span class="o">===</span> <span class="nx">kim</span> <span class="c1">// -&gt; true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">kim</span> <span class="o">===</span> <span class="nx">park</span> <span class="c1">// -&gt; false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">kim</span> <span class="o">===</span> <span class="p">{</span><span class="nx">bar</span><span class="o">:</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;foo&#39;</span><span class="p">}</span> <span class="c1">// -&gt; false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">kim</span> <span class="o">===</span> <span class="p">{...</span><span class="nx">kim</span><span class="p">}</span> <span class="c1">// -&gt; false
</span></span></span></code></pre></div>
  </figure>
</div>
<hr>
<h2 id="3-react의-component가-재렌더링되는-타이밍">3. <a name='ReactComponent-1'></a>React의 Component가 재렌더링되는 타이밍</h2>
<p>다시 한번 상기하자면, React의 Component가 재렌더링되는 타이밍은 아래의 2가지입니다.</p>
<ol>
<li>부모 Component가 재렌더링될 때
<ul>
<li>props의 변경 여부를 확인하지 않고 무조건 재렌더링됨</li>
</ul>
</li>
<li>state가 업데이트될 때
<ul>
<li>변경 전과 변경 후의 state를 얕은 비교를 통하여 차이가 있을 때만</li>
</ul>
</li>
</ol>
<p>그럼 재렌더링되는 타이밍을 알았으니, React.memo()에 의해 재렌더링이 억제되는 이유를 알아 보겠습니다.</p>
<hr>
<h2 id="4-reactmemo를-통해-왜-재렌더링을-억제할-수-있는가">4. <a name='React.memo'></a>React.memo()를 통해 왜 재렌더링을 억제할 수 있는가?</h2>
<p>일단, React.memo()는 Component를 인자로 받아서 Component를 반환하는(즉, Component를 래핑하는) 함수입니다.
(이를 고차 Component라고도 합니다.)</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// React.memo로 래핑만 해도, Component는 메모화됩니다.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">MemoComponent</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">memo</span><span class="p">((</span><span class="nx">props</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// props를 사용한 처리
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">Users</span> <span class="o">/&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span></span></span></code></pre></div>
  </figure>
</div>
<p>React.memo()로 래핑된 Component는, 그 부모 Component가 재렌더링될 때 props의 변경을 확인하고 변경이 없다면, 재렌더링되지 않습니다.</p>
<p>또한 props의 비교 방법은 기본적으로 얕은 비교(shallow comparison)를 하지만, 사용자 정의 비교 함수를 React.memo()의 두 번째 인자로 전달함으로써, 비교 방법을 커스터마이즈할 수 있습니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">equalFunction</span> <span class="o">=</span> <span class="p">(</span><span class="nx">prevProps</span><span class="p">,</span> <span class="nx">nextProps</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 사용자 정의 비교 처리
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">MemoComponent</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">memo</span><span class="p">((</span><span class="nx">props</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// props를 사용한 처리
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">Users</span> <span class="o">/&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">},</span> <span class="nx">equalFunction</span><span class="p">)</span></span></span></code></pre></div>
  </figure>
</div>
<p>그러나 제가 지금까지 React를 공부했어도 React.memo() 함수에 비교 함수의 커스터마이즈까지 사용하는 경우는 거의 못 봤는데요.</p>
<p>그래서 이 글에서는 이후부터 Component를 메모화한다는 거는, 비교 함수의 커스터마이즈는 하지 않고 기본적인 얕은 비교에 의한 메모화를 칭하겠습니다.</p>
<p>참고로 props를 가지지 않는 Component도 React.memo()로 메모화할 수 있습니다.</p>
<p>원래 props가 없기 때문에, 메모화하면 부모 Component가 재렌더링되어도 전혀 재렌더링되지 않게 됩니다.</p>
<hr>
<h2 id="5-reactmemo에-의해-재렌더링이-억제되는-이유">5. <a name='React.memo-1'></a>React.memo()에 의해 재렌더링이 억제되는 이유</h2>
<p>그래서, React.memo()로 재렌더링이 억제되는 이유는 다음과 같습니다.</p>
<p>&lsquo;React.memo()로 래핑된 Component는, 부모 Component가 재렌더링되어도 props에 변경이 없는 경우에만 재렌더링되기 때문입니다.&rsquo;</p>
<hr>
<p>지금까지 예전에 배웠던 걸 다시 한번 정리해 봤는데요.</p>
<p>이 타이밍에 다시 한번 깔끔하게 정리해 보겠습니다.</p>
<h3 id="51-react의-component가-재렌더링되는-타이밍">5.1. <a name='ReactComponent-2'></a>React의 Component가 재렌더링되는 타이밍</h3>
<ol>
<li>부모 Component가 재렌더링될 때
<ul>
<li>props의 변경 여부를 확인하지 않고 무조건 재렌더링됨</li>
</ul>
</li>
<li>state가 업데이트될 때
<ul>
<li>변경 전과 변경 후의 state를 얕은 비교하여 차이가 있을 때만</li>
<li></li>
</ul>
</li>
</ol>
<h3 id="52-reactmemo에-의해-재렌더링이-억제되는-이유">5.2. <a name='React.memo-2'></a>React.memo()에 의해 재렌더링이 억제되는 이유</h3>
<ol>
<li>React.memo()로 래핑된 Component는, 부모 Component가 재렌더링되어도 변경 전후의 props를 얕은 비교하여 변경이 없는 경우에만 재렌더링됨</li>
</ol>
<p>그럼 여기서 다시 이글의 제목으로 다시 돌아가 보겠습니다.</p>
<p>&lsquo;왜 React는 기본적으로 Component를 메모(memo)화하지 않는 걸까?&rsquo;</p>
<p>당연히, 기본적으로 메모화되면 문제가 되는 Component가 있을 수도 있습니다.</p>
<p>그러므로 먼저 Component를 메모화할지의 판단을 먼저 고심하고, 그 후에 메모화해서는 안 되는 Component가 있는지를 생각하겠습니다.</p>
<hr>
<h2 id="6-component를-메모화할지의-판단-기준">6. <a name='Component'></a>Component를 메모화할지의 판단 기준</h2>
<p>메모화된 Component는, 부모 Component가 재렌더링되어도 props에 변경이 있을 때만 재렌더링됩니다.</p>
<p>따라서 Component를 메모화할지의 판단 기준은 아래 2가지로 생각할 수 있습니다.</p>
<ol>
<li>부모 Component의 재렌더링에 따라 props의 변경이 있을 때만 재렌더링하길 원하는 Component
<ul>
<li>⭕　메모화하는 것이 좋음</li>
</ul>
</li>
<li>부모 Component의 재렌더링에 따라 props의 변경이 없어도 재렌더링하길 원하는 Component
<ul>
<li>❌　메모화하면 안 됨</li>
</ul>
</li>
</ol>
<p>그렇다면 &lsquo;부모 Component의 재렌더링에 따라 props의 변경이 없어도 재렌더링하길 원하는 Component&rsquo;는 어떤 Component일까요?</p>
<hr>
<h2 id="7-props에-변경이-없어도-재렌더링하길-원하는-component는-존재하는가">7. <a name='propsComponent'></a>props에 변경이 없어도 재렌더링하길 원하는 Component는 존재하는가?</h2>
<p>간단하게 생각해보면, 부모 Component만 재렌더링되고 자식 Component가 재렌더링되지 않으면, 결과론적으로 자식 Component만 오래되어 가므로, 만약 표시하는 데이터의 최신성을 유지해야 하는 Component 등이라면 재렌더링하길 원하는 컴포넌트가 될 수 있습니다.</p>
<p>그러나 그 경우에는 최신성을 유지하는 책임은 자식 Component에 있습니다.</p>
<p>따라서 최신성을 부모 Component의 재렌더링 타이밍에 전적으로 맡기는 것은 조금 어려운 말이지만 책임의 분배에 있어서 올바르지 않다고 생각합니다.</p>
<p>이렇듯 여러 상황을 고려해봤지만, 올바른 책임 분배를 전제로 생각하면 해당되는 Component를 더 이상 추려낼 수 없을 거 같네요.</p>
<p>그러므로 개인적인 생각이지만 &lsquo;부모 Component의 재렌더링에 따라 props의 변경이 없어도 재렌더링하길 원하는 Component&rsquo;는 존재하지 않거나, 아니면 매우 특수한 용도의 Component일 것이라고 생각합니다.</p>
<hr>
<h2 id="8-거의-모든-component는-메모memo화하는-것이-좋은가">8. <a name='Componentmemo'></a>거의 모든 Component는 메모(memo)화하는 것이 좋은가?</h2>
<p>정리해 보자면 아래와 같습니다.</p>
<ol>
<li>부모 Component의 재렌더링에 따라 props의 변경이 있을 때만 재렌더링하길 원하는 Component
<ul>
<li>⭕　메모화하는 것이 좋음</li>
</ul>
</li>
<li>부모 Component의 재렌더링에 따라 props의 변경이 없어도 재렌더링하길 원하는 Component
<ul>
<li>❌　메모화하면 안 됨</li>
<li>용도가 존재하지 않거나, 아니면 매우 특수한 용도의 Component</li>
</ul>
</li>
</ol>
<p>여기서 너무 쉬운 판단일지 모르지만 제 생각으로는 거의 모든 Component는 메모(memo)화하는 것이 좋을 것 같다는 생각이 듭니다.</p>
<hr>
<h2 id="9-왜-react는-기본적으로-component를-메모화하지-않는가">9. <a name='ReactComponent-3'></a>왜 React는 기본적으로 Component를 메모화하지 않는가?</h2>
<p>예전에 Dan Abramov씨가 Component의 메모화에 대해 언급한 트윗이 있었는데요.</p>
<p>지금은 찾을 수 없지만요.</p>
<p>Component의 메모화에 대한 Dan씨의 견해는.</p>
<blockquote>
<p>메모화에 의한 얕은 비교(shallow comparison)의 부하는 props의 수에 비례하며, 결과적으로 재렌더링이 일어나는 경우에는 이 얕은 비교의 처리는 무의미하게 되며, 또한 많은 Component는 다른 props를 받기 때문에, 비교하는 것이 빠르다고 단정할 수 없는 것 같습니다.</p></blockquote>
<hr>
<h2 id="10-react의-소스-코드를-살펴보자">10. <a name='React'></a>React의 소스 코드를 살펴보자</h2>
<p>그럼 React의 소스 코드에서 메모화된 Component의 업데이트 처리가 어떻게 되어 있는지 살펴보겠습니다.</p>
<p>먼저 메모화된 Component를 업데이트하는 함수입니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// react/packages/react-reconciler/src/ReactFiberBeginWork.new.js
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">updateMemoComponent</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">　　　　<span class="nx">current</span><span class="o">:</span> <span class="nx">Fiber</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">workInProgress</span><span class="o">:</span> <span class="nx">Fiber</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">Component</span><span class="o">:</span> <span class="nx">any</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">nextProps</span><span class="o">:</span> <span class="nx">any</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">renderLanes</span><span class="o">:</span> <span class="nx">Lanes</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="o">:</span> <span class="kc">null</span> <span class="o">|</span> <span class="nx">Fiber</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">　　　　<span class="c1">// 생략
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">hasScheduledUpdateOrContext</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> 　　　　　　<span class="c1">// 이것은 defaultProps가 해결된 props일 것이며,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// current.memoizedProps와 달리 해결되지 않은 것입니다.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kr">const</span> <span class="nx">prevProps</span> <span class="o">=</span> <span class="nx">currentChild</span><span class="p">.</span><span class="nx">memoizedProps</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  　　　　<span class="c1">// 얕은 비교를 기본으로 한다
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  　　　　<span class="kd">let</span> <span class="nx">compare</span> <span class="o">=</span> <span class="nx">Component</span><span class="p">.</span><span class="nx">compare</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  　　　　<span class="nx">compare</span> <span class="o">=</span> <span class="nx">compare</span> <span class="o">!==</span> <span class="kc">null</span> <span class="o">?</span> <span class="nx">compare</span> <span class="o">:</span> <span class="nx">shallowEqual</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  　　　　<span class="k">if</span> <span class="p">(</span><span class="nx">compare</span><span class="p">(</span><span class="nx">prevProps</span><span class="p">,</span> <span class="nx">nextProps</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">current</span><span class="p">.</span><span class="nx">ref</span> <span class="o">===</span> <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">ref</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  　　　　　　　　<span class="k">return</span> <span class="nx">bailoutOnAlreadyFinishedWork</span><span class="p">(</span><span class="nx">current</span><span class="p">,</span> <span class="nx">workInProgress</span><span class="p">,</span>　<span class="nx">renderLanes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  　　　　<span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">　　　　<span class="c1">// React DevTools가 이 플래그를 읽습니다.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">flags</span> <span class="o">|=</span> <span class="nx">PerformedWork</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">newChild</span> <span class="o">=</span> <span class="nx">createWorkInProgress</span><span class="p">(</span><span class="nx">currentChild</span><span class="p">,</span> <span class="nx">nextProps</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nx">newChild</span><span class="p">.</span><span class="nx">ref</span> <span class="o">=</span> <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">ref</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">newChild</span><span class="p">.</span><span class="k">return</span> <span class="o">=</span> <span class="nx">workInProgress</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">child</span> <span class="o">=</span> <span class="nx">newChild</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">newChild</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
  </figure>
</div>
<p><code>compare = compare !== null ? compare : shallowEqual;</code>에서, React.memo()의 두 번째 인자로 전달된 사용자 정의 비교 함수가 있으면 그것을, 없으면 얕은 비교를 props를 비교하는 함수로 사용하고 있으며, compare(prevProps, nextProps) 함수에서 props를 비교하고 있습니다.</p>
<p>다음은 얕은 비교 함수입니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// react/packages/shared/shallowEqual.js
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Performs equality by iterating through keys on an object and returning false
</span></span></span><span class="line"><span class="cl"><span class="cm"> * when any key has values which are not strictly equal between the arguments.
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Returns true when the values of all keys are strictly equal.
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">shallowEqual</span><span class="p">(</span><span class="nx">objA</span><span class="o">:</span> <span class="nx">mixed</span><span class="p">,</span> <span class="nx">objB</span><span class="o">:</span> <span class="nx">mixed</span><span class="p">)</span><span class="o">:</span> <span class="kr">boolean</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">is</span><span class="p">(</span><span class="nx">objA</span><span class="p">,</span> <span class="nx">objB</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="k">typeof</span> <span class="nx">objA</span> <span class="o">!==</span> <span class="s1">&#39;object&#39;</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">    <span class="nx">objA</span> <span class="o">===</span> <span class="kc">null</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">    <span class="k">typeof</span> <span class="nx">objB</span> <span class="o">!==</span> <span class="s1">&#39;object&#39;</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">    <span class="nx">objB</span> <span class="o">===</span> <span class="kc">null</span>
</span></span><span class="line"><span class="cl">  <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">keysA</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">objA</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">keysB</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">objB</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">keysA</span><span class="p">.</span><span class="nx">length</span> <span class="o">!==</span> <span class="nx">keysB</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Test for A&#39;s keys different from B.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">keysA</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">currentKey</span> <span class="o">=</span> <span class="nx">keysA</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="o">!</span><span class="nx">hasOwnProperty</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">objB</span><span class="p">,</span> <span class="nx">currentKey</span><span class="p">)</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">      <span class="o">!</span><span class="nx">is</span><span class="p">(</span><span class="nx">objA</span><span class="p">[</span><span class="nx">currentKey</span><span class="p">],</span> <span class="nx">objB</span><span class="p">[</span><span class="nx">currentKey</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
  </figure>
</div>
<p><code>for (let i = 0; i &lt; keysA.length; i++)</code>에서 props의 수만큼 for문을 돌리고, is(objA[currentKey], objB[currentKey])에서 얕은 비교를 하고 있습니다.</p>
<p>정말로 props의 수에 비례하여 얕은 비교가 이루어지고 있습니다.</p>
<p>참고로 is()는 앞서 언급한 useState의 setter에서 state의 얕은 비교에도 사용되었던 함수입니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// react/packages/shared/objectIs.js
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">is</span><span class="p">(</span><span class="nx">x</span><span class="o">:</span> <span class="nx">any</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="nx">any</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="nx">x</span> <span class="o">===</span> <span class="nx">y</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">x</span> <span class="o">!==</span> <span class="mi">0</span> <span class="o">||</span> <span class="mi">1</span> <span class="o">/</span> <span class="nx">x</span> <span class="o">===</span> <span class="mi">1</span> <span class="o">/</span> <span class="nx">y</span><span class="p">))</span> <span class="o">||</span> <span class="p">(</span><span class="nx">x</span> <span class="o">!==</span> <span class="nx">x</span> <span class="o">&amp;&amp;</span> <span class="nx">y</span> <span class="o">!==</span> <span class="nx">y</span><span class="p">)</span> <span class="c1">// eslint-disable-line no-self-compare
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
  </figure>
</div>
<hr>
<h2 id="11-결론">11. <a name='2'></a>결론</h2>
<p>&lsquo;왜 React는 기본적으로 Component를 메모화하지 않는가?&lsquo;의 결론은, 바로 Dan씨가 트윗에서 말한 것처럼 아래와 같을겁니다.</p>
<ul>
<li>메모화에 의한 얕은 비교에 따른 부하가 props의 수에 비례한다.</li>
<li>결과적으로 재렌더링이 일어나는 경우에는 이 얕은 비교의 처리는 무의미하게 된다.</li>
<li>많은 Component는 다른 props를 받기 때문에, 비교하는 것이 빠르다고 단정할 수 없다.(얕은 비교가 무의미하게 되는 경우가 많다)</li>
</ul>
<p>아마도 위와 같기 때문에, 기본적으로 Component를 메모화하지 않는 것 같습니다.</p>
<p>메모화에 의해 성능이 악화될 가능성이 있기 때문에, 메모화할지 여부는 선택적으로 개발자에게 위임되어 있는 것입니다.</p>
<hr>
<h2 id="12-실제-속도-차이는">12. <a name='3'></a>실제 속도 차이는?</h2>
<p>얕은 비교(shallow comparison)의 부하는 재렌더링의 속도에 얼마나 영향을 미치는가?</p>
<p>보통 구글링을 통해 알아본 봐로는 props 갯수가 10,000개일 경우 메모(memo)화된 쪽이 압도적으로 10~30배 정도 재렌더링에 시간이 걸린다고 합니다.</p>
<p>props의 수를 1,000개로 줄이면, 차이가 3~5배 정도로 줄어든다고 합니다.</p>
<p>확실히 메모화된 Component가 재렌더링에 시간을 더 많이 소요하며, 또한 props의 수에 비례하여 소요 시간이 증가하는 거네요.</p>
<hr>
<h2 id="13-recordtuple이-도입되면-표준으로-component가-메모화될-수도-있을까">13. <a name='RecordTupleComponent'></a>Record＆Tuple이 도입되면, 표준으로 Component가 메모화될 수도 있을까?</h2>
<p>조금은 먼 얘기지만 Record＆Tuple이 도입되면, props의 수에 비례하지 않고 props를 비교할 수 있게 되므로, 표준으로 Component가 메모화되는 날이 올 수도 있습니다.(아직은 먼 얘기지만&hellip;)</p>
<p>Record와 Tuple은 각각</p>
<ul>
<li>Record: 객체와 같은 데이터 구조 <code>#{ x: 1, y: 2 }</code></li>
<li>Tuple: 배열과 같은 데이터 구조 <code>#[1, 2, 3, 4]</code></li>
</ul>
<p>이며, === 비교는 얕은 비교가 아닌 깊은 비교가 되므로, props의 각 속성마다 for문을 돌릴 필요가 없어지고, props의 수에 비례하지 않게 props의 비교가 가능해집니다.</p>
<p>Object와 Record의 === 비교 차이</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// Object
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">kim</span> <span class="o">=</span> <span class="p">{</span><span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">b</span><span class="o">:</span> <span class="mi">2</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">kim</span> <span class="o">===</span> <span class="p">{</span><span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">b</span><span class="o">:</span> <span class="mi">2</span><span class="p">}</span> <span class="c1">// -&gt; false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// Record
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">park</span> <span class="o">=</span> <span class="err">#</span><span class="p">{</span><span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">b</span><span class="o">:</span> <span class="mi">2</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">park</span> <span class="o">===</span> <span class="err">#</span><span class="p">{</span><span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">b</span><span class="o">:</span> <span class="mi">2</span><span class="p">}</span> <span class="c1">// -&gt; true
</span></span></span></code></pre></div>
  </figure>
</div>
<p>Record&amp;Tuple 얘기는 아직은 아니지만 먼 얘기네요.</p>
<p>그럼.</p>

      <div class="tag-list-single">
        <a class="btn btn-light" href="/tags/react/" role="button">react</a>
        <a class="btn btn-light" href="/tags/memo/" role="button">memo</a>
        </div>
      
      <ins class="adsbygoogle"
          style="display:block"
          data-ad-format="autorelaxed"
          data-ad-client="ca-pub-7748316956330968"
          data-ad-slot="4495825428"></ins>
      <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
      </script>
    </div>
  </div>
</article>

      
      </div>
    </div>
    
    
<div class="bg-light">
    <section class="section section-related container">
      <div class="row justify-content-center">
        <div class="col-md-12 col-lg-12">
          <h2 class="section-title text-center">Related posts</h2>
        </div>
      </div>
      <div class="row justify-content-center">
        <div class="col-lg-12">
          <div class="card">
              <div class="card-body">
                <article>
                  <h2 class="h3"><a class="stretched-link text-body" href="/blog/2024-12-29-nextjs-supabase-tutorial-1-making-template-and-omit-middleware/">Next.js 15, Supabase 강좌 1편. 유저 인증(Auth)을 위한 Next.js 15와 Supabase 템플릿 만들기</a></h2>
                  <p>nextjs</p>
                  <p>
  <small>December 29, 2024<span class="stretched-link position-relative reading-time text-nowrap" title="Estimated reading time"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
        <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
        <path d="M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0"></path>
        <path d="M12 7v5l3 3"></path>
      </svg>7&nbsp;minutes</span></small>
</p>
</article>
              </div>
            </div>
          <div class="card">
              <div class="card-body">
                <article>
                  <h2 class="h3"><a class="stretched-link text-body" href="/blog/2024-12-29-ssr-login-with-react-router-and-supabase/">React Router V7에서 서버사이드 렌더링(SSR) 방식으로 완벽하게 Supabase 로그인 구현하기</a></h2>
                  <p>Supabase의 로그인 부분을 클라이언트 사이드쪽 말고 서버사이드 렌더링 방식으로 구현해 봅시다.</p>
                  <p>
  <small>December 29, 2024<span class="stretched-link position-relative reading-time text-nowrap" title="Estimated reading time"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
        <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
        <path d="M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0"></path>
        <path d="M12 7v5l3 3"></path>
      </svg>7&nbsp;minutes</span></small>
</p>
</article>
              </div>
            </div>
          <div class="card">
              <div class="card-body">
                <article>
                  <h2 class="h3"><a class="stretched-link text-body" href="/blog/2024-12-28-react-router-v-7-supabase-user-auth-login-signup-logout/">React Router V7과 Supabase로 유저 가입, 로그인, 로그아웃(Auth) 구현하기</a></h2>
                  <p>React Router V7와 함께 Supabase의 User Auth 부분 즉, 로그인(로그아웃)을 구현해 보겠습니다.</p>
                  <p>
  <small>December 28, 2024<span class="stretched-link position-relative reading-time text-nowrap" title="Estimated reading time"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
        <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
        <path d="M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0"></path>
        <path d="M12 7v5l3 3"></path>
      </svg>11&nbsp;minutes</span></small>
</p>
</article>
              </div>
            </div>
          </div>
      </div>
    </section>
    <script src="https://utteranc.es/client.js"
      repo="cpro95/utterances_mycodings_fly_dev"
      issue-term="pathname"
      theme="github-light"
      label="blog-comment"
      crossorigin="anonymous"
    async>
    </script>
  </div>
  
    <footer class="footer text-muted">
  <div class="container-lg">
    <div class="row">
      <div class="col-lg-8 text-center text-lg-start">
        <ul class="list-inline">
          <li class="list-inline-item"><a class="text-muted" href="/about/">about</a></li>
        </ul>
      </div>
      <div class="col-lg-8 text-center text-lg-end">
        <ul class="list-inline">
          <li class="list-inline-item">Copyright (c) All Right Reserved.</li>
        </ul>
      </div>
    </div>
  </div>
</footer>

    

<script async
  src="/js/app.19b73e0182301dd61c9211c2f6890104740e2eb9eb12fe4ba8d4f31435b22ed6.js"
  integrity="sha256-Gbc&#43;AYIwHdYckhHC9okBBHQOLrnrEv5LqNTzFDWyLtY=">
</script>





<script async
  src="/js/flexsearch.5dd6433c29c3e043627f046054aed58ff3790f58fdb8423f45125bbafdcad335.js"
  integrity="sha256-XdZDPCnD4ENifwRgVK7Vj/N5D1j9uEI/RRJbuv3K0zU=">
</script>
<script async
  src="/js/search-modal.96e662d8f691fe25c859a3437074b485f2d7bed0bca612725028c6cf4322e2f2.js"
  integrity="sha256-luZi2PaR/iXIWaNDcHS0hfLXvtC8phJyUCjGz0Mi4vI=">
</script>

    <div class="d-inline-flex fixed-bottom-right pb-4 pe-4">
  <button id="toTop" type="button" class="btn btn-primary rounded-circle ms-auto p-2"><span class="visually-hidden">Top</span><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-up" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M6 15l6 -6l6 6"></path></svg></button>
</div>

    
  </body>
</html>
