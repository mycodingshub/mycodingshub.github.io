<!doctype html>
<html lang="ko" data-bs-theme="auto">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><link rel="preload" href="https://mycodingshub.github.io/fonts/vendor/jost/jost-v4-latin-regular.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="https://mycodingshub.github.io/fonts/vendor/jost/jost-v4-latin-500.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="https://mycodingshub.github.io/fonts/vendor/jost/jost-v4-latin-700.woff2" as="font" type="font/woff2" crossorigin>
<script 
  src="/js/color-mode.86a91f050a481d0a3f0c72ac26543cb6228c770875981c58dcbc008fd3f875c8.js"
  integrity="sha256-hqkfBQpIHQo/DHKsJlQ8tiKMdwh1mBxY3LwAj9P4dcg=">
</script>


<link rel="stylesheet" href="/main.86b7305f5a96b7dd3a46fa6277d87b125af3bf13f48c4cfcc269be84fa9e8fb75375d45a5fe9056ce9190644b7a6e5f13f917f12d853ed38bb76d8856898f755.css" integrity="sha512-hrcwX1qWt906Rvpid9h7ElrzvxP0jEz8wmm+hPqej7dTddRaX+kFbOkZBkS3puXxP5F/EthT7Ti7dtiFaJj3VQ==" crossorigin="anonymous">

<noscript><style>img.lazyload { display: none; }</style></noscript><title>Docker 강좌 2편. 실무에서 쓰이는 Docker 컨테이너 완벽 가이드</title>
<meta name="description" content="실무에서 쓰이는 Docker 컨테이너 완벽 가이드" />
<link rel="canonical" href="https://mycodingshub.github.io/blog/2024-04-06-docker-tutorial-docker-container-comprehensive-guide/" />
<meta name="robots" content="index, follow" />

<meta property="og:type" content="article" />
<meta property="og:title" content="Docker 강좌 2편. 실무에서 쓰이는 Docker 컨테이너 완벽 가이드" />
<meta property="og:description" content="실무에서 쓰이는 Docker 컨테이너 완벽 가이드" />
<meta property="og:url" content="https://mycodingshub.github.io/blog/2024-04-06-docker-tutorial-docker-container-comprehensive-guide/" />
<meta property="og:site_name" content="Home" />
<meta property="og:image" content="https://mycodingshub.github.io/cover.png" />
<meta property="og:locale" content="en" />
<meta property="article:published_time" content="2024-04-06T04:28:14Z" />
<meta property="article:modified_time" content="2024-04-06T04:28:14Z" />
<meta property="article:tag" content="docker" />
<meta property="article:tag" content="container" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:title" content="Docker 강좌 2편. 실무에서 쓰이는 Docker 컨테이너 완벽 가이드" />
<meta name="twitter:description" content="실무에서 쓰이는 Docker 컨테이너 완벽 가이드" />
<meta name="twitter:image" content="https://mycodingshub.github.io/cover.png" />

<meta name="author" content="cpro95@gmail.com" />

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "\"Docker 강좌 2편. 실무에서 쓰이는 Docker 컨테이너 완벽 가이드\"",
  "description": "\"실무에서 쓰이는 Docker 컨테이너 완벽 가이드\"",
  "datePublished": "\"2024-04-06T04:28:14Z\"",
  "dateModified": "\"2024-04-06T04:28:14Z\"",
  "author": {
    "@type": "Person",
    "name": "\"cpro95@gmail.com\""
  },
  "image": "\"https://mycodingshub.github.io/cover.png\"",
  "url": "\"https://mycodingshub.github.io/blog/2024-04-06-docker-tutorial-docker-container-comprehensive-guide/\"",
  "publisher": {
    "@type": "Organization",
    "name": "\"Home\""
  }
}
</script>




<script async src="https://www.googletagmanager.com/gtag/js?id=G-C7SBETWEJ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-C7SBETWEJ0');
</script>


<script
  async
  src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7748316956330968"
  crossOrigin="anonymous"
></script>


</head>

  
  <body class="single section blog" data-bs-spy="scroll" data-bs-target="#toc" data-bs-root-margin="0px 0px -60%" data-bs-smooth-scroll="true" tabindex="0">
    <div class="sticky-top">
<header class="navbar navbar-expand-sm">
  <div class="container-lg">
  <div class="d-flex flex-grow-1 justify-content-between">
    <div class="d-flex flex-row navbar-nav justify-content-between align-items-start gap-2">
    
    <a class="nav-link fw-bold fs-4" href="/">Home</a>

    
    
            <a class="nav-link fs-4  active" href="https://mycodingshub.github.io/blog/" aria-current="true">Blog</a>
          
        
            <a class="nav-link fs-4 " href="https://mycodingshub.github.io/life/">Life</a>
          
        
    </div>
    <div class="d-flex flex-row justify-content-between align-items-center">
      
      
      <button type="button" id="searchToggleMobile" class="btn btn-link nav-link mx-2 d-lg-none" aria-label="Search website">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
          <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
          <circle cx="10" cy="10" r="7"></circle>
          <line x1="21" y1="21" x2="15" y2="15"></line>
        </svg>
      </button>
      
      
      <button type="button" id="searchToggleDesktop" class="btn btn-link nav-link p-2 d-none d-lg-block" aria-label="Search website">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
          <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
          <circle cx="10" cy="10" r="7"></circle>
          <line x1="21" y1="21" x2="15" y2="15"></line>
        </svg>
      </button>
      
      <button id="buttonColorMode" class="btn btn-link mx-auto nav-link p-0 ms-lg-2 me-lg-1" type="button" aria-label="Toggle theme">
        <svg data-bs-theme-value="dark" xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-moon" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
          <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
          <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
        </svg>
        <svg data-bs-theme-value="light" xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-sun" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
          <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
          <path d="M12 12m-4 0a4 4 0 1 0 8 0a4 4 0 1 0 -8 0m-5 0h1m8 -9v1m8 8h1m-9 8v1m-6.4 -15.4l.7 .7m12.1 -.7l-.7 .7m0 11.4l.7 .7m-12.1 -.7l-.7 .7"></path>
        </svg>
      </button>
      </div>
        
        
        
        
        </div>
    </div>

    
    </div>
</header>
</div>

<div class="modal" id="searchModal" tabindex="-1" aria-labelledby="searchModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-fullscreen-md-down">
    <div class="modal-content">
      <div class="modal-header">
        <h1 class="modal-title fs-5 visually-hidden" id="searchModalLabel">Search</h1>
        <button type="button" class="btn-close visually-hidden" data-bs-dismiss="modal" aria-label="Close"></button>
        <div class="search-input flex-grow-1 d-none">
          <form id="search-form" class="search-form" action="#" method="post" accept-charset="UTF-8" role="search">
            <label for="query" class="visually-hidden">Search</label>
            <div class="d-flex">
              <input type="search" id="query" name="query" class="search-text form-control form-control-lg" placeholder="Search" aria-label="Search" maxlength="128" autocomplete="off">
              <button type="button" class="btn btn-link text-decoration-none px-0 ms-3 d-md-none" data-bs-dismiss="modal" aria-label="Close">Cancel</button>
            </div>
          </form>
        </div>
      </div>
      <div class="modal-body">
        <p class="search-loading status message d-none mt-3 text-center">Loading search index…</p>
        <p class="search-no-recent message d-none mt-3 text-center">No recent searches</p>
        <p class="search-no-results message d-none mt-3 text-center">No results for "<strong><span class="query-no-results">Query here</span></strong>"</p>
        <div id="searchResults" class="search-results"></div>
        <template>
          <article class="search-result list-view">
            <div class="card my-3">
              <div class="card-body">
                <header>
                  <h2 class="h5 title title-submitted mb-0"><a class="stretched-link text-decoration-none text-reset" href="#">Title here</a></h2>
                  <div class="submitted d-none"><time class="created-date">Date here</time></div>
                </header>
                <div class="content">Summary here</div>
              </div>
            </div>
          </article>
        </template>
      </div>
      <div class="modal-footer">
        <ul class="list-inline me-auto d-none d-md-block">
          <li class="list-inline-item"><kbd class="me-2"><svg width="15" height="15" aria-label="Enter key" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M12 3.53088v3c0 1-1 2-2 2H4M7 11.53088l-3-3 3-3"></path></g></svg></kbd><span class="DocSearch-Label">to select</span></li>
          <li class="list-inline-item"><kbd class="me-2"><svg width="15" height="15" aria-label="Arrow down" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M7.5 3.5v8M10.5 8.5l-3 3-3-3"></path></g></svg></kbd><kbd class="me-2"><svg width="15" height="15" aria-label="Arrow up" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M7.5 11.5v-8M10.5 6.5l-3-3-3 3"></path></g></svg></kbd><span class="DocSearch-Label">to navigate</span></li>
          <li class="list-inline-item"><kbd class="me-2"><svg width="15" height="15" aria-label="Escape key" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M13.6167 8.936c-.1065.3583-.6883.962-1.4875.962-.7993 0-1.653-.9165-1.653-2.1258v-.5678c0-1.2548.7896-2.1016 1.653-2.1016.8634 0 1.3601.4778 1.4875 1.0724M9 6c-.1352-.4735-.7506-.9219-1.46-.8972-.7092.0246-1.344.57-1.344 1.2166s.4198.8812 1.3445.9805C8.465 7.3992 8.968 7.9337 9 8.5c.032.5663-.454 1.398-1.4595 1.398C6.6593 9.898 6 9 5.963 8.4851m-1.4748.5368c-.2635.5941-.8099.876-1.5443.876s-1.7073-.6248-1.7073-2.204v-.4603c0-1.0416.721-2.131 1.7073-2.131.9864 0 1.6425 1.031 1.5443 2.2492h-2.956"></path></g></svg></kbd><span class="DocSearch-Label">to close</span></li>
        </ul>
        <p class="d-md-none">Search by <a class="text-decoration-none" href="https://github.com/nextapps-de/flexsearch">FlexSearch</a></p>
      </div>
    </div>
  </div>
</div>


    <div class="wrap container-lg" role="document">
      <div class="content">
      
        
<article>
  <div class="row justify-content-center">
    <div class="col-md-12 col-lg-12">
      
      <ins class="adsbygoogle"
        style="display:block"
        data-ad-client="ca-pub-7748316956330968"
        data-ad-slot="2971373181"
        data-ad-format="auto"
        data-full-width-responsive="true"></ins>
      <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
      </script>
      <div class="blog-header">
        <h1>Docker 강좌 2편. 실무에서 쓰이는 Docker 컨테이너 완벽 가이드</h1>
        <p>
  <small>April 6, 2024<span class="stretched-link position-relative reading-time text-nowrap" title="Estimated reading time"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
        <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
        <path d="M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0"></path>
        <path d="M12 7v5l3 3"></path>
      </svg>20&nbsp;minutes</span></small>
</p>

      </div>
    </div>
      <div class="col-md-12 col-lg-12">
      
      <p>안녕하세요?</p>
<p>두번째 Docker 강좌입니다.</p>
<p>전체적인 강좌 리스트입니다.</p>
<ol>
<li>
<p><a href="https://mycodingshub.github.io/blog/2024-04-06-docker-tutorial-understanding-virtualization-and-docker">Docker 강좌 1편. 가상화와 Docker 기초 개념 이해하기</a></p>
</li>
<li>
<p><a href="https://mycodingshub.github.io/blog/2024-04-06-docker-tutorial-docker-container-comprehensive-guide">Docker 강좌 2편. 실무에서 쓰이는 Docker 컨테이너 완벽 가이드</a></p>
</li>
<li>
<p><a href="https://mycodingshub.github.io/blog/2024-04-06-docker-tutorial-understanding-docker-image-and-dockerfile">Docker 강좌 3편. Docker 이미지 및 Dockerfile 기초</a></p>
</li>
<li>
<p><a href="https://mycodingshub.github.io/blog/2024-04-06-docker-volume-usage-and-principles">Docker 강좌 4편. Docker 볼륨 (Volume) 사용 방법과 원리</a></p>
</li>
<li>
<p><a href="https://mycodingshub.github.io/blog/2024-04-06-docker-tutorial-understanding-bind-mount-and-port-publish">Docker 강좌 5편. Docker 바인드 마운트와 포트 publish</a></p>
</li>
<li>
<p><a href="https://mycodingshub.github.io/blog/2024-04-06-docker-tutorial-docker-compose-complete-guide">Docker 강좌 6편. Docker Compose 완벽 가이드</a></p>
</li>
</ol>
<hr>
<p>** 목 차 **</p>
<ul>
<li><a href="#%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88%ec%9d%98-%ea%b8%b0%ec%b4%88">컨테이너의 기초</a>
<ul>
<li><a href="#%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88-%ec%8b%a4%ed%96%89---container-run">컨테이너 실행 - container run</a></li>
<li><a href="#%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88-%eb%aa%a9%eb%a1%9d-%ed%99%95%ec%9d%b8---container-ls">컨테이너 목록 확인 - container ls</a>
<ul>
<li><a href="#%ec%98%b5%ec%85%98-%ec%84%a4%eb%aa%85">옵션 설명:</a></li>
</ul>
</li>
<li><a href="#%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88-%ec%a4%91%ec%a7%80---container-stop">컨테이너 중지 - container stop</a></li>
<li><a href="#%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88-%ec%82%ad%ec%a0%9c---container-rm">컨테이너 삭제 - container rm</a>
<ul>
<li><a href="#%ec%98%b5%ec%85%98-%ec%84%a4%eb%aa%85-1">옵션 설명:</a></li>
</ul>
</li>
<li><a href="#%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88-%ec%8b%a4%ed%96%89">컨테이너 실행</a></li>
<li><a href="#%ec%8b%a4%ed%96%89-%ec%a4%91%ec%9d%b8-%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88-%eb%aa%a9%eb%a1%9d-%ed%99%95%ec%9d%b8">실행 중인 컨테이너 목록 확인</a></li>
<li><a href="#%ec%8b%a4%ed%96%89-%ec%a4%91%ec%9d%b8-%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88-%ec%a4%91%ec%a7%80">실행 중인 컨테이너 중지</a></li>
<li><a href="#%eb%aa%a8%eb%93%a0-%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88-%eb%aa%a9%eb%a1%9d-%ed%99%95%ec%9d%b8">모든 컨테이너 목록 확인</a></li>
<li><a href="#%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88-%ec%82%ad%ec%a0%9c">컨테이너 삭제</a></li>
<li><a href="#%ec%8b%a4%ed%96%89-%ec%a4%91%ec%9d%b8-%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88%eb%a5%bc-%ec%a4%91%ec%a7%80%ed%95%98%ec%a7%80-%ec%95%8a%ea%b3%a0-%eb%b0%94%eb%a1%9c-%ec%82%ad%ec%a0%9c%ed%95%98%ea%b8%b0">실행 중인 컨테이너를 중지하지 않고 바로 삭제하기</a></li>
<li><a href="#%ec%a0%95%ec%a7%80%ed%95%a0-%ea%b2%83%ec%9d%b8%ec%a7%80-%ec%82%ad%ec%a0%9c%ed%95%a0-%ea%b2%83%ec%9d%b8%ec%a7%80"><strong>정지</strong>할 것인지 <strong>삭제</strong>할 것인지</a></li>
<li><a href="#%ec%9a%94%ec%95%bd">요약</a></li>
</ul>
</li>
<li><a href="#%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88-%ec%8b%9c%ec%9e%91-%ec%8b%9c-%ea%b8%b0%eb%b3%b8-%ec%98%b5%ec%85%98">컨테이너 시작 시 기본 옵션</a>
<ul>
<li><a href="#%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88-%ec%83%81%ed%98%b8%ec%9e%91%ec%9a%a9">컨테이너 상호작용</a></li>
<li><a href="#%eb%b0%b1%ea%b7%b8%eb%9d%bc%ec%9a%b4%eb%93%9c%ec%97%90%ec%84%9c-%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88%eb%a5%bc-%ec%8b%a4%ed%96%89%ed%95%98%ea%b8%b0">백그라운드에서 컨테이너를 실행하기</a></li>
<li><a href="#%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88%ea%b0%80-%ec%a4%91%ec%a7%80%eb%90%a0-%eb%95%8c-%ec%9e%90%eb%8f%99%ec%9c%bc%eb%a1%9c-%ec%82%ad%ec%a0%9c%ed%95%98%ea%b8%b0">컨테이너가 중지될 때 자동으로 삭제하기</a></li>
<li><a href="#%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88%ec%97%90-%ec%9d%b4%eb%a6%84%ec%9d%84-%ec%a7%80%ec%a0%95%ed%95%98%ea%b8%b0">컨테이너에 이름을 지정하기</a></li>
<li><a href="#%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88-%ec%8b%9c%ec%9e%91-%ec%8b%9c-%eb%8f%99%ec%9e%91-%eb%b3%80%ea%b2%bd%ed%95%98%ea%b8%b0">컨테이너 시작 시 동작 변경하기</a></li>
<li><a href="#%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88%ec%9d%98-os-%ec%95%84%ed%82%a4%ed%85%8d%ec%b2%98%eb%a5%bc-%ec%a7%80%ec%a0%95%ed%95%98%ea%b8%b0">컨테이너의 OS 아키텍처를 지정하기</a></li>
<li><a href="#%ec%9a%94%ec%95%bd-1">요약</a></li>
</ul>
</li>
<li><a href="#%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88-%ec%83%81%ed%83%9c-%eb%b3%80%ed%99%94">컨테이너 상태 변화</a>
<ul>
<li><a href="#%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88-%ec%83%81%ed%83%9c-%eb%b0%8f-%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4-%ec%9d%b4%ed%95%b4%ed%95%98%ea%b8%b0"><strong>컨테이너 상태 및 프로세스 이해하기</strong></a></li>
<li><a href="#%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88%ec%99%80-%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4"><strong>컨테이너와 프로세스</strong></a>
<ul>
<li><a href="#%ec%98%88%ec%a0%9c-1-ubuntu-%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88%eb%a5%bc-%ea%b8%b0%eb%b3%b8-%eb%aa%85%eb%a0%b9%ec%96%b4-bash%eb%a1%9c-%ec%8b%a4%ed%96%89"><strong>예제 1: Ubuntu 컨테이너를 기본 명령어 (bash)로 실행</strong></a></li>
<li><a href="#%ec%98%88%ec%a0%9c-2-nginx-%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88%eb%a5%bc-%ea%b8%b0%eb%b3%b8-%eb%aa%85%eb%a0%b9%ec%96%b4-nginx%eb%a1%9c-%ec%8b%a4%ed%96%89"><strong>예제 2: Nginx 컨테이너를 기본 명령어 (nginx)로 실행</strong></a></li>
<li><a href="#%ec%98%88%ec%a0%9c-3-nginx-%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88%eb%a5%bc-%ec%a7%80%ec%a0%95%ed%95%9c-%eb%aa%85%eb%a0%b9-bash%ec%9c%bc%eb%a1%9c-%ec%8b%a4%ed%96%89"><strong>예제 3: Nginx 컨테이너를 지정한 명령 (bash)으로 실행</strong></a></li>
</ul>
</li>
<li><a href="#%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88%ec%99%80-%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4%ec%9d%98-%ea%b4%80%ea%b3%84"><strong>컨테이너와 프로세스의 관계</strong></a></li>
<li><a href="#%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88%ea%b0%80-%ec%a2%85%eb%a3%8c%eb%90%98%eb%8a%94-%ea%b2%bd%ec%9a%b0"><strong>컨테이너가 종료되는 경우</strong></a>
<ul>
<li><a href="#1-%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88%eb%a5%bc-%ec%a7%81%ec%a0%91-%ec%a4%91%ec%a7%80%ed%95%98%eb%8a%94-%ea%b2%bd%ec%9a%b0">1. <strong>컨테이너를 직접 중지하는 경우</strong></a></li>
<li><a href="#2-%eb%a9%94%ec%9d%b8-%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4%ea%b0%80-%ec%a2%85%eb%a3%8c%eb%90%98%eb%8a%94-%ea%b2%bd%ec%9a%b0">2. <strong>메인 프로세스가 종료되는 경우</strong></a>
<ul>
<li><a href="#2-a-%ec%82%ac%ec%9a%a9%ec%9e%90%ea%b0%80-%eb%a9%94%ec%9d%b8-%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4%eb%a5%bc-%ec%a7%81%ec%a0%91-%ec%a2%85%eb%a3%8c%ed%95%98%eb%8a%94-%ea%b2%bd%ec%9a%b0">2-A. <strong>사용자가 메인 프로세스를 직접 종료하는 경우</strong></a></li>
<li><a href="#2-b-%eb%a9%94%ec%9d%b8-%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4%ea%b0%80-%ec%9e%90%eb%8f%99%ec%9c%bc%eb%a1%9c-%ec%a2%85%eb%a3%8c%eb%90%98%eb%8a%94-%ea%b2%bd%ec%9a%b0">2-B. <strong>메인 프로세스가 자동으로 종료되는 경우</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%ec%a6%89%ec%8b%9c-%ec%a4%91%ec%a7%80%ec%99%80-%eb%b0%b1%ea%b7%b8%eb%9d%bc%ec%9a%b4%eb%93%9c-%ec%8b%a4%ed%96%89%ec%97%90-%eb%8c%80%ed%95%98%ec%97%ac"><strong>즉시 중지와 백그라운드 실행에 대하여</strong></a></li>
<li><a href="#%ec%9a%94%ec%95%bd-2"><strong>요약</strong></a></li>
</ul>
</li>
<li><a href="#%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88-%ec%83%81%ed%83%9c-%ec%9c%a0%ec%a7%80">컨테이너 상태 유지</a>
<ul>
<li><a href="#1-%eb%8f%99%ec%9d%bc%ed%95%9c-%ec%9d%b4%eb%af%b8%ec%a7%80%ec%97%90%ec%84%9c-%ec%8b%9c%ec%9e%91%ed%95%98%eb%8d%94%eb%9d%bc%eb%8f%84-%eb%8b%a4%eb%a5%b8-%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88%ec%9e%85%eb%8b%88%eb%8b%a4">1. <strong>동일한 이미지에서 시작하더라도 다른 컨테이너입니다.</strong></a></li>
<li><a href="#2-%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88%ec%97%90%ec%84%9c-%ec%88%98%ed%96%89%ed%95%9c-%ec%9e%91%ec%97%85%ec%9d%80-%eb%8b%a4%eb%a5%b8-%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88%ec%97%90-%ec%98%81%ed%96%a5%ec%9d%84-%ec%a3%bc%ec%a7%80-%ec%95%8a%ec%8a%b5%eb%8b%88%eb%8b%a4">2. <strong>컨테이너에서 수행한 작업은 다른 컨테이너에 영향을 주지 않습니다.</strong></a></li>
<li><a href="#%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88%ec%97%90%ec%84%9c-%ec%88%98%ed%96%89%ed%95%9c-%ec%9e%91%ec%97%85%ec%9d%80-%eb%8b%a4%eb%a5%b8-%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88%ec%97%90-%ec%98%81%ed%96%a5%ec%9d%84-%ec%a3%bc%ec%a7%80-%ec%95%8a%ec%8a%b5%eb%8b%88%eb%8b%a4"><strong>컨테이너에서 수행한 작업은 다른 컨테이너에 영향을 주지 않습니다.</strong></a></li>
<li><a href="#%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88%ec%9d%98-%ec%83%81%ed%83%9c-%eb%b3%80%ea%b2%bd%ec%9d%84-%eb%8b%a4%eb%a5%b8-%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88%ec%97%90-%eb%b0%98%ec%98%81%ed%95%98%eb%a0%a4%eb%a9%b4">컨테이너의 상태 변경을 다른 컨테이너에 반영하려면</a></li>
<li><a href="#%ed%8c%8c%ec%9d%bc%ec%9d%84-%ec%9c%a0%ec%a7%80%ed%95%98%eb%a0%a4%eb%a9%b4-%ed%98%b8%ec%8a%a4%ed%8a%b8-%eb%a8%b8%ec%8b%a0%ea%b3%bc-%ea%b3%b5%ec%9c%a0%ed%95%98%ec%84%b8%ec%9a%94">파일을 유지하려면 호스트 머신과 공유하세요.</a></li>
<li><a href="#%ec%9a%94%ec%95%bd-3"><strong>요약</strong></a></li>
</ul>
</li>
<li><a href="#%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88%ec%97%90-%ec%97%b0%ea%b2%b0%ed%95%98%ea%b8%b0">컨테이너에 연결하기</a>
<ul>
<li><a href="#%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88-%eb%82%b4%ec%97%90%ec%84%9c-%eb%aa%85%eb%a0%b9-%ec%8b%a4%ed%96%89%ed%95%98%ea%b8%b0">컨테이너 내에서 명령 실행하기</a>
<ul>
<li><a href="#%ec%98%b5%ec%85%98-%ec%84%a4%eb%aa%85-2">옵션 설명</a></li>
</ul>
</li>
<li><a href="#%ec%8b%a4%ed%96%89-%ec%a4%91%ec%9d%b8-%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88%ec%97%90%ec%84%9c-%eb%aa%85%eb%a0%b9-%ec%8b%a4%ed%96%89%ed%95%98%ea%b8%b0">실행 중인 컨테이너에서 명령 실행하기</a></li>
<li><a href="#%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88%ec%97%90-%ec%97%b0%ea%b2%b0%ed%95%98%ea%b8%b0-1">컨테이너에 연결하기</a></li>
<li><a href="#%ec%b0%b8%ea%b3%a0-%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88%ec%97%90-ssh-%ec%97%b0%ea%b2%b0%ec%97%90-%eb%8c%80%ed%95%9c-%ec%98%a4%ed%95%b4">(참고) 컨테이너에 SSH 연결에 대한 오해</a></li>
<li><a href="#%ec%9a%94%ec%95%bd-4">요약</a></li>
</ul>
</li>
</ul>
<hr>
<h1 id="컨테이너의-기초">컨테이너의 기초</h1>
<p>컨테이너를 조작하는 몇 가지 명령어를 사용하여 컨테이너를 시작하고 중지할 수 있습니다.</p>
<p>명령어 목록을 외우는 것만으로는 이해도 향상에 어려움이 있습니다.</p>
<p>그럼에도 불구하고 기본적인 작업은 최소한 알아두어야 합니다.</p>
<p>이제 특정 용도에 따라 다르게 사용되는 Docker 기본 조작을 배워보겠습니다.</p>
<h2 id="컨테이너-실행---container-run">컨테이너 실행 - container run</h2>
<p>새로운 버전</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <pre tabindex="0"><code>$ docker container run [옵션] &lt;이미지&gt; [명령]</code></pre>
  </figure>
</div>
<p>예전 버전</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <pre tabindex="0"><code>$ docker run [옵션] &lt;이미지&gt; [명령]</code></pre>
  </figure>
</div>
<h2 id="컨테이너-목록-확인---container-ls">컨테이너 목록 확인 - container ls</h2>
<p>새로운 버전</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <pre tabindex="0"><code>$ docker container ls [옵션]</code></pre>
  </figure>
</div>
<p>예전 버전</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <pre tabindex="0"><code>$ docker ps [옵션]</code></pre>
  </figure>
</div>
<h3 id="옵션-설명">옵션 설명:</h3>
<ul>
<li><code>-a</code> 또는 <code>--all</code>: 모든 컨테이너 표시 (실행 중이지 않은 컨테이너 포함)</li>
</ul>
<h2 id="컨테이너-중지---container-stop">컨테이너 중지 - container stop</h2>
<p>새로운 버전</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <pre tabindex="0"><code>$ docker container stop [옵션] &lt;컨테이너&gt;</code></pre>
  </figure>
</div>
<p>예전 버전</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <pre tabindex="0"><code>$ docker stop [옵션] &lt;컨테이너&gt;</code></pre>
  </figure>
</div>
<h2 id="컨테이너-삭제---container-rm">컨테이너 삭제 - container rm</h2>
<p>새로운 버전</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <pre tabindex="0"><code>$ docker container rm [옵션] &lt;컨테이너&gt;</code></pre>
  </figure>
</div>
<p>예전 버전</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <pre tabindex="0"><code>$ docker rm [옵션] &lt;컨테이너&gt;</code></pre>
  </figure>
</div>
<h3 id="옵션-설명-1">옵션 설명:</h3>
<ul>
<li><code>-f</code> 또는 <code>--force</code>: 실행 중인 컨테이너 강제 삭제 (중지 및 삭제를 한 번에 수행)</li>
</ul>
<hr>
<h2 id="컨테이너-실행">컨테이너 실행</h2>
<p>Nginx라는 웹 서버를 <code>container run</code> 명령어를 사용하여 컨테이너로 실행해보겠습니다.</p>
<p>새로운 버전</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <pre tabindex="0"><code>$ docker container run [옵션] &lt;이미지&gt; [명령]</code></pre>
  </figure>
</div>
<p>예전 버전</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <pre tabindex="0"><code>$ docker run [옵션] &lt;이미지&gt; [명령]</code></pre>
  </figure>
</div>
<p>먼저 최소한의 옵션으로 컨테이너를 실행해 보겠습니다.</p>
<p>단순히 실행만 하고 싶으므로 <code>&lt;image&gt;</code>에는 <code>nginx</code>만 지정하겠습니다.</p>
<p>그러나 완전히 동작하지 않는 것은 재미가 없으므로 <code>--publish</code> 옵션만 추가하겠습니다.</p>
<p><code>--publish</code> 옵션을 사용하면 브라우저에서 확인할 수 있도록 웹 서버에 접근할 수 있습니다.</p>
<p>이에 대한 설명은 다음 시간에 &ldquo;포트&rdquo; 부분에서 다루겠습니다.</p>
<p>이를 바탕으로 다음 명령어로 컨테이너를 실행합니다:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <pre tabindex="0"><code>$ docker container run --publish 8080:80 nginx
Unable to find image &#39;nginx:latest&#39; locally
latest: Pulling from library/nginx
59f5764b1f6d: Pull complete
f7bd43626fa7: Pull complete
2df415630b2f: Pull complete
059f9f6918db: Pull complete
df91ff398a83: Pull complete
e75b854d63f1: Pull complete
4b88df8a13cd: Pull complete
Digest: sha256:6db391d1c0cfb30588ba0bf72ea999404f2764febf0f1f196acd5867ac7efa7e
Status: Downloaded newer image for nginx:latest
/docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration
/docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d/
/docker-entrypoint.sh: Launching /docker-entrypoint.d/10-listen-on-ipv6-by-default.sh
10-listen-on-ipv6-by-default.sh: info: Getting the checksum of /etc/nginx/conf.d/default.conf
10-listen-on-ipv6-by-default.sh: info: Enabled listen on IPv6 in /etc/nginx/conf.d/default.conf
/docker-entrypoint.sh: Sourcing /docker-entrypoint.d/15-local-resolvers.envsh
/docker-entrypoint.sh: Launching /docker-entrypoint.d/20-envsubst-on-templates.sh
/docker-entrypoint.sh: Launching /docker-entrypoint.d/30-tune-worker-processes.sh
/docker-entrypoint.sh: Configuration complete; ready for start up
2024/04/06 01:41:34 [notice] 1#1: using the &#34;epoll&#34; event method
2024/04/06 01:41:34 [notice] 1#1: nginx/1.25.4
2024/04/06 01:41:34 [notice] 1#1: built by gcc 12.2.0 (Debian 12.2.0-14)
2024/04/06 01:41:34 [notice] 1#1: OS: Linux 6.6.16-linuxkit
2024/04/06 01:41:34 [notice] 1#1: getrlimit(RLIMIT_NOFILE): 1048576:1048576
2024/04/06 01:41:34 [notice] 1#1: start worker processes
2024/04/06 01:41:34 [notice] 1#1: start worker process 28
2024/04/06 01:41:34 [notice] 1#1: start worker process 29
2024/04/06 01:41:34 [notice] 1#1: start worker process 30
2024/04/06 01:41:34 [notice] 1#1: start worker process 31
2024/04/06 01:41:34 [notice] 1#1: start worker process 32
2024/04/06 01:41:34 [notice] 1#1: start worker process 33
2024/04/06 01:41:34 [notice] 1#1: start worker process 34
2024/04/06 01:41:34 [notice] 1#1: start worker process 35</code></pre>
  </figure>
</div>
<p><code>[notice] 1#1: start worker processes</code> 메시지와 함께 터미널이 조작 불가능해지면 실행이 성공한 것입니다.</p>
<p>브라우저에서 http://localhost:8080에 접속해 보세요.</p>
<p>다음과 같은 화면이 나타나면 실행한 컨테이너의 웹 서버에 접근할 수 있습니다.</p>
<p>
  <figure>
    <img src="https://blogger.googleusercontent.com/img/a/AVvXsEgyaKuB7XysbB3I_o5Xdt595AVIV5OwsDrZl67U_TTepcDCPJE_5K4kauF6_WIUOfdwflMiVyo6lhPnK5KfMut5vklobU1zIJrgzp1lBJh0b6vpz8pZc6lPrlm69sNMVnL0c22UIwku66oAgbknqfNeMshpq9TncTkRYH2Jv8cTvGJdp8MVQn7uD5LHoq0"
         alt=""
         
         class="img-fluid"
         loading="lazy"
         decoding="async" />
    
  </figure></p>
<p>컨테이너 자체는 가상 서버가 아니지만, 실행한 컨테이너(격리 영역) 내에서 Nginx 웹 서버가 실행되고 있습니다.</p>
<p>이미지에서 컨테이너를 시작했으므로 현재 상황은 다음과 같이 나타낼 수 있습니다:</p>
<p>
  <figure>
    <img src="https://blogger.googleusercontent.com/img/a/AVvXsEji1BFKgHOGl9xbBhTaxZz4OaQaBPlXlCUN2InmIsjM8ntptAkjIgnsAI-FZpACuMPW_-EbofZMEf5iPGvKHkcNSzspk-bTUthmZGd98Gcj0Xy4s2gO8AeVF72e-7JhgAqZisLL-6X4DBPjGCHICyXSt3ATIp9AqTCdhDdyo7emHH17X6mntWZTSuQD-ug"
         alt=""
         
         class="img-fluid"
         loading="lazy"
         decoding="async" />
    
  </figure></p>
<hr>
<h2 id="실행-중인-컨테이너-목록-확인">실행 중인 컨테이너 목록 확인</h2>
<p>컨테이너 목록을 확인하려면 <code>container ls</code> 명령어를 사용합니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <pre tabindex="0"><code>$ docker container ls [옵션]</code></pre>
  </figure>
</div>
<p><code>container run</code>을 실행한 탭을 그대로 두고 새로운 탭을 열어 컨테이너 목록을 확인해 보겠습니다.</p>
<p>특별한 옵션을 지정하지 않아도 되므로 다음 명령어로 컨테이너 목록을 확인합니다:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <pre tabindex="0"><code>$ docker container ls</code></pre>
  </figure>
</div>
<p>다음과 같은 결과가 표시됩니다:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <pre tabindex="0"><code>CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS                  NAMES
f4032101bb8c   nginx     &#34;/docker-entrypoint.…&#34;   6 minutes ago   Up 6 minutes   0.0.0.0:8080-&gt;80/tcp   zen_pasteur</code></pre>
  </figure>
</div>
<p><code>IMAGE</code>가 <code>nginx</code>인 컨테이너가 하나 실행되었음을 확인할 수 있습니다.</p>
<p><code>CONTAINER ID</code>는 <code>f4032101bb8c</code>이며, <code>NAMES</code>는 <code>zen_pasteur</code>입니다.</p>
<p>여기서 <code>NAMES</code>는 컨테이너를 실행할 때마다 무작위로 할당됩니다.</p>
<p>컨테이너 목록을 확인한 후 <code>CONTAINER ID</code>가 <code>f4032101bb8c</code>인 상태를 다음과 같이 나타낼 수 있습니다:</p>
<p>
  <figure>
    <img src="https://blogger.googleusercontent.com/img/a/AVvXsEhgX5WrvK2IdLIsmndFnoj7eP36IOqhsH3EeRW0eWIIYRbj-QFK7TdTawdqNveRDk1RmpT2rpU84B8D_H85TxkP4gv5tz_gqStJKUEk5zPSEr3f5yEZcA8KL4XqlwNt7JZBmhqIikyPUCmWVgj0mKsXIiIHPQgGTUxy5kMx18vs8pHyURgS7wceWVR-QnQ"
         alt=""
         
         class="img-fluid"
         loading="lazy"
         decoding="async" />
    
  </figure></p>
<hr>
<h2 id="실행-중인-컨테이너-중지">실행 중인 컨테이너 중지</h2>
<p>Nginx를 사용한 작업이 끝나면 컨테이너를 중지하려면 <code>container stop</code> 명령어를 사용합니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <pre tabindex="0"><code>$ docker container stop [옵션] &lt;컨테이너&gt;</code></pre>
  </figure>
</div>
<p><code>container stop</code>에는 대부분의 경우 옵션이 필요하지 않으므로 대상 <code>&lt;컨테이너&gt;</code>를 CONTAINER ID 또는 NAMES로 지정하여 실행할 수 있습니다.</p>
<p>이를 바탕으로 다음 명령어로 컨테이너를 중지합니다.</p>
<p>(CONTAINER ID는 본인의 터미널에서 확인한 값입니다.)</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <pre tabindex="0"><code>$ docker container stop \
  f4032101bb8c</code></pre>
  </figure>
</div>
<p>컨테이너가 정상적으로 중지되면 더 이상 http://localhost:8080에 접속해도 아무 내용도 표시되지 않습니다.</p>
<p>실행 중인 컨테이너 목록을 확인해도 Nginx 컨테이너가 더 이상 표시되지 않습니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <pre tabindex="0"><code>$ docker container ls
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</code></pre>
  </figure>
</div>
<p>컨테이너가 실행 중이었지만 중지 명령을 받아 현재 상황은 다음과 같이 나타낼 수 있습니다:</p>
<p>
  <figure>
    <img src="https://blogger.googleusercontent.com/img/a/AVvXsEgU4YXFERcgT5FF-j9Uz64_sQgvMdHpLkxRjtOsjtg8JkhPEgs8P7epsoR7d2TkbHqUKtfSlgkyvnD7GebPs6qOyM8fF2V-tvVkfnZrN1d1rGNr6vFV9U2YUtBEUreevYWzpXjBZUppXKgZnPREaqHQySjmi8ttAKkjn2Zs83M5HvvKSWD9qAZMnWVNSIg"
         alt=""
         
         class="img-fluid"
         loading="lazy"
         decoding="async" />
    
  </figure></p>
<hr>
<h2 id="모든-컨테이너-목록-확인">모든 컨테이너 목록 확인</h2>
<p>컨테이너는 중지되어도 삭제되기 전까지 호스트 머신에 정보로 남아 있으며, 다시 시작할 수도 있습니다.</p>
<p>중지된 컨테이너를 포함하여 모든 컨테이너 목록을 확인하려면 <code>container ls</code>에 <code>--all</code> 또는 <code>-a</code> 옵션을 추가하여 실행합니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <pre tabindex="0"><code>$ docker container ls \
    --all</code></pre>
  </figure>
</div>
<p>다음과 같은 결과가 표시됩니다:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <pre tabindex="0"><code>docker container ls \
    --all
CONTAINER ID   IMAGE                             COMMAND                  CREATED          STATUS                     PORTS     NAMES
f4032101bb8c   nginx                             &#34;/docker-entrypoint.…&#34;   15 minutes ago   Exited (0) 5 minutes ago             zen_pasteur</code></pre>
  </figure>
</div>
<p><code>IMAGE</code>가 <code>nginx</code>인 컨테이너가 하나 실행되었음을 확인할 수 있습니다.</p>
<p><code>CONTAINER ID</code>는 <code>f4032101bb8c</code>이며, <code>NAMES</code>는 <code>zen_pasteur</code>입니다.</p>
<p>이는 컨테이너를 실행할 때마다 무작위로 할당됩니다.</p>
<p><code>--all</code> 옵션을 사용하지 않은 경우의 확인 범위는 다음과 같습니다:</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">docker container ls
</span></span><span class="line"><span class="cl">CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</span></span></code></pre></div>
  </figure>
</div>
<p><code>--all</code> 옵션을 사용한 경우의 확인 범위는 다음과 같이 나타낼 수 있습니다:</p>
<p>
  <figure>
    <img src="https://blogger.googleusercontent.com/img/a/AVvXsEhbArZiDUl64zQ7mZJxn8vAN1Nkeqe7cgPPMKVdJD36CYBSFk3KkZQwKroJDfBpIC2XCxGyjpe7mRfGtp7S8W820sHRDqdDIU2q8lXQm_5u1hYZjcICdYnC2JnMQH49Iy1mGu07MziBpl_ZbM4iksaxF7rvbP1YlISxltlRqwskMH4-ctLJc97fmnIA8eo"
         alt=""
         
         class="img-fluid"
         loading="lazy"
         decoding="async" />
    
  </figure></p>
<hr>
<h2 id="컨테이너-삭제">컨테이너 삭제</h2>
<p>컨테이너를 삭제하려면 <code>container rm</code>을 사용합니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <pre tabindex="0"><code>$ docker container rm [옵션] &lt;컨테이너&gt;</code></pre>
  </figure>
</div>
<p><code>container stop</code>과 마찬가지로 <code>&lt;컨테이너&gt;</code>를 지정하는 명령어이므로, <code>container ls</code>에서 확인한 CONTAINER ID를 사용하여 실행합니다. (CONTAINER ID는 본인의 터미널에서 확인한 값입니다.)</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <pre tabindex="0"><code>$ docker container rm \
    f4032101bb8c</code></pre>
  </figure>
</div>
<p>이제 컨테이너가 완전히 삭제되었습니다.</p>
<p>컨테이너 목록을 확인해도 더 이상 Nginx 컨테이너가 표시되지 않습니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <pre tabindex="0"><code>$ docker container ls \
    --all
CONTAINER ID   IMAGE                             COMMAND   CREATED      STATUS                  PORTS     NAMES</code></pre>
  </figure>
</div>
<p>컨테이너가 실행 중이었지만 중지 명령을 받아 현재 상황은 다음과 같이 나타낼 수 있습니다:</p>
<p>
  <figure>
    <img src="https://blogger.googleusercontent.com/img/a/AVvXsEg2Hcjap5m2sNIvT7Ppv7R_6_dj6oFk-zRuDtmwgo0G7JW1BlaJFi1HHNRx0_IziV5VKXIsMPralot7rAf5mtH8PP_5LKROTT45uw6uG2sNILCIPNzzTM0716BWRQU6cqiiS-xbFko6dPTqfxRjUXidKB0RMhMo1vw5eIyYFYoTUmcS-CvOWRcewCpQLK0"
         alt=""
         
         class="img-fluid"
         loading="lazy"
         decoding="async" />
    
  </figure></p>
<h2 id="실행-중인-컨테이너를-중지하지-않고-바로-삭제하기">실행 중인 컨테이너를 중지하지 않고 바로 삭제하기</h2>
<p><code>container stop</code>과 <code>container rm</code>을 다음 명령어로 한 번에 실행할 수 있습니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <pre tabindex="0"><code>$ docker container rm \
    --force           \
    &lt;컨테이너&gt;</code></pre>
  </figure>
</div>
<p>즉시 삭제할 의도로 중지된 컨테이너를 중지할 때 이 명령어를 사용하면 편리합니다.</p>
<p>중지된 컨테이너에 강제 삭제 명령을 내렸으므로 현재 상황은 다음과 같이 나타낼 수 있습니다:</p>
<p>
  <figure>
    <img src="https://blogger.googleusercontent.com/img/a/AVvXsEjaCoZxzWICvJ1m8JVEkus4j0vnJobtcwsqG6h78U-pDZBW2869K47FB5zIRvuz8Et_I8hNlpZw_VxadXavTXvgdZ-48FC0xXZft_2yhF7TELy_o8-9I_w2rLsdAH3ysT8kSs5SQp1tzR-7XjuDaAcLI85e3wvCHRM8ZQgkxWl1vJzyu2rTWOsutxvcpWA"
         alt=""
         
         class="img-fluid"
         loading="lazy"
         decoding="async" />
    
  </figure></p>
<h2 id="정지할-것인지-삭제할-것인지"><strong>정지</strong>할 것인지 <strong>삭제</strong>할 것인지</h2>
<p>&ldquo;<strong>정지된 컨테이너</strong>는 다시 시작할 수 있지만, 저는 거의 다시 시작을 하지 않습니다.&rdquo;</p>
<p>그래서 저는 <code>container stop</code>을 사용하지 않고 <code>container rm --force</code>를 사용하거나, 앞으로 배울 &ldquo;컨테이너 시작 시 기본 지정&quot;에서 설명하듯 <code>container run</code>의 <code>--rm</code> 옵션을 사용하여 컨테이너를 즉시 삭제합니다.</p>
<p>컨테이너는 가볍고 일회용이라는 컨셉이기 때문에 &ldquo;편하게 시작하고 작업이 끝나면 삭제하고, 다시 필요하면 다시 시작한다&quot;는 접근 방식이 간단하고 좋다고 생각합니다.</p>
<h2 id="요약">요약</h2>
<p>아래는 컨테이너 작업에 관한 간결한 요약입니다.</p>
<ul>
<li>컨테이너 시작: container run</li>
<li>컨테이너 목록 확인: container ls</li>
<li>실행 중인 컨테이너 정지: container stop</li>
<li>정지된 컨테이너 삭제: container rm</li>
<li>실행 중인 컨테이너 삭제: container rm &ndash;force</li>
</ul>
<hr>
<h1 id="컨테이너-시작-시-기본-옵션">컨테이너 시작 시 기본 옵션</h1>
<p>컨테이너를 시작하고 중지하는 방법을 이해했다면, 이제 <code>container run</code> 명령의 옵션에 대해 배워봅시다.</p>
<p>이 페이지에서는 특정 용도에 따라 사용되는 기본적인 작업에 대해 학습합니다.</p>
<p>이 페이지에서 처음 등장하는 명령과 옵션</p>
<ul>
<li><strong>컨테이너 시작하기 - <code>container run</code></strong>
<ul>
<li><code>-i</code> 또는 <code>--interactive</code>: 컨테이너의 표준 입력에 연결</li>
<li><code>-t</code> 또는 <code>--tty</code>: 가상 터미널 할당</li>
<li><code>-d</code> 또는 <code>--detach</code>: 백그라운드에서 실행</li>
<li><code>--rm</code>: 중지된 컨테이너 자동 삭제 (중복 정보 충돌 방지)</li>
<li><code>--name</code>: 컨테이너에 이름 지정 (쉽게 참조 가능)</li>
<li><code>--platform</code>: 이미지 아키텍처 명시 (M1 Mac에서 필요한 경우)</li>
</ul>
</li>
</ul>
<h2 id="컨테이너-상호작용">컨테이너 상호작용</h2>
<p>이전에 사용한 Nginx 컨테이너는 시작하면 Nginx가 실행되지만, Ubuntu 컨테이너는 시작하면 bash를 조작할 수 있습니다.</p>
<p>bash와 같은 상호작용이 필요한 경우 호스트 머신의 터미널 입력을 받기 위해 <code>--interactive</code> 옵션과 컨테이너의 가상 출력 장소를 만들기 위해 <code>--tty</code> 옵션이 필요합니다.</p>
<p>호스트 머신에서 다음과 같이 실행합니다.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker container run <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --interactive      <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --tty              <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    ubuntu:20.04</span></span></code></pre></div>
  </figure>
</div>
<p>Docker뿐만 아니라 Linux 명령의 옵션은 <code>-h</code> 또는 <code>--help</code>, <code>-v</code> 또는 <code>--version</code>과 같이 동일한 옵션을 짧게 또는 길게 지정할 수 있습니다.</p>
<p>짧은 옵션은 여러 개를 연속해서 지정할 수 있으며, 위의 명령은 이전 옵션과 결합하여 최소한으로 다음과 같이 실행할 수 있습니다.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker run -it ubuntu:20.04</span></span></code></pre></div>
  </figure>
</div>
<p>이 글에서는 명확하고 긴 새 명령을 사용하는 의도로 모든 옵션을 긴 형태로 지정합니다.</p>
<p>변경된 프롬프트는 Ubuntu 컨테이너의 bash입니다.</p>
<p>컨테이너는 가상 서버가 아닌 Docker에 의해 생성된 Linux의 네임스페이스입니다.</p>
<p>Docker를 통해 마치 다른 OS처럼 만들어져 OS 정보 등을 확인할 수 있습니다.</p>
<p>컨테이너에서 다음 명령으로 OS 정보를 확인할 수 있습니다.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># cat /etc/lsb-release</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">DISTRIB_ID</span><span class="o">=</span>Ubuntu
</span></span><span class="line"><span class="cl"><span class="nv">DISTRIB_RELEASE</span><span class="o">=</span>20.04
</span></span><span class="line"><span class="cl"><span class="nv">DISTRIB_CODENAME</span><span class="o">=</span>focal
</span></span><span class="line"><span class="cl"><span class="nv">DISTRIB_DESCRIPTION</span><span class="o">=</span><span class="s2">&#34;Ubuntu 20.04.3 LTS&#34;</span></span></span></code></pre></div>
  </figure>
</div>
<p>이후에는 $ 프롬프트를 호스트 머신, # 프롬프트를 컨테이</p>
<hr>
<h2 id="백그라운드에서-컨테이너를-실행하기">백그라운드에서 컨테이너를 실행하기</h2>
<p>컨테이너를 <strong>백그라운드에서 실행</strong>하려면 <code>--detach</code> 옵션을 사용할 수 있습니다.</p>
<p>이 옵션을 사용하면 Nginx 컨테이너와 같이 백그라운드에서 실행되는 상주 프로세스를 시작할 때 터미널이 컨테이너 출력으로 블로킹되지 않습니다.</p>
<p>호스트 머신에서 다음과 같이 실행합니다:</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker container run <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --detach           <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --publish 8080:80  <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    nginx
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">606ccda5b16a0f6ebb8496e20a2abc1da40a48ab4f43aef8bc6d0117ce65fad1</span></span></code></pre></div>
  </figure>
</div>
<p>이제 터미널에는 많은 출력이 표시되지 않고 컨테이너 ID만 표시됩니다.</p>
<p>이 상태에서 컨테이너 목록을 확인하거나 http://localhost:8080에 액세스하면 Nginx 웹 서버에 액세스할 수 있습니다.</p>
<p>컨테이너 목록 확인, 중지 또는 삭제와 같은 작업은 포그라운드에서 실행했을 때와 동일하게 수행할 수 있습니다.</p>
<p>백그라운드에서 실행 중인 컨테이너를 잊지 않고 강제로 삭제해 보세요.</p>
<p>호스트 머신에서 다음과 같이 실행합니다:</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker container rm <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --force           <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    606ccda5b16a0f6ebb8496e20a2abc1da40a48ab4f43aef8bc6d0117ce65fad1</span></span></code></pre></div>
  </figure>
</div>
<p>이 글에서는 기본적으로 <code>--detach</code> 옵션을 지정하도록 하겠지만, 작동 여부를 확인하지 않은 명령을 시행하면서 조립 단계에서는 지정하지 않는 것이 테스트하기 쉽습니다.</p>
<p>상황에 맞게 추가하거나 제거하세요.</p>
<p>또한 당연하지만 bash와 같은 상호작용이 필요한 경우 이 옵션을 사용하지 않습니다.</p>
<h2 id="컨테이너가-중지될-때-자동으로-삭제하기">컨테이너가 중지될 때 자동으로 삭제하기</h2>
<p>컨테이너가 중지될 때 자동으로 삭제하려면 <code>--rm</code> 옵션을 사용하세요.</p>
<p>중지된 컨테이너를 다시 사용하지 않을 경우 이 옵션을 사용하여 중지된 컨테이너가 계속 쌓이는 상태를 방지할 수 있습니다.</p>
<p>호스트 머신에서 다음과 같이 실행합니다:</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker container run <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --rm               <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --detach           <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --publish 8080:80  <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    nginx
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">974b0b8a40d8d1a3c5b693720982c1a47ba948272e124da75c822f0ad0f4e875</span></span></code></pre></div>
  </figure>
</div>
<p><code>--rm</code> 옵션을 지정한 컨테이너는 중지되면 자동으로 삭제되는 것을 확인할 수 있습니다.</p>
<p>호스트 머신에서 다음과 같이 실행합니다:</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker container stop <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    974b0b8a40d8d1a3c5b693720982c1a47ba948272e124da75c822f0ad0f4e875
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">$ docker container ls <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --all
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</span></span></code></pre></div>
  </figure>
</div>
<p>이 글에서는 중지된 컨테이너를 조작하지 않으므로 <code>--rm</code> 옵션은 항상 지정되도록 하겠습니다.</p>
<p>또한 <code>--name</code> 옵션과 함께 자주 사용됩니다.</p>
<h2 id="컨테이너에-이름을-지정하기">컨테이너에 이름을 지정하기</h2>
<p>컨테이너에 <strong>이름을 지정</strong>하려면 <code>--name</code> 옵션을 사용할 수 있습니다. 이 옵션을 사용하면 매번 무작위로 할당되는 컨테이너 이름을 지정할 수 있습니다.</p>
<p>호스트 머신에서 다음과 같이 실행합니다:</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker container run <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --name web-server  <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --rm               <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --detach           <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --publish 8080:80  <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    nginx:1.21
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">1144303f9d718b35bf7a354f51872dde18bffbcdd8ca900a2f7efb5c9fe62d97</span></span></code></pre></div>
  </figure>
</div>
<p>(보이지 않는 부분이 있지만) NAMES가 <code>web-server</code>로 설정되었음을 확인할 수 있습니다.</p>
<p>호스트 머신에서 다음과 같이 실행합니다:</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker container ls
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS          PORTS                  NAMES
</span></span><span class="line"><span class="cl">1144303f9d71   nginx:1.21     <span class="s2">&#34;/docker-entrypoint.…&#34;</span>   <span class="m">35</span> seconds ago   Up <span class="m">35</span> seconds   0.0.0.0:8080-&gt;80/tcp   web-server</span></span></code></pre></div>
  </figure>
</div>
<p>이제 NAMES를 사용하여 컨테이너를 지정할 수 있으므로 컨테이너 ID를 찾는 번거로움을 덜 수 있습니다.</p>
<p>호스트 머신에서 다음과 같이 실행합니다:</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker container stop <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    web-server</span></span></code></pre></div>
  </figure>
</div>
<p>한 가지 주의할 점은 컨테이너 지정에 사용되는 NAMES는 고유해야 하므로 동일한 컨테이너 이름으로 여러 컨테이너를 시작할 수 없습니다. 이 카운트에는 중지된 컨테이너도 포함되므로 이름을 지정한 컨테이너는 중지가 아닌 삭제를 수행하도록 설정하는 것이 불필요한 오류를 줄일 수 있습니다.</p>
<p>따라서 <code>--name</code> 옵션은 보통 <code>--rm</code> 옵션과 함께 사용됩니다.</p>
<p>이 글에서는 명확하고 무작위성이 제거되는 이유로 <code>--name</code> 옵션을 항상 지정하도록 하겠습니다.</p>
<h2 id="컨테이너-시작-시-동작-변경하기">컨테이너 시작 시 동작 변경하기</h2>
<p>컨테이너를 시작할 때의 동작을 변경하려면 옵션은 아니지만 <code>container run</code>의 <code>[command]</code>는 정확히 이해해야 하는 중요한 인수입니다.</p>
<p>따라서 여기서 확인해보겠습니다.</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <pre tabindex="0"><code>$ docker container run [option] &lt;image&gt; [command]</code></pre>
  </figure>
</div>
<p>지금까지 사용한 Nginx 컨테이너는 시작하면 Nginx가 실행되고, Ubuntu 컨테이너는 bash가 실행되었습니다.</p>
<p>이 차이는 이미지의 차이에 의한 것으로, 이미지에는 컨테이너를 시작할 때 어떤 명령을 실행할지 미리 기록되어 있습니다. =</p>
<p>이 글에서는 이를 편의상 &ldquo;기본 명령&quot;이라고 부릅니다.</p>
<p><code>container run</code>에서 <code>[command]</code>를 지정하지 않으면 이미지마다 정해진 기본 명령이 실행됩니다.</p>
<p>그러나 <code>[command]</code>를 지정하면 기본 명령이 아닌 원하는 명령을 실행할 수 있습니다.</p>
<p>이 글에서는 이를 편의상 &ldquo;지정된 명령&quot;이라고 부릅니다.</p>
<p>이를 통해 Nginx 컨테이너에서 nginx를 실행하거나 bash를 실행할 수 있게 됩니다.</p>
<p>Nginx 컨테이너를 기본 명령 (nginx)으로 시작하는 예시 1:</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker container run      <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --name nginx-web-server <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --rm                    <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --detach                <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    nginx</span></span></code></pre></div>
  </figure>
</div>
<p>Nginx 컨테이너를 지정된 명령 (bash)으로 시작하는 예시 2:</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker container run <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --name nginx-bash  <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --rm               <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --interactive      <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --tty              <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    nginx              <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    bash</span></span></code></pre></div>
  </figure>
</div>
<p>여기서 중요한 점은 이미지와 컨테이너 간의 관계를 올바르게 이해하는 것입니다.</p>
<p>예시 2에서 Nginx 컨테이너를 bash로 시작했지만, 이는 예시 1과 다른 Nginx 컨테이너의 bash입니다.</p>
<p>이미지를 OS나 가상 서버와 같은 것으로 생각하면 &ldquo;이미지에 명령을 내려 nginx를 시작하고 SSH를 통해 bash를 사용한다&quot;와 같은 오해를 할 수 있습니다.</p>
<p>하지만 이는 전혀 다릅니다.</p>
<p><code>container run</code>을 실행할 때마다 새로운 컨테이너가 이미지에서 생성되는 것을 명심해야 합니다.</p>
<p>
  <figure>
    <img src="https://blogger.googleusercontent.com/img/a/AVvXsEill0p9-sAu7zl7VaaSiQ8JTPKpB_1Yh4lhFL44N-YZtbDBQUf1JXFYvH01GxVLJmrFDJNsaP46JCCmNMIJ7KOobbQI7MLWeC5xAHo7RUVMF193T2esgDW4QQtwMaCVQnHPHaE16UqPs5-Svl2TzxP6jDPyH8y9NhG9Bl35rjVaLjbOHn2Ui28K4C07mio"
         alt=""
         
         class="img-fluid"
         loading="lazy"
         decoding="async" />
    
  </figure></p>
<p>예시 1의 컨테이너에서 bash를 시작하려면 <code>container exec</code>를 사용해야 합니다.</p>
<p>
  <figure>
    <img src="https://blogger.googleusercontent.com/img/a/AVvXsEjXH3H6GpxJvPZoEa7wbDJNZDI0X19CaHLgGN8Q_dhcO01gL2_L1UZmZVDFXlZckP60VfetdS7W6ZlBwkVLsUAWaeTjtsDnU45kiwrhXz_Tvba15oX05zsRDOn9_Gre1FP84RRwps9RN5KdKFAMlSSL4bcJNVrZc2ckp1PtMK7Zok0PDp0FqbQYnn_XSxU"
         alt=""
         
         class="img-fluid"
         loading="lazy"
         decoding="async" />
    
  </figure></p>
<p>여러 번 강조하지만, 무엇을 어떻게 하는지 잘 고민하면 이러한 오해를 피하고 원활하게 이해할 수 있습니다.</p>
<hr>
<h2 id="컨테이너의-os-아키텍처를-지정하기">컨테이너의 OS 아키텍처를 지정하기</h2>
<p>이 글에서는 세부 사항은 생략하지만, OS 아키텍처를 명시적으로 지정해야 하는 경우 <code>--platform</code> 옵션을 사용합니다.</p>
<p>예를 들어 Docker Hub의 Ubuntu 이미지를 살펴보면 OS/ARCH에 여러 후보가 있는 것을 알 수 있습니다.</p>
<p>
  <figure>
    <img src="https://blogger.googleusercontent.com/img/a/AVvXsEgdXIGPysrfsUXFzgunqTqQjB_xJNHNFBX-y0lIqUYgOPypQOeLQuw87zZtxMm-Q1RpuZMrrOy9nq5WiGPHgdWHxLwUh2cuCGFvK12ggIc7FhrP8aXhyCHZ0tJ2uNznej54hSuAEWjQH7-VdNsEihWsQ0SAItdrN1auZjQhAmQXFWNmehmeUetFVanUOps"
         alt=""
         
         class="img-fluid"
         loading="lazy"
         decoding="async" />
    
  </figure></p>
<p>일반적으로 Intel 또는 AMD CPU를 사용하는 경우(즉, Windows 및 Intel Mac의 경우) <code>linux/amd64</code>를, ARM CPU를 사용하는 경우(M1 Mac의 경우) Docker가 자동으로 선택합니다.</p>
<p><code>linux/amd64</code> 또는 유사한 이미지는 거의 항상 존재하지만, <code>linux/arm64/v8</code>은 존재하지 않는 경우가 흔합니다.</p>
<p>ARM CPU를 사용하지만 <code>linux/arm64/v8</code>이 존재하지 않는 경우 <code>--platform</code> 옵션을 사용하여 강제로 <code>linux/amd64</code> 이미지를 사용합니다.</p>
<p><code>--platform=linux/amd64</code>는 Intel 또는 AMD CPU 사용자에게는 기본 설정과 동일한 결과이므로 영향을 미치지 않습니다.</p>
<p>또한 <code>--platform=linux/arm64/v8</code>을 명시적으로 지정하는 경우가 많지 않습니다.</p>
<p>이 글에서는 필요한 경우에만 <code>--platform=linux/amd64</code>을 지정하도록 하겠습니다.</p>
<p>다음 표를 참조하여 상황에 맞게 해석하고 대응하세요.</p>
<table>
  <thead>
      <tr>
          <th>옵션</th>
          <th>자신의 머신</th>
          <th>결과</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>--platform=linux/amd64</code></td>
          <td>Intel 또는 AMD CPU</td>
          <td>의미 없음</td>
      </tr>
      <tr>
          <td></td>
          <td></td>
          <td>삭제 가능</td>
      </tr>
      <tr>
          <td><code>--platform=linux/amd64</code></td>
          <td>ARM CPU</td>
          <td>중요</td>
      </tr>
      <tr>
          <td></td>
          <td></td>
          <td>그대로 지정</td>
      </tr>
      <tr>
          <td><code>--platform=linux/arm64/v8</code></td>
          <td>Intel 또는 AMD CPU</td>
          <td>거의 보이지 않음</td>
      </tr>
      <tr>
          <td></td>
          <td></td>
          <td>이 글에는 없음</td>
      </tr>
      <tr>
          <td><code>--platform=linux/arm64/v8</code></td>
          <td>ARM CPU</td>
          <td>의미 없음</td>
      </tr>
      <tr>
          <td></td>
          <td></td>
          <td>거의 보이지 않음</td>
      </tr>
      <tr>
          <td></td>
          <td></td>
          <td>이 글에는 없음</td>
      </tr>
  </tbody>
</table>
<p>참고로, 호스트 머신과 일치하는 OS/ARCH가 존재하지 않는 경우 <code>--platform</code> 옵션만으로 충분한지는 이미지에 따라 다릅니다.</p>
<h2 id="요약-1">요약</h2>
<p>지금까지 배운걸 요약하면:</p>
<ul>
<li><code>--interactive</code> 옵션은 상호작용이 필요한 경우에 지정하고, 항상 지정해도 문제가 없습니다.</li>
<li><code>--tty</code> 옵션은 상호작용이 필요한 경우에 지정하고, 항상 지정해도 문제가 없습니다.</li>
<li><code>--detach</code> 옵션은 상호작용이 필요하지 않은 경우에 지정하며, 디버깅 등의 상황에서는 제외하는 것이 좋습니다.</li>
<li><code>--rm</code> 옵션은 항상 지정합니다. 중지된 컨테이너를 활용할지 여부에 따라 결정합니다.</li>
<li><code>--name</code> 옵션은 항상 지정합니다. 이름을 지정하면 충돌을 피하기 쉽습니다.</li>
<li><code>--platform</code> 옵션은 필요한 경우에만 지정합니다. Intel 또는 AMD CPU의 경우 고려할 필요가 없으며, ARM CPU의 경우 상황에 따라 다릅니다. 이 글에서는 필요한 경우에만 <code>--platform=linux/amd64</code>을 지정합니다.</li>
</ul>
<hr>
<h1 id="컨테이너-상태-변화">컨테이너 상태 변화</h1>
<h2 id="컨테이너-상태-및-프로세스-이해하기"><strong>컨테이너 상태 및 프로세스 이해하기</strong></h2>
<p>컨테이너가 의도한 대로 작동하는지 확인하기 위해 컨테이너의 상태 변화를 정확히 이해해 보겠습니다.</p>
<p>컨테이너가 왜 중단되는지 이해하지 못하면 &ldquo;실행했던 컨테이너가 사라졌다&rdquo; 또는 &ldquo;터미널이 멈춰서 실행에 실패했다&quot;와 같은 오해를 할 수 있습니다.</p>
<h2 id="컨테이너와-프로세스"><strong>컨테이너와 프로세스</strong></h2>
<p>컨테이너를 실행하는 방법을 배웠으니, 몇 가지 컨테이너를 실행하고 프로세스를 확인해 보겠습니다.</p>
<h3 id="예제-1-ubuntu-컨테이너를-기본-명령어-bash로-실행"><strong>예제 1: Ubuntu 컨테이너를 기본 명령어 (bash)로 실행</strong></h3>
<p>Ubuntu 컨테이너를 실행하고 기본 명령어인 bash를 사용하여 컨테이너 내의 프로세스 목록을 ps 명령어로 확인하면, PID 1이 bash인 것을 알 수 있습니다.</p>
<p>또한 ps 명령어 자체도 프로세스로 존재합니다.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker container run <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --name ubuntu1     <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --rm               <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --interactive      <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --tty              <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    ubuntu:20.04
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># ps</span>
</span></span><span class="line"><span class="cl">  PID TTY          TIME CMD
</span></span><span class="line"><span class="cl">    <span class="m">1</span> pts/0    00:00:00 bash
</span></span><span class="line"><span class="cl">   <span class="m">10</span> pts/0    00:00:00 ps</span></span></code></pre></div>
  </figure>
</div>
<h3 id="예제-2-nginx-컨테이너를-기본-명령어-nginx로-실행"><strong>예제 2: Nginx 컨테이너를 기본 명령어 (nginx)로 실행</strong></h3>
<p>Nginx 컨테이너를 실행하고 기본 명령어인 웹 서버가 실행된 상태에서 PID 1은 nginx의 시작 명령어입니다.</p>
<p>또한 ps 명령어를 실행하기 위해 container exec로 실행한 bash 프로세스도 존재합니다.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker container run <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --name nginx1      <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --rm               <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --detach           <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    nginx
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">$ docker container <span class="nb">exec</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --interactive       <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --tty               <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    nginx1              <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    bash
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 컨테이너 내에 ps 명령어가 없으므로 설치</span>
</span></span><span class="line"><span class="cl"><span class="c1"># apt update</span>
</span></span><span class="line"><span class="cl"><span class="c1"># apt install -y procps</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># ps x</span>
</span></span><span class="line"><span class="cl">  PID TTY      STAT   TIME COMMAND
</span></span><span class="line"><span class="cl">    <span class="m">1</span> ?        Ss     0:00 nginx: master process nginx -g daemon off<span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="m">36</span> pts/0    Ss     0:00 bash
</span></span><span class="line"><span class="cl">  <span class="m">387</span> pts/0    R+     0:00 ps x</span></span></code></pre></div>
  </figure>
</div>
<p>마지막으로, 컨테이너를 실행할 때 &ndash;tty 옵션을 지정하지 않았기 때문에 TTY가 ?로 표시되었습니다.</p>
<h3 id="예제-3-nginx-컨테이너를-지정한-명령-bash으로-실행"><strong>예제 3: Nginx 컨테이너를 지정한 명령 (bash)으로 실행</strong></h3>
<p>Nginx 컨테이너를 기본 명령어인 nginx가 아닌 지정한 명령어인 bash로 실행한 상태에서 PID 1은 bash입니다.</p>
<p>또한 ps 프로세스는 존재하지만 nginx 프로세스는 없습니다.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker container run <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --name nginx2      <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --rm               <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --interactive      <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --tty              <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    nginx              <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    bash
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 컨테이너 내에 ps 명령어가 없으므로 설치</span>
</span></span><span class="line"><span class="cl"><span class="c1"># apt update</span>
</span></span><span class="line"><span class="cl"><span class="c1"># apt install -y procps</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># ps</span>
</span></span><span class="line"><span class="cl">  PID TTY          TIME CMD
</span></span><span class="line"><span class="cl">    <span class="m">1</span> pts/0    00:00:00 bash
</span></span><span class="line"><span class="cl">  <span class="m">346</span> pts/0    00:00:00 ps</span></span></code></pre></div>
  </figure>
</div>
<h2 id="컨테이너와-프로세스의-관계"><strong>컨테이너와 프로세스의 관계</strong></h2>
<p>컨테이너는 Namespace를 통해 격리된 프로세스라는 것을 &ldquo;Docker를 이해하기 위한 핵심&quot;에서 배웠습니다.</p>
<p>또한 컨테이너에는 이미지에 의해 정의된 기본 명령이 있으며, container run 실행 시 임의의 명령을 지정할 수 있다는 것을 &ldquo;컨테이너 시작 시 기본 지정&quot;에서 배웠습니다.</p>
<p>이 페이지에서 확인한 프로세스와 이전 페이지에서 배운 내용을 통합하면 다음과 같이 이해할 수 있습니다.</p>
<ul>
<li>컨테이너는 특정한 명령을 실행하기 위해 시작됩니다.</li>
<li>이 명령은 기본 명령이거나 지정한 명령 중 하나이며, PID가 1이 됩니다.</li>
<li>여러 컨테이너의 PID = 1은 Linux의 Namespace 기능으로 인해 충돌하지 않습니다.</li>
</ul>
<p>이 글에서는 편의상 PID = 1인 프로세스를 &ldquo;메인 프로세스&quot;라고 하고, 이를 시작하는 명령을 &ldquo;메인 명령&quot;이라고 부릅니다.</p>
<p>컨테이너는 메인 프로세스를 실행하기 위해 시작된다는 점을 기억하면 컨테이너를 더 원활하게 이해할 수 있습니다.</p>
<p>예를 들어 컨테이너가 가상 서버가 아닌 단순한 1개의 프로세스로 보인다면 &ldquo;Ubuntu에 PHP, MySQL 및 Apache를 설치한 컨테이너를 만들자&quot;가 아니라 &ldquo;PHP, MySQL 및 Apache가 필요하므로 3개의 컨테이너를 만들자&quot;라는 생각으로 자연스럽게 전환될 것입니다.</p>
<p>또한 메인 프로세스가 종료된 컨테이너는 자동으로 중지된다는 중요한 사실을 이해하게 될 것입니다.</p>
<h2 id="컨테이너가-종료되는-경우"><strong>컨테이너가 종료되는 경우</strong></h2>
<p>이전에 배운 내용을 기반으로 컨테이너가 종료되는 두 가지 주요 이유를 설명하겠습니다.</p>
<h3 id="1-컨테이너를-직접-중지하는-경우">1. <strong>컨테이너를 직접 중지하는 경우</strong></h3>
<p>Nginx 컨테이너를 기본 명령어 (nginx)로 다음과 같이 실행합니다.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker container run <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --name nginx3      <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --rm               <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --detach           <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    nginx:1.21</span></span></code></pre></div>
  </figure>
</div>
<p>실행된 Nginx는 웹 서버이므로 메인 프로세스가 종료되지 않는 한 계속 실행됩니다.</p>
<p>메인 프로세스는 자동으로 종료되지 않으므로 컨테이너는 중지하거나 삭제할 때까지 계속 실행됩니다.</p>
<h3 id="2-메인-프로세스가-종료되는-경우">2. <strong>메인 프로세스가 종료되는 경우</strong></h3>
<p>이 경우 두 가지 하위 케이스로 나누어 확인합니다.</p>
<h4 id="2-a-사용자가-메인-프로세스를-직접-종료하는-경우">2-A. <strong>사용자가 메인 프로세스를 직접 종료하는 경우</strong></h4>
<p>동일한 Nginx 컨테이너를 지정한 명령어 (bash)로 다음과 같이 실행합니다.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker container run <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --name nginx4      <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --rm               <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --interactive      <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --tty              <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    nginx:1.21         <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    bash
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 어떤 작업 수행</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 어떤 작업 수행</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># exit</span></span></span></code></pre></div>
  </figure>
</div>
<p>실행된 bash는 exit할 수 있으므로 메인 프로세스는 언젠가 종료됩니다.</p>
<p>메인 프로세스가 종료되면 컨테이너도 연쇄적으로 중지됩니다.</p>
<h4 id="2-b-메인-프로세스가-자동으로-종료되는-경우">2-B. <strong>메인 프로세스가 자동으로 종료되는 경우</strong></h4>
<p>마지막으로 동일한 Nginx 컨테이너를 지정한 명령어 (ls)로 다음과 같이 실행합니다.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker container run <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --name nginx5      <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --rm               <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    nginx:1.21         <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    ls /etc/nginx
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$</span></span></code></pre></div>
  </figure>
</div>
<p>실행된 ls는 결과만 표시하므로 메인 프로세스는 즉시 종료됩니다.</p>
<p>메인 프로세스가 즉시 종료되므로 컨테이너도 즉시 중지됩니다.</p>
<p>컨테이너가 실행되는 동안 실제로 존재하는 시간은 거의 없으므로 실행 중인 컨테이너에 강제 삭제 명령을 내리는 것은 불가능합니다.</p>
<h2 id="즉시-중지와-백그라운드-실행에-대하여"><strong>즉시 중지와 백그라운드 실행에 대하여</strong></h2>
<p>즉시 중지와 백그라운드 실행 (<code>--detach</code> 옵션)을 혼동하지 않도록 주의해야 합니다.</p>
<p>컨테이너의 상태나 컨테이너 시작의 성공 여부는 <code>container run</code> 이후 터미널이 멈췄는지 여부로 판단해서는 안 됩니다.</p>
<p>간단한 기억 방법을 사용하지 않도록 주의하세요.</p>
<table>
  <thead>
      <tr>
          <th>메인 명령어</th>
          <th>옵션</th>
          <th>터미널</th>
          <th>컨테이너</th>
          <th>메인 프로세스</th>
          <th>시작 명령어 실행 결과</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>nginx</td>
          <td></td>
          <td>멈춤</td>
          <td>실행 중</td>
          <td>실행 중</td>
          <td>정상</td>
      </tr>
      <tr>
          <td>nginx</td>
          <td>&ndash;detach</td>
          <td>멈추지 않음</td>
          <td>실행 중</td>
          <td>실행 중</td>
          <td>정상</td>
      </tr>
      <tr>
          <td>ls</td>
          <td></td>
          <td>멈추지 않음</td>
          <td>중지됨</td>
          <td>종료됨</td>
          <td>정상 (종료)</td>
      </tr>
  </tbody>
</table>
<h2 id="요약-2"><strong>요약</strong></h2>
<ul>
<li>컨테이너는 메인 프로세스 (PID = 1)를 실행하기 위해 시작됩니다.</li>
<li>컨테이너가 종료되는 이유는 크게 두 가지입니다.
<ol>
<li>컨테이너를 중지하는 경우</li>
<li>메인 프로세스가 종료되는 경우</li>
</ol>
</li>
<li>즉시 중지와 백그라운드 실행 (<code>--detach</code> 옵션)을 혼동하지 않도록 주의하세요.</li>
</ul>
<hr>
<h1 id="컨테이너-상태-유지">컨테이너 상태 유지</h1>
<p>컨테이너의 상태에 대해 두 가지 관점에서 살펴보겠습니다.</p>
<h2 id="1-동일한-이미지에서-시작하더라도-다른-컨테이너입니다">1. <strong>동일한 이미지에서 시작하더라도 다른 컨테이너입니다.</strong></h2>
<p>이는 <code>CONTAINER ID</code>를 확인하면 명확합니다.</p>
<p>첫 번째 Nginx 컨테이너를 기본 명령어 (nginx)로 다음과 같이 실행합니다.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker container run <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --name nginx1      <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --rm               <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --detach           <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    nginx:1.21</span></span></code></pre></div>
  </figure>
</div>
<p>두 번째 Nginx 컨테이너를 기본 명령어 (nginx)로 다음과 같이 실행합니다.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker container run <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --name nginx2      <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --rm               <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --detach           <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    nginx:1.21</span></span></code></pre></div>
  </figure>
</div>
<p>컨테이너 목록을 확인하면 서로 다른 <code>CONTAINER ID</code>를 가진 두 개의 컨테이너가 실행 중임을 확인할 수 있습니다.</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker container ls
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">CONTAINER ID   IMAGE          COMMAND                  CREATED         STATUS         PORTS     NAMES
</span></span><span class="line"><span class="cl">770f08892af6   nginx:1.21     <span class="s2">&#34;/docker-entrypoint.…&#34;</span>   <span class="m">4</span> seconds ago   Up <span class="m">3</span> seconds   80/tcp    nginx2
</span></span><span class="line"><span class="cl">abff10020aa4   nginx:1.21     <span class="s2">&#34;/docker-entrypoint.…&#34;</span>   <span class="m">7</span> seconds ago   Up <span class="m">6</span> seconds   80/tcp    nginx1</span></span></code></pre></div>
  </figure>
</div>
<p>이름은 같지만, 이전과는 다른 <code>CONTAINER ID</code>를 가지므로 더 이상 다른 컨테이너입니다.</p>
<h2 id="2-컨테이너에서-수행한-작업은-다른-컨테이너에-영향을-주지-않습니다">2. <strong>컨테이너에서 수행한 작업은 다른 컨테이너에 영향을 주지 않습니다.</strong></h2>
<p>컨테이너는 독립적으로 실행되며 다른 컨테이너에 영향을 미치지 않습니다.</p>
<p>예를 들어, 첫 번째 Nginx 컨테이너에서 파일을 생성하거나 수정하더라도 두 번째 Nginx 컨테이너에는 영향을 주지 않습니다.</p>
<p>이는 컨테이너의 격리된 환경과 독립성 때문입니다.</p>
<p>
  <figure>
    <img src="https://blogger.googleusercontent.com/img/a/AVvXsEjrN2pCT6DfvESCJXAFOBjU4ugmRf8scM52o0a1V3JobR4lUX3Ff3ag_3XljikLZ-4lDKIKWdAJuosTY1MAPaj9H9GSYJUcantkKH5GMqfxhZ6afja-TBm_CqoTdYO4-lcLVO1TlzOF7cKzTHfFmYGVPwK0ZCBIWAA25ZPTstLa7JOurgt7oq78M-NA6So"
         alt=""
         
         class="img-fluid"
         loading="lazy"
         decoding="async" />
    
  </figure></p>
<h2 id="컨테이너에서-수행한-작업은-다른-컨테이너에-영향을-주지-않습니다"><strong>컨테이너에서 수행한 작업은 다른 컨테이너에 영향을 주지 않습니다.</strong></h2>
<p>이를 확인하기 위해 다음과 같이 시도해 보겠습니다.</p>
<ol>
<li>첫 번째 Ubuntu 컨테이너를 기본 명령어 (bash)로 실행합니다.</li>
</ol>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker container run <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --name ubuntu1     <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --rm               <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --interactive      <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --tty              <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    ubuntu:20.04</span></span></code></pre></div>
  </figure>
</div>
<ol start="2">
<li>두 번째 Ubuntu 컨테이너를 기본 명령어 (bash)로 실행합니다.</li>
</ol>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker container run <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --name ubuntu2     <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --rm               <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --interactive      <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --tty              <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    ubuntu:20.04</span></span></code></pre></div>
  </figure>
</div>
<ol start="3">
<li>ubuntu1 컨테이너에서 <code>vi</code>를 설치하고 <code>~/hello.txt</code> 파일을 생성합니다.</li>
</ol>
<p>컨테이너 (ubuntu1):</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># apt update</span>
</span></span><span class="line"><span class="cl"><span class="c1"># apt install -y vim</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># vi ~/hello.txt</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>hello world를 입력하고 :wq로 저장하고 종료<span class="o">)</span></span></span></code></pre></div>
  </figure>
</div>
<ol start="4">
<li>이제 ubuntu2 컨테이너에서 <code>vi</code> 명령어를 실행하면 <code>vi</code>가 존재하지 않음을 확인할 수 있습니다.</li>
</ol>
<p>컨테이너 (ubuntu2):</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># vi</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">bash: vi: <span class="nb">command</span> not found</span></span></code></pre></div>
  </figure>
</div>
<ol start="5">
<li>또한 <code>~/hello.txt</code> 파일도 존재하지 않습니다.</li>
</ol>
<p>컨테이너 (ubuntu2):</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># cat ~/hello.txt</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">cat: ~/hello.txt: No such file or directory</span></span></code></pre></div>
  </figure>
</div>
<p>이를 통해 컨테이너에서 수행한 작업이 다른 컨테이너에 영향을 주지 않음을 확인할 수 있습니다.</p>
<p>
  <figure>
    <img src="https://blogger.googleusercontent.com/img/a/AVvXsEgKNCAaVK6t36m8JKkfRsaq2l2yL1s51zi_97-DeAHKRtd-KZYhjaKBstuw4hhxDiEYgpfxZA8K14UAnIV4TBz0J7rnSYgZzm8_px3B5maH1Rn_9ThV6pa_42PsEMuO2YPoLEzlyzumWK2tG7QuK-GY14MXNfiOdV2vFBHKUMspWy4POboZfvUzvgv_QBM"
         alt=""
         
         class="img-fluid"
         loading="lazy"
         decoding="async" />
    
  </figure></p>
<h2 id="컨테이너의-상태-변경을-다른-컨테이너에-반영하려면">컨테이너의 상태 변경을 다른 컨테이너에 반영하려면</h2>
<p>이를 위해 크게 두 가지 방법이 있습니다.</p>
<p>모든 컨테이너에 구성 변경을 반영하려면 이미지를 만듭니다.</p>
<p>어떤 컨테이너에서든 vi를 사용하고 싶다면 “Dockerfile에서 vi가 포함된 이미지를 만들어 두는” 방법을 사용할 수 있습니다.</p>
<p>
  <figure>
    <img src="https://blogger.googleusercontent.com/img/a/AVvXsEgb5ishEzfUNDbKrwQ_fi_HXvgaBPZEeytX5tULr_i-hfysp_V_K6ik3qHG-aH-VrBxgE_GLH1RHGqMdJBOYFBNC_IA4wO-TSgsbnCpkqtsS6p2ZEuKlG6mrDpVsH4yWM76_hW2GM270ZUUY-WvYTj1aDDt3c32aLsOe5ziBDss6JQiexY2jyWhWZHKODg"
         alt=""
         
         class="img-fluid"
         loading="lazy"
         decoding="async" />
    
  </figure></p>
<p>이렇게 하면 &ldquo;매번 컨테이너를 시작할 때마다 vi를 설치하는 것&quot;이 아니라 “vi가 포함된 컨테이너를 시작하는” 것이 가능합니다.</p>
<h2 id="파일을-유지하려면-호스트-머신과-공유하세요">파일을 유지하려면 호스트 머신과 공유하세요.</h2>
<p><code>~/hello.txt</code> 파일을 유지하고 싶다면 &ldquo;호스트 머신과 파일을 공유&quot;하는 방법을 사용할 수 있습니다.</p>
<p>
  <figure>
    <img src="https://blogger.googleusercontent.com/img/a/AVvXsEjQNgQx9vLaaQiFw5nohm1SNWc2u9KD3GBK7cYinfeIjd3aiKz2uCKDaRJjNOYgSntkO1poJMTkhgogEEJE2kX2H042LUQzs08jIpDe8xEh8jlZ_XS4K8eQIjtHTiqW9y_Wq7bOickhcWsfdakkBhpg_ojZyPkdSlxNP0R4MMKxv8ISiFfR8k2eUZoC1Zo"
         alt=""
         
         class="img-fluid"
         loading="lazy"
         decoding="async" />
    
  </figure></p>
<p>이렇게 하면 &ldquo;매번 컨테이너를 시작할 때마다 파일을 생성하는 것&quot;이 아니라 “컨테이너를 시작한 후 호스트 머신의 파일을 사용하는” 것이 가능합니다.</p>
<p>자세한 내용은 다음에 배울 &ldquo;볼륨&quot;과 &ldquo;바인드 마운트&quot;에서 설명하겠습니다.</p>
<h2 id="요약-3"><strong>요약</strong></h2>
<ul>
<li>컨테이너는 매번 시작할 때마다 다른 컨테이너입니다.</li>
<li>컨테이너에서 수행한 작업은 다른 컨테이너에 영향을 주지 않습니다.</li>
<li>다른 컨테이너에 변경 사항을 반영하려면 어떤 처리가 필요합니다.
<ul>
<li>Dockerfile</li>
<li>볼륨 또는 바인드 마운트</li>
</ul>
</li>
</ul>
<hr>
<h1 id="컨테이너에-연결하기">컨테이너에 연결하기</h1>
<p>container exec 명령어는 컨테이너 내에서 프로그램을 실행하거나 상호작용하는 데 사용되는 중요한 도구입니다.</p>
<p>컨테이너를 개발하거나 배포할 때 현재 상태를 확인하거나 문제를 디버깅하는 데 유용합니다.</p>
<p>이 글에서는 docker exec 명령어에 대해 배우고 실행 중인 Docker 컨테이너에서 명령을 실행하고 대화형 쉘을 얻는 방법을 알아보겠습니다.</p>
<h2 id="컨테이너-내에서-명령-실행하기">컨테이너 내에서 명령 실행하기</h2>
<p><code>docker container exec</code></p>
<p>새로운 버전</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker container <span class="nb">exec</span> <span class="o">[</span>옵션<span class="o">]</span> &lt;컨테이너&gt; 명령</span></span></code></pre></div>
  </figure>
</div>
<p>예전 버전</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker <span class="nb">exec</span> <span class="o">[</span>옵션<span class="o">]</span> &lt;컨테이너&gt; 명령</span></span></code></pre></div>
  </figure>
</div>
<h3 id="옵션-설명-2">옵션 설명</h3>
<ul>
<li><code>-i</code>, <code>--interactive</code>: 컨테이너의 표준 입력에 연결합니다. 컨테이너를 대화식으로 조작할 수 있습니다.</li>
<li><code>-t</code>, <code>--tty</code>: 의사 터미널을 할당합니다. 컨테이너를 대화식으로 조작할 수 있습니다.</li>
</ul>
<h2 id="실행-중인-컨테이너에서-명령-실행하기">실행 중인 컨테이너에서 명령 실행하기</h2>
<p><code>container exec</code>는 실행 중인 컨테이너에 명령을 보내는 명령입니다.</p>
<p>이 명령은 컨테이너 내에서 Linux 명령을 실행하는데 사용됩니다.</p>
<p>예를 들어, Ubuntu 컨테이너를 기본 명령 (bash)으로 시작하고 <code>~/hello.txt</code> 파일을 생성해 보겠습니다.</p>
<p>호스트 머신에서 다음과 같이 실행합니다:</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker container run <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --name ubuntu1     <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --rm               <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --interactive      <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --tty              <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    ubuntu:20.04
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># echo &#39;hello world&#39; &gt; ~/hello.txt</span></span></span></code></pre></div>
  </figure>
</div>
<p>이제 이 bash 세션을 종료하지 않고 다른 탭에서 컨테이너에 <code>cat</code> 명령을 실행해 보겠습니다:</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker container <span class="nb">exec</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    ubuntu1             <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    cat ~/hello.txt</span></span></code></pre></div>
  </figure>
</div>
<p>결과로 <code>hello world</code>를 확인할 수 있습니다.</p>
<p>이렇게 파일을 확인하는 것은 당연한 일일 수 있지만, 다음과 같은 중요한 차이점을 이해하지 않으면 불필요한 문제가 발생할 수 있습니다:</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker container run <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    ubuntu:20.04       <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    cat ~/hello.txt
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">cat: ~/hello.txt: No such file or directory</span></span></code></pre></div>
  </figure>
</div>
<p>
  <figure>
    <img src="https://blogger.googleusercontent.com/img/a/AVvXsEjSfQ3m2G-vzKePUYdm_eR1ahbLRYAlsqE3LybONd5djJf9Eeye0WSPZvLK21NXrvAFUjvyd0gkIOXQf95Y8c1bkN3-yLmnL_i93JT1_KMPr8HeGjxtXNH4vL9x63vKw1F5UOmH0ZavaIAvL6ltkGk_bWCAwptlJt8Inb1tTVoz2dYwg0qb4V5g8L4s9Gg"
         alt=""
         
         class="img-fluid"
         loading="lazy"
         decoding="async" />
    
  </figure></p>
<p><code>container run</code>과 <code>container exec</code>는 모두 Linux 명령을 지정할 수 있지만, 실행 중인 컨테이너에 명령을 보내는 것과 이미지에서 컨테이너를 시작하는 것은 결정적으로 다릅니다.</p>
<h2 id="컨테이너에-연결하기-1">컨테이너에 연결하기</h2>
<p>실제로 구축하거나 디버깅할 때는 한 번에 하나씩 <code>ls</code>와 같은 명령을 실행하는 대신 실행 중인 컨테이너의 bash를 직접 사용하고 싶을 때가 있습니다.</p>
<p><code>bash</code>도 <code>cat</code>이나 <code>ls</code>와 같은 Linux 프로세스이므로 <code>container exec</code>를 사용하여 실행할 수 있습니다.</p>
<p>다음 명령을 사용하여 <code>ubuntu1</code> 컨테이너에 <code>bash</code>를 실행해 보겠습니다.</p>
<p>상호 작용을 위해 <code>container run</code>과 동일한 옵션이 필요합니다.</p>
<p>호스트 머신에서 다음과 같이 실행합니다:</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker container <span class="nb">exec</span>  <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --interactive        <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --tty                <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    ubuntu1              <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    bash</span></span></code></pre></div>
  </figure>
</div>
<p>프롬프트가 <code>#</code>로 변경되면 Ubuntu 컨테이너의 <code>bash</code>로 전환되었습니다.</p>
<p>일반적으로와 같이 작업할 수 있습니다.</p>
<p>컨테이너 내에서 다음과 같은 명령을 실행해 보겠습니다:</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># pwd</span>
</span></span><span class="line"><span class="cl">/
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># date</span>
</span></span><span class="line"><span class="cl">Tue Feb <span class="m">15</span> 15:18:23 UTC <span class="m">2022</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># whoami</span>
</span></span><span class="line"><span class="cl">root
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># cat ~/hello.txt</span>
</span></span><span class="line"><span class="cl">hello world
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># exit</span></span></span></code></pre></div>
  </figure>
</div>
<p><code>container exec</code>는 다음과 같은 상황에서 매우 유용합니다.</p>
<p>이를 제대로 이해하고 사용할 수 있도록 노력해 보세요:</p>
<ul>
<li>컨테이너 내의 로그를 확인하고 싶을 때</li>
<li>Dockerfile을 작성하기 전에 <code>bash</code>에서 설치 명령을 시험해 보고 싶을 때</li>
<li>MySQL 데이터베이스 서버의 클라이언트 <code>mysql</code>을 직접 조작하고 싶을 때</li>
</ul>
<p><code>ubuntu1</code> 컨테이너는 더 이상 중지하지 않아도 됩니다.</p>
<p>호스트 머신에서 다음과 같이 실행합니다:</p>



<div class="expressive-code">
  <figure class="frame is-terminal not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ docker container stop <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    ubuntu1</span></span></code></pre></div>
  </figure>
</div>
<h2 id="참고-컨테이너에-ssh-연결에-대한-오해">(참고) 컨테이너에 SSH 연결에 대한 오해</h2>
<p>컨테이너나 <code>container exec</code>에 대해 정확히 이해하지 못하면 Docker 컨테이너 SSH와 같은 검색을 하게 될 수 있습니다.</p>
<p>실제로 이를 검색하면 컨테이너에 <code>sshd</code>라는 SSH를 수신 대기하는 데몬 프로세스를 실행하는 절차도 찾을 수 있습니다.</p>
<p>그러나 컨테이너에 SSH 연결은 다음과 같은 이유로 권장되지 않습니다:</p>
<ul>
<li>SSH를 위한 확장을 추가한 이미지를 만들어야 합니다.</li>
<li>이미지나 Dockerfile과 별도로 키, 암호 등을 관리해야 하며, 취약성 대응과 같은 비용이 증가합니다.</li>
<li>SSH 지원이 포함된 이미지를 그대로 배포하면 원래는 없었던 취약성이 증가할 수 있습니다.</li>
</ul>
<p>SSH를 사용하고 싶은 생각은 이미지를 가상 서버와 같은 것으로 간주하거나 <code>container exec</code>와 <code>container run</code>의 차이를 이해하지 못했을 때 발생하기 쉽습니다.</p>
<p>저도 처음에는 Docker 컨테이너 SSH로 Google 검색을 한 기억이 있습니다.</p>
<p>
  <figure>
    <img src="https://blogger.googleusercontent.com/img/a/AVvXsEjXH3H6GpxJvPZoEa7wbDJNZDI0X19CaHLgGN8Q_dhcO01gL2_L1UZmZVDFXlZckP60VfetdS7W6ZlBwkVLsUAWaeTjtsDnU45kiwrhXz_Tvba15oX05zsRDOn9_Gre1FP84RRwps9RN5KdKFAMlSSL4bcJNVrZc2ckp1PtMK7Zok0PDp0FqbQYnn_XSxU"
         alt=""
         
         class="img-fluid"
         loading="lazy"
         decoding="async" />
    
  </figure></p>
<p>작업을 수행하려면 <code>container exec</code>를 사용하여 컨테이너 내에서 <code>bash</code>를 실행하면 됩니다.</p>
<h2 id="요약-4">요약</h2>
<p>요약하자면:</p>
<ul>
<li><code>container exec</code>를 사용하여 실행 중인 컨테이너에 명령을 보낼 수 있습니다.</li>
<li><code>container run</code>과 <code>container exec</code>를 혼동하지 말아야 합니다.</li>
<li>SSH 연결은 하지 말고 bash 명령어를 되도록 사용합시다.</li>
</ul>

      <div class="tag-list-single">
        <a class="btn btn-light" href="/tags/docker/" role="button">docker</a>
        <a class="btn btn-light" href="/tags/container/" role="button">container</a>
        </div>
      
      <ins class="adsbygoogle"
          style="display:block"
          data-ad-format="autorelaxed"
          data-ad-client="ca-pub-7748316956330968"
          data-ad-slot="4495825428"></ins>
      <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
      </script>
    </div>
  </div>
</article>

      
      </div>
    </div>
    
    
<div class="bg-light">
    <section class="section section-related container">
      <div class="row justify-content-center">
        <div class="col-md-12 col-lg-12">
          <h2 class="section-title text-center">Related posts</h2>
        </div>
      </div>
      <div class="row justify-content-center">
        <div class="col-lg-12">
          <div class="card">
              <div class="card-body">
                <article>
                  <h2 class="h3"><a class="stretched-link text-body" href="/blog/2024-04-06-docker-tutorial-docker-compose-complete-guide/">Docker 강좌 6편. Docker Compose 완벽 가이드</a></h2>
                  <p>Docker Compose 완벽 가이드</p>
                  <p>
  <small>April 6, 2024<span class="stretched-link position-relative reading-time text-nowrap" title="Estimated reading time"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
        <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
        <path d="M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0"></path>
        <path d="M12 7v5l3 3"></path>
      </svg>9&nbsp;minutes</span></small>
</p>
</article>
              </div>
            </div>
          <div class="card">
              <div class="card-body">
                <article>
                  <h2 class="h3"><a class="stretched-link text-body" href="/blog/2024-04-06-docker-tutorial-understanding-bind-mount-and-port-publish/">Docker 강좌 5편. 바인드 마운트와 포트 publish</a></h2>
                  <p>Docker 바인드 마운트와 포트 publish</p>
                  <p>
  <small>April 6, 2024<span class="stretched-link position-relative reading-time text-nowrap" title="Estimated reading time"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
        <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
        <path d="M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0"></path>
        <path d="M12 7v5l3 3"></path>
      </svg>5&nbsp;minutes</span></small>
</p>
</article>
              </div>
            </div>
          <div class="card">
              <div class="card-body">
                <article>
                  <h2 class="h3"><a class="stretched-link text-body" href="/blog/2024-04-06-docker-volume-usage-and-principles/">Docker 강좌 4편. Docker 볼륨 (Volume) 사용 방법과 원리</a></h2>
                  <p>Docker 볼륨 (Volume) 사용 방법과 원리</p>
                  <p>
  <small>April 6, 2024<span class="stretched-link position-relative reading-time text-nowrap" title="Estimated reading time"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
        <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
        <path d="M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0"></path>
        <path d="M12 7v5l3 3"></path>
      </svg>7&nbsp;minutes</span></small>
</p>
</article>
              </div>
            </div>
          </div>
      </div>
    </section>
    <script src="https://utteranc.es/client.js"
      repo="cpro95/utterances_mycodings_fly_dev"
      issue-term="pathname"
      theme="github-light"
      label="blog-comment"
      crossorigin="anonymous"
    async>
    </script>
  </div>
  
    <footer class="footer text-muted">
  <div class="container-lg">
    <div class="row">
      <div class="col-lg-8 text-center text-lg-start">
        <ul class="list-inline">
          <li class="list-inline-item"><a class="text-muted" href="/about/">about</a></li>
        </ul>
      </div>
      <div class="col-lg-8 text-center text-lg-end">
        <ul class="list-inline">
          <li class="list-inline-item">Copyright (c) All Right Reserved.</li>
        </ul>
      </div>
    </div>
  </div>
</footer>

    

<script async
  src="/js/app.19b73e0182301dd61c9211c2f6890104740e2eb9eb12fe4ba8d4f31435b22ed6.js"
  integrity="sha256-Gbc&#43;AYIwHdYckhHC9okBBHQOLrnrEv5LqNTzFDWyLtY=">
</script>





<script async
  src="/js/flexsearch.5dd6433c29c3e043627f046054aed58ff3790f58fdb8423f45125bbafdcad335.js"
  integrity="sha256-XdZDPCnD4ENifwRgVK7Vj/N5D1j9uEI/RRJbuv3K0zU=">
</script>
<script async
  src="/js/search-modal.96e662d8f691fe25c859a3437074b485f2d7bed0bca612725028c6cf4322e2f2.js"
  integrity="sha256-luZi2PaR/iXIWaNDcHS0hfLXvtC8phJyUCjGz0Mi4vI=">
</script>

    <div class="d-inline-flex fixed-bottom-right pb-4 pe-4">
  <button id="toTop" type="button" class="btn btn-primary rounded-circle ms-auto p-2"><span class="visually-hidden">Top</span><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-up" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M6 15l6 -6l6 6"></path></svg></button>
</div>

    
  </body>
</html>
